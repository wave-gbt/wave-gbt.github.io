<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用 LinkedHashMap 实现 LRU Cache]]></title>
    <url>%2F%E5%88%A9%E7%94%A8-LinkedHashMap-%E5%AE%9E%E7%8E%B0-LRU-Cache.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[使用 Optional 解决 NPE 问题]]></title>
    <url>%2FSolve-NPE-problems-with-Optional.html</url>
    <content type="text"><![CDATA[NPE(NullPointerException) 是 Java 程序开发中的最典型的异常，从Java类型系统的角度看，null可以被赋值给任何类型的变量，并且不断被传递，知道最后谁也不知道它是从哪里引入的。 场景先看一种情况1user.getAddress().getProvince(); 这种写法，在user或者address为null时，是有可能报NullPointerException异常的。为了解决这个问题，于是采用下面的写法123456if(user!=null)&#123; Address address = user.getAddress(); if(address!=null)&#123; String province = address.getProvince(); &#125;&#125; 这种写法是比较丑陋的，为了避免上述丑陋的写法，让丑陋的设计变得优雅。JAVA8 提供了Optional类来优化这种写法，通过类型系统让你的领域模型中隐藏的知识显式地体现在你的代码中，这样我们就不用显式进行空值检测。 类方法 方法 描述 static Optional empty() 返回空的 Optional 实例。 boolean equals(Object obj) 判断其他对象是否等于 Optional。 Optional filter(Predicate&lt;? super predicate) 如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。 Optional flatMap(Function&lt;? super T,Optional&gt; mapper) 如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional T get() 如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException int hashCode() 返回存在值的哈希码，如果值不存在 返回 0。 void ifPresent(Consumer&lt;? super T&gt; consumer) 如果值存在则使用该值调用 consumer , 否则不做任何事情。 boolean isPresent() 如果值存在则方法会返回true，否则返回 false。 Optional map(Function&lt;? super T,? extends U&gt; mapper) 如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。 static Optional of(T value) 返回一个指定非null值的Optional。 static Optional ofNullable(T value) 如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。 T orElse(T other) 如果存在该值，返回值， 否则返回 other。 T orElseGet(Supplier&lt;? extends T&gt; other) 如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。 T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) 如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常 String toString() 返回一个Optional的非空字符串，用来调试 实例12345678910111213141516171819// 判断一个对象的属性是否为空，为空则跑出异常Optional.ofNullable(user) .flatMap(u-&gt; u.getAddress()) .map(a-&gt;a.getCity()) .orElseThrow(()-&gt;new Exception(&quot;异常&quot;)); // 判断一个对象是否为空，不为空 do somethingOptional.ofNullable(user).ifPresent(u-&gt;&#123; // do something &#125;);// 对 Optional 中包含的值进行过滤，如果包含的值满足条件，那么还是返回这个 Optional；否则创建一个新的对象返回Optional&lt;User&gt; user1 = Optional.ofNullable(user). filter(u -&gt; &quot;wave&quot;.equals(u.getName)). orElseGet(()-&gt; &#123; User user1 = new User(); user1.setName(&quot;wave&quot;); return user1; &#125;);; 使用Optional的思路和Stream相同，都是链式思路，省去了繁琐的判断，在后面的开发中，可以使用Optional设计API，这样可以设计出更安全的接口和方法。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一条SQL(select/update)语句是如何执行的?]]></title>
    <url>%2Fhow-is-a-sql-executed.html</url>
    <content type="text"><![CDATA[关键字：基础架构,日志系统 在执行下面这个查询语句时：1mysql&gt; select * from T where ID=10; MySQL 内部的执行过程，所以需要拆解一下，看看 SQL 语句在 MySQL 中各个功能模块中的执行过程。 大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。 Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、 MyISAM、Memory 等多个存储引擎。 连接器连接器负责跟客户端建立连接、获取权限、维持和管理连接。1mysql -h$ip -P$port -u$user -p 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。 建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。 但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因 为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断 开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉 (OOM)，从现象看就是 MySQL 异常重启了。 怎么解决这个问题呢?你可以考虑以下两种方案： 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后， 断开连接，之后要查询再重连。 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执 行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权 限验证，但是会将连接恢复到刚刚创建完时的状态。 查询缓存 MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前 执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询 的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。所以如果被缓存命中，效率会很高。 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。所以查询缓存的命中率会非常低。 MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻 底没有这个功能了。 分析器 分析器先会做“词法分析”，识别出具体的SQL语句查询字段和对应的表明，然后做”语法分析”，判断是否满足 MySQL 的语法。 优化器 优化器是在表里面有多个索引的时候，决定使用哪个索引;或者在一个语句有多表关联 (join)的时候，决定各个表的连接顺序。 执行器 开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返 回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结 果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。 比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的: 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如 果是则将这行存在结果集中; 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 如果是下面的更新语句呢？1mysql&gt; update T set c=c+1 where ID=2; 除了上述查询的那一套流程，还涉及到两个重要的日志模块。 redo log 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。 InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文 件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。 有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。 binlog redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog(归档日志)。 这两种日志有以下三点不同。 redo log 是 InnoDB 引擎特有的;binlog 是 MySQL 的 Server 层实现的，所有引擎 都可以使用。 redo log 是物理日志，记录的是“在某个数据页上做了什么修改”;binlog 是逻辑日 志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 redo log 是循环写的，空间固定会用完;binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 两阶段提交我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器;否则，需要先从磁 盘读入内存，然后再返回。 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到 新的一行数据，再调用引擎接口写入这行新数据。 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交(commit)状态，更新完成。 将 redo log 的写入拆成了两个步骤: prepare 和 commit，这就是”两阶段提交”。简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。 Reference: [极客时间-MySQL实践45讲]]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈常用分布式ID的设计方案]]></title>
    <url>%2Fdistributed-id-design.html</url>
    <content type="text"><![CDATA[需要明确通常的分布式 ID 的定义，基本包括: 全局唯一，区别于单点系统的唯一，全局是要求分布式系统内唯一。 有序性，通常要保证生成的 ID 是有序递增的。 目前业界的的方案主要是： 基于数据库自增序列的实现。这种方式优点和缺点都非常明显，好处是简单易用，但是在扩展性和可靠性等方面存在局限性。 基于 Twitter 早期开源的Snowflake的实现，以及相关改动方案。其结构定义可以参考下面的示意图。 其中 10 位的WorkerID，标准定义是 5 位数据中心 + 5 位机器编码，以区分不同的集群节点。最后的 12 位就是单位毫秒内可生成的序列号数目的理论极限。 在明确的业务场景中，我们到底需要一个什么样的分布式ID呢，除了唯一性和有序，通常还希望分布式ID： 有意义，也就是说包含更多的信息，比如时间和业务信息。 高可用性，取决于我们业务对扩展性，性能方面的要求。 紧凑性，ID 的大小可能受实际应用的制约，例如太长的ID会降低 MYSQL 等数据库索引的性能。 分享一个很好的分布式ID的实现 westid. Reference: 极客时间-Java核心技术36讲]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发编程学习 - 概述]]></title>
    <url>%2Fjava-concurrent-programming-outline.html</url>
    <content type="text"><![CDATA[看薛兆丰的《经济学通识》，他总结到，人类面临着四大基本约束：东西不够，生命有限，互相依赖，需要协调。当我看到这句话的时候，我猛然间意识到：计算机也同样面临着这四大基本约束。 在计算中，CPU、内存、IO、硬盘、带宽等，这些资源也都有不够的时候，而每个线程的也有着自己的生命周期，并且它们之间又是相互依赖的，也同样需要协调。有了上面的这种想法，我觉得我学习计算机的知识有了章法可循。 并发编程知识全景图 并发编程领域可以抽象成三个核心问题：分工、同步和互斥。 分工类似于现实中一个组织完成一个项目，项目经理要拆分任务，安排合适的成员去完成。 同步每个小任务间可能存在相互依赖，同步需要做的是在前置任务完成后，通知后置任务启动。 互斥互斥主要解决正确性问题。互斥要求同一时间，只允许一个线程访问共享变量。 学习方法论: 我认为工程上的解决方案，一定要有理论做基础。「跳出来，看全景」 和 「钻进去，看本质」，这两条方法论，我想是适合很多领域的学习的。 Reference: 极客时间-Java并发编程实战]]></content>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长公共前缀]]></title>
    <url>%2Flongest-common-prefix.html</url>
    <content type="text"><![CDATA[编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 示例 1:12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2:123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 思路先利用Arrays.sort(strs)为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Main &#123; public static String replaceSpace(String[] strs) &#123; // 如果检查值不合法及就返回空串 if (!checkStrs(strs)) &#123; return ""; &#125; // 数组长度 int len = strs.length; // 用于保存结果 StringBuilder res = new StringBuilder(); // 给字符串数组的元素按照升序排序(包含数字的话，数字会排在前面) Arrays.sort(strs); int m = strs[0].length(); int n = strs[len - 1].length(); int num = Math.min(m, n); for (int i = 0; i &lt; num; i++) &#123; if (strs[0].charAt(i) == strs[len - 1].charAt(i)) &#123; res.append(strs[0].charAt(i)); &#125; else break; &#125; return res.toString(); &#125; private static boolean checkStrs(String[] strs) &#123; if (strs != null) &#123; // 遍历strs检查元素值 for (int i = 0; i &lt; strs.length; i++) &#123; if (strs[i] == null || strs[i].length() == 0) &#123; return false; &#125; &#125; &#125; return true; &#125; // 测试 public static void main(String[] args) &#123; String[] strs = &#123; "customer", "car", "cat" &#125;; // String[] strs = &#123; "customer", "car", null &#125;;//空串 // String[] strs = &#123;&#125;;//空串 // String[] strs = null;//空串 System.out.println(Main.replaceSpace(strs));// c &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何保证幂等机制]]></title>
    <url>%2Fhow-to-guarantee-idempotent-mechanism.html</url>
    <content type="text"><![CDATA[概述 其实这是一个很常见的问题，做后端开发会经常遇到这个问题，如何保证消息消费不被重复消费，或者说如何保证一个接口多次调用只会产生一种结果，不管调多少次，资源都不会发生改变。如果重复消费了或者调用了，如何保证不造成系统异常。所以幂等机制的核心就是保证资源唯一性。 场景 需要保证幂等性的场景就是需要限定接口只能调用一次；消息重复消费之后，要保证资源不会发生改变。例如： 支付接口 退款接口 新增数据的接口 … 思路 利用数据库的唯一索引，针对我们需要约束的资源字段创建唯一索引，可以防止插入重复的数据。需要注意的是，如果是分库分表的情况，唯一索引的情况就不能限制资源数据的唯一性。 可以先根据数据库唯一索引查一下，如果存在，就做更新操作。 这块要注意的是如何避免并发场景（分布式锁）。 如果是直接写 redis，每次都是set，天然就幂等的。 利用 redis 做一层校验，每次调接口或这消费消息之前先查一下 redis 里有没有全局的ID，如果没有消费过，加redis，再处理消息或接口。]]></content>
      <tags>
        <tag>沉淀</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[All Or Nothing]]></title>
    <url>%2Fgoodbye-2018.html</url>
    <content type="text"><![CDATA[关键字：don&#39;t be nervous, 业务or技术, 人情味儿, 慎独 年前和学弟吃了个饭，听他讲了讲毕业这半年有什么变化，进步了多少，因为公司涉及的领域各有不同，所以技术领域或者说业务领域有很大的差别，没有什么反复探讨的东西，不过有一句话倒是令我影响深刻：其他人或者公司不注重的细节，积累起来就是自身的核心价值。 don’t be nervous，这一年在亚信做了一些小事儿，佣金业务，智能调度，监控预警等，相应的也接触到了一些”新鲜”的技术, 微服务(SpringBoot), 微服务治理框架(SpringCloud, Dubbo), 分布式定时任务调度平台(elastic-job,xxl-job), 消息中间件(rabbitMQ, rocketMQ, kafka), 全文搜索引擎(Elasticsearch)等，能结合业务的发展方向对基础技术有一定的预判和快速上手，在面对方方面面的技术过程中，最重要的就是不要害怕，不要惊慌失措，不要逃避，这就是学习工程化，在技术宽度达到一定阶段后，就能根据不同的业务需求，进行技术选型，避免业务发展受到基础技术的拖累而不知所措。 业务or技术，纯粹的业务做的久了，难免心生倦怠，觉得技术得不到成长，工作内容除了CRUD就是if...else,就算接到有挑战的开发任务,有了上面don&#39;t be nervous的心态之后，也能心态平和的迎刃而解。我当然知道这是很多开发者面对的问题。其实这是一种相对割裂的眼光看问题，实际上，所谓的业务代码和技术代码，它们的区别，仅仅是和业务的距离远近不同而已：业务代码离业务更近，技术代码离业务稍远。他们最终都是指向业务实现的。2018年，我没有很好的去阅读他人的代码了解全局的业务形态，也没有在自己的技术栈上下功夫深钻底层实现，其实这两者只要有一个做的出色，就能有很大的成长。每当心生倦怠的时候，不妨多读读《对开发来讲，业务重要还是技术重要？》。 人情味儿，其实说到一个公司的人情味儿，当然离不开领导的关怀，组内和睦。我这里主要想说的是关于开发过程中，项目组或者说开发小组所给予的试错空间，容错性，很大程度上每个人写的代码都会被组长review一遍，或者就算是生产出了问题，自然有测试同事和负责发版的同事发现并修复，只要不导致重大生产后果，上线之后还存活的bug也不会被专门针对，逐渐的开发少了对自己代码负责的心态，没有对代码敬畏之心。我曾经问一个实习生毕业之后还来亚信的原因，答案是清闲，安稳。我不觉得清闲松散是一个项目组有人情味的表现，死海效应已经泛滥。其实团队有这么大的试错性，对于提升个人技术是特别好的一件事，任何可以实现业务需求的方式，就都可以去尝试，并且分享出来一起探讨利弊是一个很好的组内技术交流方式。 慎独, 马未都的脱口秀节目《观复嘟嘟》曾经有一期以江湖为主题，这其中就有一段关于慎独更加清晰明了的对话。一位女观众问：“像我们这种普通人如果要在江湖上混，应该注意些什么？” 他说：“要很注意的一点，就是古人一再提醒的叫慎独。慎独就是你一个人独处的时候，你自己给自己一个交代，你给自己内心一个交代，我老说，你这事你对谁都不重要，对你自己最重要。你当下所有对工作的敷衍，最后都成了人生对你的敷衍。希望2019以此为戒，对自己负责。]]></content>
      <tags>
        <tag>Life-Talk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch Jest 实践]]></title>
    <url>%2Fes-jest-practice.html</url>
    <content type="text"><![CDATA[JestGitHubJest是 Elasticsearch 的 Java Http Rest 客户端。ElasticSearch 已经具备应用于 Elasticsearch 内部的 Java API，但是 Jest 弥补了ES自有API缺少Elasticsearch Http Rest接口客户端的不足。 springBoot 集成 Jest 依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.searchbox&lt;/groupId&gt; &lt;artifactId&gt;jest&lt;/artifactId&gt; &lt;version&gt;6.3.0&lt;/version&gt;&lt;/dependency&gt; 使用介绍 实践123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 创建查询表达式 * @param criterias * @param page * @return */private SearchSourceBuilder buildSearch(List&lt;Criteria&gt; criterias, EqlPage page) &#123; //指定查询的库表 SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); // 分页 if (Objects.nonNull(page)) &#123; searchSourceBuilder.from((page.getCurrentPage() - 1) * page.getPageRows()).size(page.getPageRows()); &#125; if (CollectionUtils.isNotEmpty(criterias)) &#123; BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); criterias.stream().forEach(t -&gt; &#123; if (SHOULD.equals(t.getFieldType())) &#123; // 设置 should 匹配条件 boolQueryBuilder.should(QueryBuilders.termQuery(t.getFieldName(), t.getFieldValue())); &#125; if (MUST.equals(t.getFieldType())) &#123; // 设置 must 匹配条件 boolQueryBuilder.must(QueryBuilders.termQuery(t.getFieldName(), t.getFieldValue())); &#125; if (RANGE.equals(t.getFieldType())) &#123; // 设置 range 区间匹配条件 boolQueryBuilder.must( QueryBuilders.rangeQuery(t.getFieldName()).format(DATE_FORMAT).from(t.getFieldValue()).to(t.getFieldValue2())); &#125; &#125;); searchSourceBuilder.query(boolQueryBuilder); &#125; return searchSourceBuilder;&#125;/** * es 执行查询 * @param searchSourceBuilder * @return */public List&lt;OrderBean&gt; search(SearchSourceBuilder searchSourceBuilder,EqlPage page) &#123; List&lt;OrderBean&gt; list = Lists.newArrayList(); try &#123; SearchResult result = client.execute(new Search.Builder(searchSourceBuilder.toString()) // multiple index or types can be added. .addIndex(baseConfig.getEsIndex()) .addType(baseConfig.getEsType()) // 设置排序字段与排序方式 .addSort(new Sort(StringUtils.isBlank(page.getSortField()) ? "create_time" : page.getSortField(), StringUtils.isEmpty(page.getSort()) ? Sort.Sorting.DESC : Sort.Sorting.ASC)) .build()); result.getSourceAsObjectList(OrderBean.class, false); List&lt;SearchResult.Hit&lt;Object, Void&gt;&gt; hits = result.getHits(Object.class); if (CollectionUtils.isEmpty(hits)) &#123; return list; &#125; log.info("es - list size :&#123;&#125;", hits.size()); // 将查询结果映射到java实体里 hits.stream().forEach(t -&gt; &#123; String news = JSON.toJSONString(t.source); OrderBean order = JSON.parseObject(news, OrderBean.class); list.add(order); &#125;); // 获取查询总记录数 page.setTotalRows(result.getTotal().intValue()); // 设置总页数 page.setPageNum((page.getTotalRows() - 1) / page.getPageRows() + 1); &#125; catch (Exception e) &#123; log.info("es - 查询失败：&#123;&#125;",JSON.toJSONString(e.getMessage())); throw new BusinessException("9999","es 查询失败：&#123;&#125;",e.getMessage()); &#125; return list;&#125;]]></content>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用两个栈实现队列]]></title>
    <url>%2Fachieve-queues-with-two-stack.html</url>
    <content type="text"><![CDATA[题目描述 用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 题目分析 首先清楚栈和队列的特点，栈的特点是先进后出，队列的特点是先进先出。也就是说，栈的删除操作在表尾进行，队列的删除操作在表头进行。 解题思路in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。 12345678910111213141516171819Stack&lt;Integer&gt; in = new Stack&lt;Integer&gt;();Stack&lt;Integer&gt; out = new Stack&lt;Integer&gt;();// 入栈 (in 栈)public void push(int node) &#123; in.push(node);&#125;// 出栈public int pop() throws Exception &#123; if (out.isEmpty()) // 如果 out 栈为空，in 栈不为空，把元素从 in 栈顶出栈，放到 out 栈底 while (!in.isEmpty()) out.push(in.pop()); if (out.isEmpty()) throw new Exception(&quot;queue is empty&quot;); return out.pop(); // 然后从 out 的栈的栈顶出栈，就是当时最先入栈的元素&#125; 题目来源：nowcoder]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组中的查找]]></title>
    <url>%2Ffind-in-two-dimensional-array.html</url>
    <content type="text"><![CDATA[题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题目分析1234567891011Consider the following matrix:[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]Given target = 5, return true.Given target = 20, return false. 解题思路从右上角开始查找。矩阵中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间。 复杂度：O(M + N) + O(1) 当前元素的查找区间为左下角的所有元素，例如元素 12 的查找区间如下： 123456789101112131415public boolean Find(int target, int[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false; int rows = matrix.length, cols = matrix[0].length; int r = 0, c = cols - 1; // 从右上角开始 while (r &lt;= rows - 1 &amp;&amp; c &gt;= 0) &#123; if (target == matrix[r][c]) return true; else if (target &gt; matrix[r][c]) // 如果比右上角的数大,就往下找；否则往左找 r++; else c--; &#125; return false;&#125; 题目来源：nowcoder]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于缓存]]></title>
    <url>%2Fabout-cache.html</url>
    <content type="text"><![CDATA[对于热点数据，缓存的价值非常大，主要解决热点数据访问的性能问题。提供高性能的数据快速访问。 缓存特征命中率当某个请求能够通过访问缓存而得到响应时，称为缓存命中。 缓存命中率越高，缓存的利用率也就越高。 最大空间缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。 当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。 清空策略 FIFO (First In First Out)：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。 LRU (Least Recently Used)：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。 LFU (less frequently used)：最少使用策略，无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。策略算法主要比较元素的hitCount（命中次数）。在保证高频数据有效性场景下，可选择这类策略。 缓存位置浏览器当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。 ISP网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。 反向代理反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。 本地缓存使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。 分布式缓存使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。 相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。 数据库缓存MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。 缓存问题缓存穿透指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。 解决方案： 对这些不存在的数据缓存一个空数据； 对这类请求进行过滤。 缓存雪崩指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。 在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。 解决方案： 为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现； 为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。 也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。 缓存一致性缓存一致性要求数据更新的同时缓存数据也能够实时更新。 解决方案： 在数据更新的同时立即去更新缓存； 在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。 要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。 Reference: 缓存那些事 How Aspiration CDN helps to improve your website loading speed?]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息可靠性投递的技术方案]]></title>
    <url>%2Fmessage-reliability-delivery-suggestion.html</url>
    <content type="text"><![CDATA[使用 MQ 技术最常见的核心需求，需要保证消息不丢失，100%投递成功。以下是一个可靠性投递的流程图，以说明可靠性投递的概念。 step 1： 首先把消息信息(业务数据）存储到数据库中，紧接着，我们再把这个消息记录也存储到一张消息记录表里(者另外一个同源数据库的消息记录表)step 2： 发送消息到MQ Broker节点（采用 confirm 方式发送，会有异步的返回结果）step 3： 生产者端接受MQ Broker节点返回的 confirm 确认消息结果step 4： 进行更新消息记录表里的消息状态。比如默认 status = 0 当收到消息确认成功后，更新为1即可step 5： 但是在消息确认这个过程中可能由于网络闪断、MQ Broker端异常等原因导致 回送消息失败或者异常。这个时候就需要发送方（生产者）对消息进行可靠性投递了，保障消息不丢失，100%的投递成功！（有一种极限情况是闪断，Broker返回的成功确认消息，但是生产端由于网络闪断没收到，这个时候重新投递可能会造成消息重复，需要消费端去做幂等处理）所以我们需要有一个定时任务，（比如每5分钟拉取一下处于中间状态的消息，当然这个消息可以设置一个超时时间，比如超过1分钟 Status = 0 ，也就说明了1分钟这个时间窗口内，我们的消息没有被确认，那么会被定时任务拉取出来）step 6： 接下来我们把中间状态的消息进行重新投递 retry send，继续发送消息到MQ ，当然也可能有多种原因导致发送失败step 7： 我们可以采用设置最大努力尝试次数，比如投递了3次，还是失败，那么我们可以将最终状态设置为Status = 2 ，最后 交由人工解决处理此类问题（或者把消息转储到失败表中）。 具体的技术实现细节参考慕课视频《RabbitMQ消息中间件极速入门与实战》 Reference: RabbitMQ消息中间件极速入门与实战]]></content>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保证服务可用行性的核心思路]]></title>
    <url>%2Fimprove-service-availability.html</url>
    <content type="text"><![CDATA[如何保障稳定性，提高可用性呢？其实，可以分为几个方面：通过技术和流程防止故障产生、并且在发生故障时，减少故障的定位时间，以及提高故障恢复时间。 Reference: 梁桂钊的知识星球 –「服务端思维」]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图API-判断坐标点在多边形区域内]]></title>
    <url>%2Fjudge-point-isInPolygon.html</url>
    <content type="text"><![CDATA[在智能派单的业务中,判断一个订单的收货地址在哪个配送员的配送范围之内,就显得极为关键。网上参考了一些解决思路和方法,做了一些实践和归纳。 射线法思路 判断一个点是否在多边形内部 [1] 射线法思路 判断一个点是否在多边形内部 [2] 射线法实现 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 判断点是否在多边形内，如果点位于多边形的顶点或边上，也算做点在多边形内，直接返回true * @param point 检测点 * @param pts 多边形的顶点 * @return 点在多边形内返回true,否则返回false */ public static boolean IsPtInPoly(Point2D.Double point, List&lt;Point2D.Double&gt; pts)&#123; int N = pts.size(); boolean boundOrVertex = true; //如果点位于多边形的顶点或边上，也算做点在多边形内，直接返回true int intersectCount = 0;//cross points count of x double precision = 2e-10; //浮点类型计算时候与0比较时候的容差 Point2D.Double p1, p2;//neighbour bound vertices Point2D.Double p = point; //当前点 p1 = pts.get(0);//left vertex for(int i = 1; i &lt;= N; ++i)&#123;//check all rays if(p.equals(p1))&#123; return boundOrVertex;//p is an vertex &#125; p2 = pts.get(i % N);//right vertex if(p.x &lt; Math.min(p1.x, p2.x) || p.x &gt; Math.max(p1.x, p2.x))&#123;//ray is outside of our interests p1 = p2; continue;//next ray left point &#125; if(p.x &gt; Math.min(p1.x, p2.x) &amp;&amp; p.x &lt; Math.max(p1.x, p2.x))&#123;//ray is crossing over by the algorithm (common part of) if(p.y &lt;= Math.max(p1.y, p2.y))&#123;//x is before of ray if(p1.x == p2.x &amp;&amp; p.y &gt;= Math.min(p1.y, p2.y))&#123;//overlies on a horizontal ray return boundOrVertex; &#125; if(p1.y == p2.y)&#123;//ray is vertical if(p1.y == p.y)&#123;//overlies on a vertical ray return boundOrVertex; &#125;else&#123;//before ray ++intersectCount; &#125; &#125;else&#123;//cross point on the left side double xinters = (p.x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y;//cross point of y if(Math.abs(p.y - xinters) &lt; precision)&#123;//overlies on a ray return boundOrVertex; &#125; if(p.y &lt; xinters)&#123;//before ray ++intersectCount; &#125; &#125; &#125; &#125;else&#123;//special case when ray is crossing through the vertex if(p.x == p2.x &amp;&amp; p.y &lt;= p2.y)&#123;//p crossing over p2 Point2D.Double p3 = pts.get((i+1) % N); //next vertex if(p.x &gt;= Math.min(p1.x, p3.x) &amp;&amp; p.x &lt;= Math.max(p1.x, p3.x))&#123;//p.x lies between p1.x &amp; p3.x ++intersectCount; &#125;else&#123; intersectCount += 2; &#125; &#125; &#125; p1 = p2;//next ray left point &#125; if(intersectCount % 2 == 0)&#123;//偶数在多边形外 return false; &#125; else &#123; //奇数在多边形内 return true; &#125; &#125; 百度地图 API 的使用 需要申请且认证为开发者。 需要在控制台创建应用,获取相应的服务密钥(AK) 在开发文档中选择自己需要的api,根据具体api的服务文档和使用指南发送请求,使用服务即可。]]></content>
      <tags>
        <tag>沉淀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于开发中单表查和连表查的取舍]]></title>
    <url>%2Fsingle-or-join-query.html</url>
    <content type="text"><![CDATA[关于开发中单表查询和连接查询怎么取舍？连表配合索引一次查询就可以出来，单表的话可能需要 n 次读取数据库。 处理策略 能单表就单表，尽量不要连表，不光有开销，连表后复用性降低，系统复杂性会增加。而且数据库做关联是很耗性能的。把连表查拆分成两次查询也是基于查出结果的 idList 去查另一张表，开销很小，查询出的结果可以做一次merge组合。 通用的 merge 方法123456789101112131415161718192021222324252627/** * @author wave * @create 2018-06-20 11:24 **/public class MergeUtil &#123; /** * 把 sourceList 的一些属性合并到 targetList 中 * 基于 testFunction 的条件,合入逻辑实现为 biConsumer * @param targetList * @param sourceList * @param testFunction * @param biConsumer * @param &lt;T&gt; * @param &lt;S&gt; */ public static &lt;T, S&gt; void merge(List&lt;T&gt; targetList, List&lt;S&gt; sourceList, BiFunction&lt;? super T, ? super S,Boolean&gt; testFunction, BiConsumer&lt;? super T, ? super S&gt; biConsumer) &#123; targetList.forEach((t)-&gt;&#123; Optional&lt;S&gt; optional = sourceList.stream().filter(s -&gt; testFunction.apply(t,s)).findFirst(); if (optional.isPresent()) &#123; biConsumer.accept(t,optional.get()); &#125; &#125;); &#125;&#125; 调用方式1234567/** * 基于两个 list 的 id 做关联, 将 name 属性 merge 到目标 list ***/MergeUtil.merge(targetList,sourceList, (target,source)-&gt;target.id().equals(source.id()), (target,source)-&gt;target.setName(source.getName)); Reference: 梁桂钊的知识星球 –「服务端思维」]]></content>
      <tags>
        <tag>沉淀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda 表达式]]></title>
    <url>%2Flambda-expressions.html</url>
    <content type="text"><![CDATA[什么是 Lambda?我们知道，对于一个Java变量，我们可以赋给其一个“值”。 如果你想把“一块代码”赋给一个Java变量，应该怎么做呢？ 比如，我想把右边那块代码，赋给一个叫做aBlockOfCode的Java变量： 在Java 8之前，这个是做不到的。但是Java 8问世之后，利用Lambda特性，就可以做到了。 当然，这个并不是一个很简洁的写法。所以，为了使这个赋值操作更加elegant, 我们可以移除一些没用的声明。 这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式。但是这里仍然有一个问题，就是变量aBlockOfCode的类型应该是什么？在Java 8里面，所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现。这是我认为理解Lambda的一个关键所在，简而言之就是，Lambda表达式本身就是一个接口的实现。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型： 这种只有一个接口函数需要被实现的接口类型，我们叫它”函数式接口“。为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了： 这样，我们就得到了一个完整的Lambda表达式声明： Lambda表达式有什么作用?最直观的作用就是使得代码变得异常简洁。我们可以对比一下Lambda表达式和传统的Java对同一个接口的实现： 这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于Lambda可以直接赋值给一个变量，我们就可以直接把Lambda作为参数传给函数, 而传统的Java必须有明确的接口实现的定义，初始化才行：有些情况下，这个接口实现只需要用到一次。传统的Java 7必须要求你定义一个“污染环境”的接口实现MyInterfaceImpl，而相较之下Java 8的Lambda, 就显得干净很多。 Lambda结合FunctionalInterface Lib, forEach, stream()，method reference等新特性可以使代码变的更加简洁！直接上例子。 假设Person的定义和List的值都给定。现在需要你打印出guiltyPersons List里面所有LastName以”Z”开头的人的FirstName。 原生态Lambda写法：定义两个函数式接口，定义一个静态函数，调用静态函数并给参数赋值Lambda表达式。这个代码实际上已经比较简洁了，但是我们还可以更简洁么？当然可以。在Java 8中有一个函数式接口的包，里面定义了大量可能用到的函数式接口（java.util.function (Java Platform SE 8 )）。所以，我们在这里压根都不需要定义NameChecker和Executor这两个函数式接口，直接用Java 8函数式接口包里的Predicate和Consumer就可以了——因为他们这一对的接口定义和NameChecker/Executor其实是一样的。第一步简化 - 利用函数式接口包：静态函数里面的for each循环其实是非常碍眼的。这里可以利用Iterable自带的forEach()来替代。forEach()本身可以接受一个Consumer 参数。第二步简化 - 用Iterable.forEach()取代foreach loop：由于静态函数其实只是对List进行了一通操作，这里我们可以甩掉静态函数，直接使用stream()特性来完成。stream()的几个方法都是接受Predicate，Consumer等参数的（java.util.stream (Java Platform SE 8 )）。你理解了上面的内容，stream()这里就非常好理解了，并不需要多做解释。第三步简化 - 利用stream()替代静态函数：对比最开始的Lambda写法，这里已经非常非常简洁了。但是如果，我们的要求变一下，变成print这个人的全部信息，及p -&gt; System.out.println(p); 那么还可以利用Method reference来继续简化。所谓Method reference, 就是用已经写好的别的Object/Class的method来代替Lambda expression。格式如下：第四步简化 - 如果是println(p)，则可以利用Method reference代替forEach中的Lambda表达式：这基本上就是能写的最简洁的版本了。 Lambda配合Optional可以使Java对于null的处理变的异常优雅这里假设我们有一个person object，以及一个person object的Optional wrapper:Optional如果不结合Lambda使用的话，并不能使原来繁琐的null check变的简单。只有当Optional结合Lambda一起使用的时候，才能发挥出其真正的威力！ 我们现在就来对比一下下面四种常见的null处理中，Java 8的Lambda+Optional和传统Java两者之间对于null的处理差异。情况一 - 存在则开干情况二 - 存在则返回，无则返回屁情况三 - 存在则返回，无则由函数产生情况四 - 夺命连环null检查由上述四种情况可以清楚地看到，Optional+Lambda可以让我们少写很多ifElse块。尤其是对于情况四那种夺命连环null检查，传统java的写法显得冗长难懂，而新的Optional+Lambda则清新脱俗，清楚简洁。 关于Java的Lambda, 还有东西需要讨论和学习。比如如何handle lambda exception，如何利用Lambda的特性来进行parallel processing等。总之，我只是一如既往地介绍个大概，让你大概知道，哦！原来是这样子就OK了。网上关于Lambda有很多相关的教程，多看多练。假以时日，必定有所精益。 Reference: Sevenvidia-知乎]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ 初试]]></title>
    <url>%2Frocketmq-start-learn.html</url>
    <content type="text"><![CDATA[近期的项目需求需要用到消息队列, 结合实际的业务需求(佣金结算), 需要对市面上的几种消息中间件进行选型分析, 从功能维度(优先级队列、延迟队列、死信队列、重试队列、消费模式、消息过滤、消息顺序性、事务性消息等), 性能,可靠性 + 可用性, 运维管理, 日志追踪, 社区力度及生态发展等层面进行考虑, 根据各自的侧重点, 选择合适自己的消息中间件尤为重要。 我这次选择了阿里开源的RocketMQ,下面主要记录下我的首次使用,与Spring集成,采用push方式接收消息。 Maven 依赖123456789101112&lt;dependency&gt; &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;3.2.6&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-all&lt;/artifactId&gt; &lt;version&gt;3.2.6&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; application.properties123apache.rocketmq.consumer.PushConsumer=WeChatConsumerapache.rocketmq.producer.producerGroup=WeChatProducerapache.rocketmq.namesrvAddr=XX.XX.XX.XX:9876 生产者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Producer &#123; private static final Logger logger = LoggerFactory.getLogger(Producer.class); /** * 生产者的组名 */ @Value("$&#123;apache.rocketmq.producer.producerGroup&#125;") private String producerGroup; /** * NameServer 地址 */ @Value("$&#123;apache.rocketmq.namesrvAddr&#125;") private String namesrvAddr; public void defaultMQProducer()&#123; //生产者的组名 DefaultMQProducer producer = new DefaultMQProducer(producerGroup); //指定NameServer地址，多个地址以 ; 隔开 producer.setNamesrvAddr(namesrvAddr); /** * 从文件中获取待消费消息数据： * 4418040302625808|2018-04-03 10:35:52|81|820|16608187978|2018-04-03 14:22:56|9095180232 6518040101499088|2018-04-01 10:50:20|75|750|13037219257|2018-04-03 14:22:55|3579901463 */ File fin = new File("E:\\work\\20180403_1432_002.REQ"); try &#123; /** * Producer对象在使用之前必须要调用start初始化，初始化一次即可 * 注意：切记不可以在每次发送消息时，都调用start方法 */ producer.start(); List&lt;String&gt; msgList = ReadFile.readFile(fin); if (CollectionUtils.isEmpty(msgList)) &#123; return; &#125; StopWatch stop = new StopWatch(); stop.start(); for (String str : msgList) &#123; // 拆分字符串, id 记录流水号 String[] msgArr = str.split("\\|"); Message msg = new Message("WXData","push",msgArr[0],str.getBytes()); // 发送消息 SendResult result = producer.send(msg); logger.info("id:&#123;&#125;,result:&#123;&#125;", result.getMsgId(), result.getSendStatus()); &#125; stop.stop(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; producer.shutdown(); &#125; &#125;&#125; 消费者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Consumer &#123; /** * 消费者的组名 */ @Value("$&#123;apache.rocketmq.consumer.PushConsumer&#125;") private String consumerGroup; /** * NameServer 地址 */ @Value("$&#123;apache.rocketmq.namesrvAddr&#125;") private String namesrvAddr; private static final Logger logger = LoggerFactory.getLogger(Consumer.class); @Autowired CalcCommissionService calcService; // spring框架的注解，在方法上加该注解会在项目启动的时候执行该方法，也可以理解为在spring容器初始化的时候执行该方法 @PostConstruct public void defaultMQPushConsumer()&#123; //消费者的组名 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumerGroup); //指定NameServer地址，多个地址以 ; 隔开 consumer.setNamesrvAddr(namesrvAddr); try &#123; //订阅WXData下的push消息 consumer.subscribe("WXData", "push"); //设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费 //如果非第一次启动，那么按照上次消费的位置继续消费 consumer.setConsumeFromWhere( ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.registerMessageListener( (List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext Context) -&gt; &#123; try &#123; Message msg = list.get(0); String msgBody = new String (msg.getBody()); // TODO coding... &#125; catch (Exception e) &#123; e.printStackTrace(); return ConsumeConcurrentlyStatus.RECONSUME_LATER; // 稍后重试 &#125; return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; // 消费成功 &#125;); consumer.start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 测试123456789101112public class Test&#123; /** * test rocketMQ */ @Autowired Producer rocketMQProvider; @RequestMapping("/testMQ") public String testMq() &#123; rocketMQProvider.defaultMQProducer(); return null; &#125;&#125;]]></content>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 高并发编程「三」]]></title>
    <url>%2Fjava-concurrent-programming-3.html</url>
    <content type="text"><![CDATA[ConcurrentMap Map(Set)如果在不加锁的情况下, 可以使用 HashMap,treeMap,LinkedHashMap等。如果想加锁,可以使用 HashTable(用的比较少),如果并发不高的情况下，可以使用 Collections.synchronizedXXX,如果并发性比较高的情况, 建议使用 ConcurrentHashMap,如果并发性比较高，并且要求排序的情况下，建议使用 ConcurrentSkipListMap。 1234567891011121314151617181920212223242526272829303132333435363738public class T01_ConcurrentMap &#123; public static void main(String[] args) &#123; /** * 16 段, 分段锁,高并发的时候效率比较高 */ //Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); Map&lt;String, String&gt; map = new ConcurrentSkipListMap&lt;&gt;(); //高并发并且排序 /** * Hashtable 本身就带锁,效率比较低 */ //Map&lt;String, String&gt; map = new Hashtable&lt;&gt;(); /** * 可以对 HashMap 加锁：Collections.synchronizedXXX */ //Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //TreeMap Random r = new Random(); Thread[] ths = new Thread[100]; CountDownLatch latch = new CountDownLatch(ths.length); long start = System.currentTimeMillis(); for(int i=0; i&lt;ths.length; i++) &#123; ths[i] = new Thread(()-&gt;&#123; for(int j=0; j&lt;10000; j++) map.put("a" + r.nextInt(100000), "a" + r.nextInt(100000)); latch.countDown(); &#125;); &#125; Arrays.asList(ths).forEach(t-&gt;t.start()); try &#123; latch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long end = System.currentTimeMillis(); System.out.println(end - start); &#125;&#125; CopyOnWriteList写时复制容器 copy on write,多线程环境下,写时效率低,读时效率高,适合写少读多的环境。1234567891011121314151617181920212223242526272829303132333435363738394041public class T02_CopyOnWriteList &#123; public static void main(String[] args) &#123; List&lt;String&gt; lists = //new ArrayList&lt;&gt;(); //这个会出并发问题！ //new Vector(); new CopyOnWriteArrayList&lt;&gt;(); Random r = new Random(); Thread[] ths = new Thread[100]; for(int i=0; i&lt;ths.length; i++) &#123; Runnable task = new Runnable() &#123; @Override public void run() &#123; for(int i=0; i&lt;1000; i++) lists.add("a" + r.nextInt(10000)); &#125; &#125;; ths[i] = new Thread(task); &#125; runAndComputeTime(ths); System.out.println(lists.size()); &#125; static void runAndComputeTime(Thread[] ths) &#123; long s1 = System.currentTimeMillis(); Arrays.asList(ths).forEach(t-&gt;t.start()); Arrays.asList(ths).forEach(t-&gt;&#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); long s2 = System.currentTimeMillis(); System.out.println(s2 - s1); &#125;&#125; SynchronizedList new ArrayList() 是没有锁的，如果想给这个list上锁，可以通过调用Collections 的静态方法 synchronizedList(),将不加锁的容器返回成一个加了锁的容器。123456public class T03_SynchronizedList &#123; public static void main(String[] args) &#123; List&lt;String&gt; strs = new ArrayList&lt;&gt;(); List&lt;String&gt; strsSync = Collections.synchronizedList(strs); &#125;&#125; ConcurrentQueue12345678910111213141516171819202122public class T04_ConcurrentQueue &#123; public static void main(String[] args) &#123; Queue&lt;String&gt; strs = new ConcurrentLinkedQueue&lt;&gt;(); for(int i=0; i&lt;10; i++) &#123; // offer 类似于 add,有一个boolean类型的返回值,表示是否添加成功 strs.offer("a" + i); &#125; System.out.println(strs); System.out.println(strs.size()); // 表示从队列头部拿出一个,队列数量减少一个 System.out.println(strs.poll()); System.out.println(strs.size()); // 表示从队列中拿出来，但是不删除，队列数量不会变 System.out.println(strs.peek()); System.out.println(strs.size()); //双端队列Deque, 可以从两端取，也可以往两端添加 &#125;&#125; LinkedBlockingQueue 无界队列，使用链表实现的阻塞式容器,添加了两个方法，put,take1234567891011121314151617181920212223242526272829303132public class T05_LinkedBlockingQueue &#123; static BlockingQueue&lt;String&gt; strs = new LinkedBlockingQueue&lt;&gt;(); static Random r = new Random(); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; try &#123; strs.put("a" + i); //如果满了，就会等待 TimeUnit.MILLISECONDS.sleep(r.nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "p1").start(); for (int i = 0; i &lt; 5; i++) &#123; new Thread(() -&gt; &#123; for (;;) &#123; try &#123; System.out.println(Thread.currentThread().getName() + " take -" + strs.take()); //如果空了，就会等待 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "c" + i).start(); &#125; &#125;&#125; ArrayBlockingQueue ArrayBlockingQueue,是有界队列，能装的元素的个数是固定的。12345678910111213141516171819public class T06_ArrayBlockingQueue &#123; static BlockingQueue&lt;String&gt; strs = new ArrayBlockingQueue&lt;&gt;(10); static Random r = new Random(); public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 10; i++) &#123; strs.put("a" + i); &#125; strs.put("aaa"); //满了就会等待，程序阻塞 //strs.add("aaa"); // 会报异常 //strs.offer("aaa"); // 会通过返回值通知是否添加成功 //strs.offer("aaa", 1, TimeUnit.SECONDS); // 一秒钟之后加不进去，就不加了 System.out.println(strs); &#125;&#125; DelayQueue 无界队列，队列里的每一个元素都有一个时间表示自己还有多久时间可以被消费,可以用来做执行定时任务。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class T07_DelayQueue &#123; static BlockingQueue&lt;MyTask&gt; tasks = new DelayQueue&lt;&gt;(); static Random r = new Random(); static class MyTask implements Delayed &#123; long runningTime; MyTask(long rt) &#123; this.runningTime = rt; &#125; @Override public int compareTo(Delayed o) &#123; if(this.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) return -1; else if(this.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) return 1; else return 0; &#125; @Override public long getDelay(TimeUnit unit) &#123; return unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS); &#125; @Override public String toString() &#123; return "" + runningTime; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; long now = System.currentTimeMillis(); MyTask t1 = new MyTask(now + 1000); MyTask t2 = new MyTask(now + 2000); MyTask t3 = new MyTask(now + 1500); MyTask t4 = new MyTask(now + 2500); MyTask t5 = new MyTask(now + 500); tasks.put(t1); tasks.put(t2); tasks.put(t3); tasks.put(t4); tasks.put(t5); System.out.println(tasks); for(int i=0; i&lt;5; i++) &#123; System.out.println(tasks.take()); &#125; &#125;&#125; TransferQueue 提供一个transfer方法。 消费者先启动，当生产者生产的时候，先找消费者，有消费者直接给消费者，而不是放入队列,效率更高， 用在更高的并发场景下。12345678910111213141516171819202122232425public class T08_TransferQueue &#123; public static void main(String[] args) throws InterruptedException &#123; LinkedTransferQueue&lt;String&gt; strs = new LinkedTransferQueue&lt;&gt;(); /*new Thread(() -&gt; &#123; try &#123; System.out.println(strs.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start();*/ //strs.transfer("aaa"); strs.put("aaa"); new Thread(() -&gt; &#123; try &#123; System.out.println(strs.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; SynchronusQueue 没有容量的队列，有消息直接被消费，而不能放入队列。1234567891011121314151617public class T09_SynchronusQueue &#123; //容量为0 public static void main(String[] args) throws InterruptedException &#123; BlockingQueue&lt;String&gt; strs = new SynchronousQueue&lt;&gt;(); new Thread(()-&gt;&#123; try &#123; System.out.println(strs.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); strs.put("aaa"); //阻塞等待消费者消费 //strs.add("aaa"); System.out.println(strs.size()); &#125;&#125;]]></content>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题沉淀「二」]]></title>
    <url>%2Fquestions-share-2.html</url>
    <content type="text"><![CDATA[关键字: 幂等、CountDownLatch、异常处理、B+ 树 问题： 如何保证幂等机制解决方案： 幂等机制的核心是保证资源唯一性，例如客户端重复提交或服务端的多次重试只会产生一份结果。支付场景、退款场景，涉及金钱的交易不能出现多次扣款等问题。事实上，查询接口用于获取资源，因为它只是查询数据而不会影响到资源的变化，因此不管调用多少次接口，资源都不会改变，所以是它是幂等的。而新增接口是非幂等的，因为调用接口多次，它都将会产生资源的变化。因此，我们需要在出现重复提交时进行幂等处理。 那么，如何保证幂等机制呢？事实上，我们有很多实现方案。其中，一种方案就是常见的创建唯一索引。在数据库中针对我们需要约束的资源字段创建唯一索引，可以防止插入重复的数据。但是，遇到分库分表的情况是，唯一索引也就不那么好使了，此时，我们可以先查询一次数据库，然后判断是否约束的资源字段存在重复，没有的重复时再进行插入操作。注意的是，为了避免并发场景，我们可以通过锁机制，例如悲观锁与乐观锁保证数据的唯一性。这里，分布式锁是一种经常使用的方案，它通常情况下是一种悲观锁的实现。但是，很多人经常把悲观锁、乐观锁、分布式锁当作幂等机制的解决方案，这个是不正确的。除此之外，我们还可以引入状态机，通过状态机进行状态的约束以及状态跳转，确保同一个业务的流程化执行，从而实现数据幂等。 事实上，并不是所有的接口都要保证幂等，换句话说，是否需要幂等机制可以通过考量需不需要确保资源唯一性，例如行为日志可以不考虑幂等性。当然，还有一种设计方案是接口不考虑幂等机制，而是在业务实现的时候通过业务层面来保证，例如允许存在多份数据，但是在业务处理的时候获取最新的版本进行处理。 问题： redis key 过期后如何防止流量瞬间打在DB上?探讨：因为key过期后，不确定有多大的流量打在db上，所以，要提前reload这种情况，没有特别好的方式。有文章说用分布式锁。其实是错误的，这样所有流量压力也会打到锁上，这种只是把压力转换了。最好的方式只能对DB做限流，热点数据做本地缓存，这样能防止一个特别热的key，很大的流量都到DB。什么是热点数据？而且基本上所有item都是长尾效应，用户能接触的只有10%的商品；剩下的90%商品都用不到缓存，热与否，是会随时间的变化而变化的~，当然99%的公司，不需要考虑这个问题，所以很多时候在大流量面前很多方案变的那么无力！！！ 问题： CountDownLatch 实际运用在项目中什么样的场景？解答： 做某个事情可能会有前置条件，比如 A depends on B，C，那 A 要等到 B,C 任务完成了才能开始。比如聚餐，可能需要等所有人到齐才能开始，比赛颁奖需要等所有运动员赛完了，才能开始颁奖。等等… futureTask 只是等待线程池里的线程执行完毕，但是线程间没有依赖关系，完全互相独立的。所以 fututreTask 和 countDownLatch 适用的场景不一样。 问题： 项目中的异常一般是不是不在 controller 层 catch 处理，而是丢给专门的 ControllerAdvice 处理？解答：ControllerAdvice 处理确实是一种好方案。我们自定义一个运行时异常，然后统一处理，并且封装给一个统一格式的异常 JSON 格式。 问题： 为什么 B+ 树适合做索引？解答：索引本身很大，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。而 B+ 树带有顺序访问的指针，并且利用了磁盘预读以及计算机局部性原理，相比 B 树和红黑树，B+ 树的磁盘IO数最少。具体原理看：MySQL索引背后的数据结构及算法原理 Reference: 梁桂钊的知识星球 –「服务端思维」]]></content>
      <tags>
        <tag>沉淀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题沉淀「一」]]></title>
    <url>%2Fquestions-share-1.html</url>
    <content type="text"><![CDATA[关键字: mysql字符编码、索引、介绍项目、跨库跨表关联 问题： 在 join 操作时，为什么 MySQL 编码不同，性能差距很大。解决方案： 问题字符集转换遵循由小到大的原则，因为utf8mb4是utf8的超集，所以这里把utf8转换成utf8mb4，即把t1.code转换成utf8mb4字符集，转换了之后，由于t1.code上面的索引仍然是utf8字符集，所以这个索引就被执行计划忽略了，然后t1表只能选择全表扫描。更糟糕的是，如果t2筛选出来的记录不止1条，那么t1就会被全表扫描多次，性能之差可想而知。链接:MySQL表字段字符集不同导致的索引失效问题 问题： MySQL的最左前缀在第一字段不存在的情况下，为什么使用到了索引？解决方案： 可以认真阅读这篇文章。链接：mysql索引最左匹配原则的理解? - 知乎 问题： 面试中面试官让谈一谈 MySQL 中的索引，怎么回答比较好？解决方案： MySQL是很常用的数据库，其中改善性能最好的方式，就是通过数据库中合理地使用索引。因此，首先可以谈谈在项目中如何设计索引。其次，索引使用的注意事项有哪些，例如复合索引的最左前缀原则，范围查询对多列查询的影响等。最后，如果面试官对原理比较感兴趣，可能再聊聊数据库索引的原理，为什么要用 B-tree，聚集索引与非聚集索引的区别这些问题。此外，加分项，还可以说说自己在项目中，遇到了哪些索引的难点，例如之前提到的编码转换的索引失效问题，以及通过曲线救国的方式满足业务场景。 问题： 如何介绍项目解决方案： 面试官问这个问题，主要是考察你的概述能力和全局视野。当然，今天我们聊的并不是面试题，而是我们怎么去理解和复盘我们每天做的事情。有的人经常抱怨自己每天在堆业务，但没有成长。事实上，很多情况下确实在堆业务，但并不是没有成长的。并非做中间件或者技术架构才是成长，例如我们的需求分析能力，沟通协作能力，产品思维能力，抽象建模能力等都是一个非常重要的硬实力。首先，请你静下来思考，你真的了解自己每天在做的事情吗，你真的了解自己所做的业务吗？ 好的，现在进入正文，我们如何理解和复盘项目。这里，列了一个清单，请大家好好思考下这些内容。 明确项目的周期。 明确项目的价值。（为什么做这个项目，它解决了用户什么痛点，它带来什么价值？） 明确项目的功能。（这个项目涉及哪些功能？） 明确项目的技术。（这个项目用到哪些技术？） 明确个人在项目中的位置和作用。（你在这个项目的承担角色？） 明确项目的整体架构。 明确项目的优缺点,如果重新设计你会如何设计。 明确项目的亮点。（这个项目有什么亮点？） 明确技术成长。（你通过这个项目有哪些技术成长？） 问题： 分库与分表，联合查询就遇到跨库关联和跨表关系问题，那应该怎么办？解决方案： 其实，数据量小的情况下，怎么使用都没有问题的。 如果在数据量大的情况下，不一定分库分表，单库也不行的。看阿里编码规范，禁止存储过程，尽量不要使用join，有也不要超过3个。 联合查询不一定性能就差，如果很多join，都能用到主键或者唯一键性能也不差的。 业务解偶，单张表也能更好缓存。 在单库单表的情况下，联合查询是非常容易的。但是，随着分库与分表的演变，联合查询就遇到跨库关联和跨表关系问题。在设计之初就应该尽量避免联合查询，可以通过程序中进行拼装，或者通过反范式化设计进行规避。 Reference: 梁桂钊的知识星球 –「服务端思维」]]></content>
      <tags>
        <tag>沉淀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 高并发编程「二」]]></title>
    <url>%2Fjava-concurrent-programming-2.html</url>
    <content type="text"><![CDATA[reentrantlockreentrantlock可以用于替代synchronized，使用reentrantlock可以完成同样的功能,需要注意的是，必须要手动释放锁,使用synchronized锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放 1234567891011121314151617181920212223242526272829303132333435public class ReentrantLock2 &#123; Lock lock = new ReentrantLock(); void m1() &#123; try &#123; lock.lock(); //synchronized(this) for (int i = 0; i &lt; 10; i++) &#123; TimeUnit.SECONDS.sleep(1); System.out.println(i); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); // 手动释放锁 &#125; &#125; void m2() &#123; lock.lock(); System.out.println("m2 ..."); lock.unlock(); &#125; public static void main(String[] args) &#123; ReentrantLock2 rl = new ReentrantLock2(); new Thread(rl::m1).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(rl::m2).start(); &#125;&#125; 使用reentrantlock可以进行尝试锁定tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ReentrantLock3 &#123; Lock lock = new ReentrantLock(); void m1() &#123; try &#123; lock.lock(); for (int i = 0; i &lt; 10; i++) &#123; TimeUnit.SECONDS.sleep(1); System.out.println(i); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; /** * 使用tryLock进行尝试锁定，不管锁定与否，方法都将继续执行 * 可以根据tryLock的返回值来判定是否锁定 * 也可以指定tryLock的时间，由于tryLock(time)抛出异常，所以要注意unclock的处理，必须放到finally中 */ void m2() &#123; /* boolean locked = lock.tryLock(); System.out.println("m2 ..." + locked); if(locked) lock.unlock(); */ boolean locked = false; try &#123; locked = lock.tryLock(5, TimeUnit.SECONDS); System.out.println("m2 ..." + locked); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if(locked) lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; ReentrantLock3 rl = new ReentrantLock3(); new Thread(rl::m1).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(rl::m2).start(); &#125;&#125; 使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应123456789101112131415161718192021222324252627282930313233343536373839404142public class ReentrantLock4 &#123; public static void main(String[] args) &#123; Lock lock = new ReentrantLock(); Thread t1 = new Thread(()-&gt;&#123; try &#123; lock.lock(); System.out.println("t1 start"); TimeUnit.SECONDS.sleep(Integer.MAX_VALUE); System.out.println("t1 end"); &#125; catch (InterruptedException e) &#123; System.out.println("interrupted!"); &#125; finally &#123; lock.unlock(); &#125; &#125;); t1.start(); Thread t2 = new Thread(()-&gt;&#123; try &#123; //lock.lock(); lock.lockInterruptibly(); //可以对interrupt()方法做出响应 System.out.println("t2 start"); TimeUnit.SECONDS.sleep(5); System.out.println("t2 end"); &#125; catch (InterruptedException e) &#123; System.out.println("interrupted!"); &#125; finally &#123; lock.unlock(); &#125; &#125;); t2.start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t2.interrupt(); //打断线程2的等待 &#125;&#125; ReentrantLock还可以指定为公平锁123456789101112131415161718192021public class ReentrantLock5 extends Thread &#123; private static ReentrantLock lock=new ReentrantLock(true); //参数为true表示为公平锁，请对比输出结果 public void run() &#123; for(int i=0; i&lt;100; i++) &#123; lock.lock(); try&#123; System.out.println(Thread.currentThread().getName()+"获得锁"); &#125;finally&#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) &#123; ReentrantLock5 rl=new ReentrantLock5(); Thread th1=new Thread(rl); Thread th2=new Thread(rl); th1.start(); th2.start(); &#125;&#125; ThreadLocalThreadLocal 线程局部变量,ThreadLocal是使用空间换时间，synchronized是使用时间换空间,比如在hibernate中session就存在与ThreadLocal中，避免synchronized的使用.123456789101112131415161718192021222324252627282930public class ThreadLocal2 &#123; //volatile static Person p = new Person(); static ThreadLocal&lt;Person&gt; tl = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; new Thread(()-&gt;&#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(tl.get()); &#125;).start(); new Thread(()-&gt;&#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; tl.set(new Person()); &#125;).start(); &#125; static class Person &#123; String name = "zhangsan"; &#125;&#125;]]></content>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道有意思的多线程编程题]]></title>
    <url>%2Fjava-multi-thread-problem.html</url>
    <content type="text"><![CDATA[题目描述实现一个容器，提供两个方法，add，size写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束 代码123456789101112131415161718192021222324252627282930313233343536373839public class MyContainer2 &#123; //添加volatile，使t2能够得到通知 volatile List lists = new ArrayList(); public void add(Object o) &#123; lists.add(o); &#125; public int size() &#123; return lists.size(); &#125; public static void main(String[] args) &#123; MyContainer2 c = new MyContainer2(); new Thread(() -&gt; &#123; for(int i=0; i&lt;10; i++) &#123; c.add(new Object()); System.out.println("add " + i); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "t1").start(); new Thread(() -&gt; &#123; while(true) &#123; if(c.size() == 5) &#123; break; &#125; &#125; System.out.println("t2 结束"); &#125;, "t2").start(); &#125;&#125; 这样给 lists 添加 volatile 之后，t2能够接到通知，但是t2线程的死循环很浪费cpu，再看看下面这个方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class MyContainer4 &#123; //添加volatile，使t2能够得到通知 volatile List lists = new ArrayList(); public void add(Object o) &#123; lists.add(o); &#125; public int size() &#123; return lists.size(); &#125; public static void main(String[] args) &#123; MyContainer4 c = new MyContainer4(); final Object lock = new Object(); new Thread(() -&gt; &#123; synchronized(lock) &#123; System.out.println("t2启动"); if(c.size() != 5) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("t2 结束"); //通知t1继续执行 lock.notify(); &#125; &#125;, "t2").start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; new Thread(() -&gt; &#123; System.out.println("t1启动"); synchronized(lock) &#123; for(int i=0; i&lt;10; i++) &#123; c.add(new Object()); System.out.println("add " + i); if(c.size() == 5) &#123; lock.notify(); //释放锁，让t2得以执行 try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;, "t1").start(); &#125;&#125; 这里使用wait和notify做到，wait会释放锁，而notify不会释放锁,notify之后，t1必须释放锁，t2退出后，也必须notify，通知t1继续执行,整个通信过程比较繁琐下面这种方法使用Latch（门闩）替代wait notify来进行通知12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MyContainer &#123; // 添加volatile，使t2能够得到通知 volatile List lists = new ArrayList(); public void add(Object o) &#123; lists.add(o); &#125; public int size() &#123; return lists.size(); &#125; public static void main(String[] args) &#123; MyContainer c = new MyContainer(); CountDownLatch latch = new CountDownLatch(1); new Thread(() -&gt; &#123; System.out.println("t2启动"); if (c.size() != 5) &#123; try &#123; latch.await(); //也可以指定等待时间 //latch.await(5000, TimeUnit.MILLISECONDS); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("t2 结束"); &#125;, "t2").start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; new Thread(() -&gt; &#123; System.out.println("t1启动"); for (int i = 0; i &lt; 10; i++) &#123; c.add(new Object()); System.out.println("add " + i); if (c.size() == 5) &#123; // 打开门闩，让t2得以执行 latch.countDown(); &#125; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "t1").start(); &#125;&#125; 好处是通信方式简单，同时也可以指定等待时间,使用await和countdown方法替代wait和notify,CountDownLatch不涉及锁定，当count的值为零时当前线程继续运行,当不涉及同步，只是涉及线程通信的时候，用synchronized + wait/notify就显得太重了,这时应该考虑countdownlatch/cyclicbarrier/semaphore.]]></content>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmd 与 bash 基础命令入门]]></title>
    <url>%2Fcmd-and-bash.html</url>
    <content type="text"><![CDATA[不论是 bash 还是 cmd ，我们也通常称它们为“命令行工具”或者是“命令行界面(CLI)”。最后，为什么我们要学习它们？因为学习它们，cmd 可以让我们可以在 windows 或者 bash linux 等简单使用场景中，脱离对鼠标与用户界面的依赖，从而提高编码效率。 CMD 基础命令目录操作切换目录cd ：进入指定的目录或者是显示当前的目录。123cd #显示当前的路径cd dir/sub-dir #进入到dir中的sub-dir目录。d: #直接进入d盘 列出文件与子目录dir ：列出当前目录中的文件以及子目录1dir dir 除了能默认显示当前目录的文件以及子目录，还可以显示指定目录下的文件以及子目录，同时也会统计目录下的文件以及目录的数量。1dir d:\fornt #显示D盘font目录中的资源 dir 默认不显示一些特殊属性的文件(例如被隐藏了的文件)，如果想显示所有文件,可以使用 /a 参数。1dir /a 如果只是想显示具有特定属性的文件，可以为 /a 参数附加对应的属性。12345dir /a [d|r|h|s] #显示具有指定属性的文件dir /ad #只显示目录dir /ar #只显示只读文件dir /ah #只显示隐藏文件dir /as #只显示系统文件 dir 还有一个 /o 的参数也会比较常用，使用它可以分类显示文件以及目录。12345dir /o [n | s | e | d]dir /on #按名称(字母)显示dir /os #按大小(从小到大)dir /oe #按扩展名(字母顺序)dir /od #按日期/时间(从先到后) 创建目录mkdir | md ：新建目录12mkdir dir # 新建一个dir目录mkdir dir1\dir2\dir3 # 连续新建三个目录。 删除目录rmdir | rd ：删除指定目录1234md dirnamerd dirnamemd dir1\dir2\dir3rd dir1\dir2\ 注意：如果目录中含有其它目录或者是文件，单纯使用 rd 将无法删除，必须要结合一些特殊的参数，例如 /s 强制删除 /q 安静模式（不会询问）。 复制目录xcopy ：将目录复制到指定的位置。1xcopy dir e:dir1 #将dir目录复制到 E盘，并重命名为dir1。 注意：使用这种方式复制目录，只能将目录以及目录中的文件复制到新的位置，但是并不能将目录中的子目录以及子目录中的所有文件也复制过去。但可以通过附加一个参数 /e 从而实现将整个目录（所有的子目录以及文件）都复制到新的位置中。1xcopy dir e:dir1 /e 移动目录move ：将指定的目录移动到新的目录中12move C:\Users\gt\Desktop\test distDir #将指定的目录移动到新的目录中move dir1 dir2 #将dir1目录移动到dir2目录中 重命名目录rename | ren ：重命名文件或目录名。1ren dirName newDirName 显示树形目录tree ： 显示目录的树形图。12tree #当前目录的树形图tree C:\Users\gt\Desktop\ #指定目录的树形图 PS：感觉此命令在我们写项目文档时很有用，使用它可以帮我们生成项目目录的树形结构。 文件操作新建文件notepad : 打开window的记事本程序新建文件。123notepad filename.extnotepad 1.txtnotepad index.js notepad 是调用window中的记事本程序来新建文件。 删除文件del ：删除指定的文件或者是清空指定目录中的文件。1234del filename #删除指定的文件del file1 file2 .. #删除多个文件del dir #清空指定目录下的所有文件del dir1 dir2 dir3 .. #清空多个目录下的文件。 当使用 del 清空指定目录下的所有文件时，默认会有一个询问，如果想忽略询问，只需要加一个参数/q即可。1del dir /q 出此之外，使用 del 还可以删除特定属性的文件123del /AR #可以删除只读文件del /AH #可以删除隐藏文件del /AS #可以删除系统文件 最后，del 还可以结合通配符来删除匹配到文件。 复制文件copy ：复制一个或者是多个文件12345copy file.txt file_copy.txt #在当前目录由file.txt 复制为一个名为file_copy.txt的新文件。copy C:\Users\Admin\Desktop\index.js index_copy.js #将桌面上的index.js文件复制到当前目录，并命名为index_copy.jscopy file1 dir\file2 #相对目录进行复制。copy file1+file2 dir\file3 #将当前目录的file1与file2文件复制到dir目录中并合成一个新的file3文件。copy C:\Users\Admin\Desktop\ #将桌面上的所有文件复制到当前目录。 copy 命令还具有两个不是太常用的参数：12copy file /A #复制一个ASCII文件。copy file /B #复制一个二进制文件。 copy 命令只能复制指定目录中的文件，而不能复制指定目录中的子目录和文件。如果想复制目标目录下的所有文件和文件夹，可以使用 xcopy 命令，它相当于 copy 命令的扩展版。 移动文件move ：将指定的文件移动到新的位置。12move file.txt dir/file.txt #将指定的文件移动到指定的目录中。move file.txt dir/newfile.txt #移动的同时，重新命名。 重命名文件ren ：重命名文件1ren oldfilename newfilename 文件内容比较fc ：在指定的文件集中比较文件的内容1fc file1 file2 file3 打印文件type ：在命令行工具中打印文件内容。12type file #打印文件file的内容。type dir\file #打印指定目录中file文件的内容。 type 命令还可以结合通配符一起使用，打印多个文件的内容。1type dir\* #打印指定目录dir中所有文件的内容。 查找文件我们知道 dir 是用于列出指定目录中所有的文件或子目录，实际上 dir 后面还可以跟上文件名目录名或者是通配符来设置只列出匹配到的文件以及目录。123dir index.js #列出该目录下的index.jsdir *.js #列出该目录下扩展名为js的所有文件。dir * #列出所有文件 与查找文件相同，dir 也可以查找指定的目录1dir dirname 根据内容查找文件find ：根据文件内容查找文件，不确定文件名称或者是扩展名时可结合通配符使用。1234find "function handle" index.js #确定文件查找find "function handle" *.js #根据文件名模糊查找find "function handle" ?.js #查找文件名只有一个字符的js文件。find "function handle" /* #查找所有文件 find 命令还具有一些其它有用的参数：/i 忽略大小写 , /v 只显示匹配到的文件，/n 显示行号。 环境变量注意，如果想在window中设置永久的环境变量，只能通过 “我的电脑” - “属性” - “高级” - “环境变量”。使用命令行来设置环境变量只对当前窗口有效，窗口关闭时，将会自动失效。 设置环境变量set : 通过set命令我们即可以查看指定的环境变量，也可以设置一个新的环境变量。1234set #查看当前的所有环境变量set PATH #查看环境变量PATH的值。set key = value #设置一个新的环境变量并赋值。set key = value2 #重新对指定的环境变量赋值。 path这个环境变量是用于设置可执行文件（程序）的搜索路径，是非常常用的一个环境变量。 使用环境变量在CMD中，如果想引用某个环境变量，则使用 %env% 的格式。1234echo %PATH%set name=usrnameecho %name% 辅助命令123456789101112131415cls #清除屏幕。cmd #进入MS-DOSecho #显示消息，或将命令回显打开或关闭。exit #退出 CMD.EXE 程序(命令解释程序)。start #启动单独的窗口以运行指定的程序或命令。calc #启动计算器explorer #打开资源管理器notepad #打开记事本dxdiag #检查DirectX信息regedt32 #注册表编辑器Msconfig #系统配置实用程序taskmgr #打开任务管理器help #查看MS-DOS命令帮助。command /? #查看指定命令详细帮助文档。wmic #进入wmic（Windows Management Instrumentation），它是windows管理工具命令行版，使用wmic我们可以对整个系统进行管理，例如远程连接、硬件管理、进程管理、账号管理、服务管理、目录管理、共享管理等等，可说它是一个增强版的CMD。 BASH 基本命令目录操作切换目录cd ：进入指定的目录。123cd #进入个人目录cd / #进入根目录cd - #返回上次的目录 如果不确定自己当前的目录位置，可以结合 pwd 命令，便会在命令行中打印出当前目录路径。1pwd 列出文件与子目录ls ：列出当前目录中的文件以及子目录1234567ls``` `ls` 除了能默认显示当前目录的资源以及子目录，还可以显示指定目录下的文件以及子目录```markdownls ../ #列出上级目录下的资源和子目录ls / #列出根目录下的资源和子目录。ls /home #列出home目录下的资源和子目录。 ls 默认不显示具有特殊属性的文件(例如被隐藏了的文件)，如果想显示所有文件,可以使用 -a 参数1ls -a 如果要查看资源或目录更详细的信息，可以附加 -l 属性1ls -l 创建目录mkdir ：创建目录。12mkdir dir #创建一个目录dirmkdir dir1 dir2 dir3.. #同时创建多个同级目录 如果想创建一个目录树，可以附加一个 -p 参数。1mkdir -p a/b/c/d 删除目录rmdir ：删除空目录12rm -rf ：强制删除目录(包括非空目录)。rmdir emptyDir #删除一个空目录 如果想删除一个非空目录，则需要使用 rm 命令，并使用 -rf 参数。123rm -rf dir #删除一个非空目录。rm -rf dir1 dir2 dir3 #同时删除多个非空目录。rm -rf pattern #删除按照特定模式匹配到的目录。 复制目录cp -a ：复制目录到指定的位置。12cp -a dir ../dir #将当期目录复制一份到上级目录中。cp -a dir dir2 #复制目录并重命名。 移动目录mv ：移动目录到指定位置。123mv file file2 #同级移动，相当于重命名目录file为file2mv file ../file2 #将目录移动到上级目录中并重命名。sudo mv /home/user/file /home/ #将指定位置的目录移动到指定位置中。 另外，mv 也可以结合通配符进行使用。1mv * ../ #将所有的目录与文件都复制到上级目录中。 重命名目录利用 mv 命令同级移动功能，并结合重命名的特点，就可以做到目录的重命名。1mv file newfile2 #同级移动，相当于重命名目录file为newfile2 显示树形目录tree ：显示目录的树形图。12tree #当前目录的树形图tree / #根目录下的树形图 PS：感觉此命令在我们写项目文档时很有用，使用它可以帮我们生成项目目录的树形图。 常用目录说明12345678/ #根目录/bin #命令保存目录/boot #启动目录/dev #设备文件命令/etc #配置文件保存目录/home #家目录/lib #系统库保存命令/mnt #系统挂载目录 文件操作新建文件touch ：新建文件123touch filename #新建一个文件。touch file1 file2 file3... #同时新建多个文件。touch dir/file #在指定的位置中新建一个文件。 如果终端已经附加了 vi 编辑器，也可以使用 vi filename 的形式来创建文件，与 cmd 中的 notepad 命令功能类似。 删除文件rm ：删除文件。123rm file #删除文件rm dir/file #删除指定目录中的文件rm dir/* #删除指定目录中的所有文件。 复制文件cp ：复制文件到指定的位置123cp file file1 #将文件复制一份并重新命名。cp file ../ #将文件复制一份到上级目录中。sudo cp file / #将文件复制到根目录中。 cp 还可以结合通配符一起使用，将匹配到的文件复制到指定的位置中。1cp dir/* ./ #指定目录中的所有文件复制到当前目录中。 移动文件mv ：移动文件到指定的位置123mv file ../ #将文件移动到上级目录中。mv ../file ./ #将上级的文件移动到当前目录中。sudo mv file / #将文件移动到根目录中。 mv 不仅可以移动文件，还可以在移动后重命名文件。1mv filename1 ../filename2 mv还可以结合通配符使用。1mv na?.txt ../nbc.txt 重命名文件利用 mv 命令同级移动的功能再结合其可以重命名的特点，从而实现文件的重命名。1mv file file2 #同级移动，相当于重命名文件file为file2 文件内容比较diff ：比较多个文件内容的不同1diff file1 file2 ... 打印文件cat ：在命令行工具中打印文件的内容12cat filename #打印指定文件的内容cat file1 file2 #同时打印多个文件的内容 cat 命令除了能打印文件的内容，还可以合并多个文件的内容保存到一个新的文件中。1cat file1 file2 &gt; newfile 除此之外，还可以结合通配符来打印匹配到的所有文件内容。12cat a*cat *.txt 如果查看的文件内容很多，还可以使用 less 命令1less file 然后使用 space 便可以向下一页一页的翻动，或者 pgup 向上翻页 , pgdn 向下翻页，q 则可以退出 less 命令。 查找文件find ：可以根绝名称、大小、修改时间来查找指定的文件。12345find -name httpd.conf #在当前目录下查找httpd.conf文件。find -name *.js #在当前目录下查找所有js文件。find -empty #查找所有为空的目录。find -size -1000 #查找小于1000KB的文件。find -size +1000 #查找大于1000KB的文件。 find 命令默认在当前目录进行查找，你也可以指定一个目录进行查找。12find / -name *.txt #在根目录下查找所有的txt文件。find /etc -name httpd.conf #在etc目录下查找httpd.conf文件。 与根据文件名查找文件相同，也可以使用 find 按照目录名来查找目录。1find -name dirname 根据内容查找文件grep ：可以根据指定的内容来查找含有这些内容的文件。12grep pattern * #查找当前目录含有指定匹配模式的文件。pattren可以是一个正则表达式。grep c * #查找当前目录含有单词c的文件。 如果想忽略内容的大小写可以附加一个 -i 的参数。显示匹配行及行号附加 -n如果只显示文件名，不显示具体匹配到的内容，则附加 -l 参数 压缩与解压gzip ：单独压缩指定的文件，压缩后删除被压缩文件，只保留压缩后的文件，并且不能压缩目录。12gzip file #压缩指定的文件gzip file1 file2 file3... #同时压缩多个文件 gzip 还可以与通配符结合使用，压缩匹配到的文件。12gzip *.*gzip ?.?.* 若想列出某个 .gz 压缩文件中的内容，可以附加一个 -l 参数。1gzip -l file.gz 解压某个.gz 文件，则使用 gunzip 命令。1gunzip file.gz zip ：与 gzip 相比 zip 可以压缩目录还可以将多个文件压缩在一起，并保留被压缩的文件。1zip filename.zip file1 file2 ... #将指定的文件压缩到一个新创建的压缩文件中。 zip 也可以结合通配符使用，压缩匹配到的文件。1zip filename.zip *.txt 更强的是 zip 还可以一次性压缩一个目录1zip filename.zip dir 同样的，若想列出某个 .zip 压缩文件中的内容，可以附加一个 -l 参数。1unzip -l filename.zip 解压某个.zip 文件，则使用 unzip 命令。1unzip file.zip 打包与解包tar ：它是linux下的一个打包命令，它可以将一大堆松散的文件或者是目录打包在一起，从而保证资源的完整性。1tar -cvf package.tar file1 file2 file3 ... 如果要打包一个目录，则指定目录名：1tar -cvf package.tar dirname 如果想解包，则附加 -xvf 的参数即可。1tar -xvf package.tar 如果只是想列出某个包中含有的文件或目录,则附加 -tvf 参数即可。1tar tvf package.tar tar 命令只能打包，而不能压缩，而 gzip 虽然可以压缩但是只能对文件进行单独压缩，并且只保留压缩后的文件，而不保留被压缩的文件，所以将 tar + gzip 结合使用，将会互补其短，产生更大的功效。12tar package.tar file1 file2 file3 ... #将多个文件打包在package.tar包文件中。gzip package.tar.gz package.tar #将通过tar打包的文件再进行压缩。 解压缩解包也要依次进行。12gunzip package.tar.gz #解压缩tar -xvf package.tar #解包 当然，你也可以通过附加参数的方式一次性的打包压缩。1tar -zcvf package.tar.gz 然后一次性的解压缩解包1tar -zxvf package.tar.gz 常用快捷键1234567ctr+c #终止当前命令ctr+l ##清屏 相当于 clearctr+a #光标移到行首ctr+e #光标移到行尾ctr+u #把光标所在位置删除到行首ctr+d #删除光标前面的字符，一旦内容全部删除再按则会退出窗口。ctr+h #删除光标后面的字符， 其他常用命令12345678910clear #清除屏幕。echo #显示消息，或将命令回显打开或关闭。whoami #返回当前登录用户名。passwd #允许当前登录的用户更改其密码。file #尝试判断指定文件的类型。exit #退出命令行工具users #显示当前登录系统地用户last #查看用户的登录日志cammand --help #查看相关命令的帮助文档。ping #查看网络状态]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八张图理解 JAVA]]></title>
    <url>%2Ftop-8-diagrams-for-understanding-java.html</url>
    <content type="text"><![CDATA[一图胜千言，下面图解均来自 Program Creek 网站的 Java教程，目前它们拥有最多的票选。如果图解没有阐明问题，那么你可以借助它的标题来一窥究竟。 字符串不变性下面这张图展示了这段代码做了什么12String s = &quot;abcd&quot;;s = s.concat(&quot;ef&quot;); equals()方法、hashCode()方法的区别HashCode被设计用来提高性能。equals()方法与hashCode()方法的区别在于： 如果两个对象相等(equal)，那么他们一定有相同的哈希值。 如果两个对象的哈希值相同，但他们未必相等(equal)。 Java异常类的层次结构图中红色部分为受检查异常。它们必须被捕获，或者在函数中声明为抛出该异常。 集合类的层次结构注意Collections和Collection的区别。（Collections包含有各种有关集合操作的静态多态方法） Java同步Java同步机制可通过类比建筑物来阐明。 别名别名意味着有多个变量指向同一可被更新的内存块，这些别名分别是不同的对象类型。 堆和栈图解表明了方法和对象在运行时内存中的位置。 Java虚拟机运行时数据区域图解展示了整个虚拟机运行时数据区域的情况。 原文链接：programcreek 翻译：ImportNew.com - era_misa译文链接：http://www.importnew.com/11725.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 高并发编程「一」]]></title>
    <url>%2Fjava-concurrent-programming.html</url>
    <content type="text"><![CDATA[知识回顾线程的概念一个程序里不同的执行路径，可以放在不同的 cpu 里同步的执行的。 如何启动一个线程 继承java.lang.Thread类 实现java.lang.Runnable接口 在线程的Thread对象上调用start()方法，启动新的执行线程。 基本的线程同步使用 synchronized synchronizedjava 的每个对象都有一个内置锁，synchronized 修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。123456789101112131415161718192021/** * @author botaogou@gmail.com * @create 2018-02-02 15:50 **/public class T implements Runnable&#123; private int x = 3; @Override public synchronized void run() &#123; x--; System.out.println(Thread.currentThread().getName() + " x=" + x); &#125; public static void main(String[] args) &#123; T t = new T(); for (int i = 0; i &lt; 2; i++) &#123; new Thread(t,"THREAD" + i).start(); &#125; &#125;&#125; 注意当 synchronized 锁定一个静态方法的时候，相当于锁定的是这个类的 class 对象，将会锁住整个类。12345678910public class T1 &#123; private static int count = 10; // 这里等值于 synchronized(T1.class) public synchronized static void m() &#123; count--; System.out.println(Thread.currentThread().getName() + "count" + count); &#125;&#125; 同步和非同步方法是可以同时调用的，因为非同步方法的调用时，不需要获得内置锁。12345678910111213141516171819202122232425262728293031public class T &#123; public synchronized void m1() &#123; System.out.println(Thread.currentThread().getName() + " m1 start..."); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " m1 end"); &#125; public void m2() &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " m2 "); &#125; public static void main(String[] args) &#123; T t = new T(); /*new Thread(()-&gt;t.m1(), "t1").start(); new Thread(()-&gt;t.m2(), "t2").start();*/ new Thread(t::m1, "t1").start(); new Thread(t::m2, "t2").start(); &#125;&#125; 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁，也就是说 synchronized 获得的锁是可重入的。1234567891011121314151617181920public class T &#123; synchronized void m1() &#123; System.out.println("m1 start"); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; m2(); &#125; synchronized void m2() &#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("m2"); &#125;&#125; 这里是继承中有可能发生的情形，子类调用父类的同步方法12345678910111213141516171819202122232425public class T &#123; synchronized void m() &#123; System.out.println("m start"); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("m end"); &#125; public static void main(String[] args) &#123; new TT().m(); &#125; &#125;class TT extends T &#123; @Override synchronized void m() &#123; System.out.println("child m start"); super.m(); System.out.println("child m end"); &#125;&#125; 程序在执行过程中，如果出现异常，默认情况锁会被释放，所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适，在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。因此要非常小心的处理同步业务逻辑中的异常123456789101112131415161718192021222324252627282930313233343536373839public class T &#123; int count = 0; synchronized void m() &#123; System.out.println(Thread.currentThread().getName() + " start"); while(true) &#123; count ++; System.out.println(Thread.currentThread().getName() + " count = " + count); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if(count == 5) &#123; int i = 1/0; //此处抛出异常，锁将被释放，要想不被释放，可以在这里进行catch，然后让循环继续 &#125; &#125; &#125; public static void main(String[] args) &#123; T t = new T(); Runnable r = new Runnable() &#123; @Override public void run() &#123; t.m(); &#125; &#125;; new Thread(r, "t1").start(); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(r, "t2").start(); &#125;&#125; volatilevolatile 关键字，使一个变量在多个线程间可见,使用volatile关键字，会让所有线程都会读到变量的修改值。1234567891011121314151617181920212223242526272829public class T &#123; /*volatile*/ boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别 void m() &#123; System.out.println("m start"); while(running) &#123; /* try &#123; TimeUnit.MILLISECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;*/ &#125; System.out.println("m end!"); &#125; public static void main(String[] args) &#123; T t = new T(); new Thread(t::m, "t1").start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t.running = false; &#125;&#125; 但是volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized。123456789101112131415161718192021222324252627public class T &#123; volatile int count = 0; void m() &#123; for(int i=0; i&lt;10000; i++) count++; &#125; public static void main(String[] args) &#123; T t = new T(); List&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;(); for(int i=0; i&lt;10; i++) &#123; threads.add(new Thread(t::m, "thread-"+i)); &#125; threads.forEach((o)-&gt;o.start()); threads.forEach((o)-&gt;&#123; try &#123; o.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(t.count); &#125;&#125; 对比上一个程序，可以用synchronized解决，synchronized可以保证可见性和原子性，volatile只能保证可见性12345678910111213141516171819202122232425262728public class T &#123; /*volatile*/ int count = 0; synchronized void m() &#123; for (int i = 0; i &lt; 10000; i++) count++; &#125; public static void main(String[] args) &#123; T t = new T(); List&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;(); for (int i = 0; i &lt; 10; i++) &#123; threads.add(new Thread(t::m, "thread-" + i)); &#125; threads.forEach((o) -&gt; o.start()); threads.forEach((o) -&gt; &#123; try &#123; o.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(t.count); &#125;&#125; 决同样的问题的更高效的方法，使用AtomXXX类,AtomXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的1234567891011121314151617181920212223242526272829303132public class T &#123; /*volatile*/ //int count = 0; AtomicInteger count = new AtomicInteger(0); /*synchronized*/ void m() &#123; for (int i = 0; i &lt; 10000; i++) //if count.get() &lt; 1000 count.incrementAndGet(); //count++ &#125; public static void main(String[] args) &#123; T t = new T(); List&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;(); for (int i = 0; i &lt; 10; i++) &#123; threads.add(new Thread(t::m, "thread-" + i)); &#125; threads.forEach((o) -&gt; o.start()); threads.forEach((o) -&gt; &#123; try &#123; o.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(t.count); &#125;&#125; synchronized优化,同步代码块中的语句越少越好,比较m1和m2123456789101112131415161718192021222324252627282930313233343536373839404142public class T &#123; int count = 0; synchronized void m1() &#123; //do sth need not sync try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁 count ++; //do sth need not sync try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; void m2() &#123; //do sth need not sync try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁 //采用细粒度的锁，可以使线程争用时间变短，从而提高效率 synchronized(this) &#123; count ++; &#125; //do sth need not sync try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 锁定某对象o，如果o的属性发生改变，不影响锁的使用,但是如果o变成另外一个对象，则锁定的对象发生改变,应该避免将锁定对象的引用变成另外的对象1234567891011121314151617181920212223242526272829303132333435public class T &#123; Object o = new Object(); void m() &#123; synchronized(o) &#123; while(true) &#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); &#125; &#125; &#125; public static void main(String[] args) &#123; T t = new T(); //启动第一个线程 new Thread(t::m, "t1").start(); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //创建第二个线程 Thread t2 = new Thread(t::m, "t2"); t.o = new Object(); //锁对象发生改变，所以t2线程得以执行，如果注释掉这句话，线程2将永远得不到执行机会 t2.start(); &#125;&#125; 不要以字符串常量作为锁定对象,在下面的例子中，m1和m2其实锁定的是同一个对象,这种情况还会发生比较诡异的现象，比如你用到了一个类库，在该类库中代码锁定了字符串“Hello”，但是你读不到源码，所以你在自己的代码中也锁定了”Hello”,这时候就有可能发生非常诡异的死锁阻塞，因为你的程序和你用到的类库不经意间使用了同一把锁1234567891011121314151617public class T &#123; String s1 = "Hello"; String s2 = "Hello"; void m1() &#123; synchronized(s1) &#123; &#125; &#125; void m2() &#123; synchronized(s2) &#123; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 学习笔记]]></title>
    <url>%2Fmaven-learn-note.html</url>
    <content type="text"><![CDATA[什么是 MavenMaven 是跨平台的项目管理工具。主要服务于基于Java平台的项目构建，依赖管理和项目信息管理。 目录介绍 bin目录是包含mvn的运行脚本 boot目录包含一个类加载器的框架，maven使用它加载自己的类库 conf配置文件 lib包含maven运行时的依赖类库 环境变量的配置Maven 的下载配置Maven下载maven 环境配置，增加一个环境变量MAVEN_HOME,值是maven的安装路径（C:\Program Files\apache-maven-3.5.0-bin\apache-maven-3.5.0）修改path则是在path最后面添加;%MAVEN_HOME%\bin。 Maven 的项目结构123456789|----src| |----main| | |----java ——存放项目的.java文件| | |----resources ——存放项目资源文件，如spring, hibernate配置文件| |----test| | |----java ——存放所有测试.java文件，如JUnit测试类| | |----resources ——存放测试资源文件|----target ——项目输出位置|----pom.xml ----用于标识该项目是一个Maven项目 常用命令123456mvn -v 查看maven版本compile 编译test 测试packag 打包clean 删除targetinstall 安装jar包到本地仓库 maven快速创建项目骨架目录两种方式： mvn archetype:generate 按照提示进行选择 mvn archetype:generate -DgroupId=com.imooc.maven -DartifactId= maven-service -Dversion=1.0.0SNAPSHOT -Dpackage=com.imooc.maven.demo12341. -DgroupId=组织名，公司网址反写+项目名2. -DartifactId=项目名+模块名3. -Dversion=版本号4. -Dpackage=代码所存在的包名 Maven中的坐标和仓库构件坐标:1231. groupId:公司名字+项目名2. artifactId：项目名+模块名3. varsion:版本号 仓库：1231. 本地仓库2. 远程仓库3. 镜像仓库 更改仓库默认路径已安装到本地仓库中的jar包位置：1C:\Users\用户\.m2\repository\com\tiakon\demo 安装路径conf文件夹下settings.xml文件打开找到这段备注的代码： 12345&lt;!-- localRepository| The path to the local repository maven will use to store artifacts.| Default: $&#123;user.home&#125;/.m2/repository --&gt;&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; 将localRepository便签内的值替换成新路径即可。 maven生命周期完整的项目构建过程包括： 清理、编译、测试、打包、集成测试、验证、部署 maven三套独立的生命周期12345678910111213clean 清理项目 1.pre-clean 执行清理前的工作 2.clean 清理上一次构建生成的所有文件 3.post-clean 执行清理后的文件default 构建项目（最核心） compile test package installsite 生成项目站点 1. pre-site 在生成项目站点前要完成的工作 2. site 生成项目的站点文档 3. post-site 在生成项目站点后要完成的工作 4. site-deploy 发布生成的站点到服务器上 maven 中 pom.xml 常见元素介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!--指定了当前pom的版本--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.tiakon.maven.demo&lt;/groupId&gt; &lt;artifactId&gt;HoictasStudio-MavenDemo01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 第一个0表示大版本号 第二个0表示分支版本号 第三个0表示小版本号 0.0.1 snapshot 快照 alpha 内部测试 beta 公测 Release 稳定 GA 正式发布 --&gt; &lt;!-- 打包方式:默认是jar,可选war、zip、pom &lt;packaging&gt;&lt;/packaging&gt; --&gt; &lt;!--指定编码格式--&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!-- 项目名 &lt;name&gt;&lt;/name&gt; 项目地址 &lt;url&gt;&lt;/url&gt; 项目描述 &lt;description&gt;&lt;/description&gt; 开发人员列表 &lt;developers&gt;&lt;/developers&gt; 许可证信息 &lt;licenses&gt;&lt;/licenses&gt; 组织信息 &lt;organization&gt;&lt;/organization&gt; --&gt; &lt;!--依赖列表--&gt; &lt;dependencies&gt; &lt;!--依赖项--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;!--&lt;type&gt;&lt;/type&gt;--&gt; &lt;!--依赖范围--&gt; &lt;!--&lt;scope&gt;&lt;/scope&gt;--&gt; &lt;!--设置依赖是否可选（默认）false--&gt; &lt;!--&lt;optional&gt;&lt;/optional&gt;--&gt; &lt;!--排斥依赖传递列表--&gt; &lt;!-- &lt;exclusions&gt; &lt;exclusion&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; --&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--依赖的管理，作用主要定义在父模块中，对子模块进行管理--&gt; &lt;!-- &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; --&gt; &lt;!--对构件的行为提供相应的支持--&gt; &lt;build&gt; &lt;!--插件列表--&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt; jar-no-fork &lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--通常用于子模块对父模块pom的继承--&gt; &lt;!--&lt;parent&gt;&lt;/parent&gt;--&gt; &lt;!--用来聚合运行Maven项目，指定多个模块一起编译--&gt; &lt;!-- &lt;modules&gt; &lt;module&gt;&lt;/module&gt; &lt;/modules&gt; --&gt; &lt;/project&gt; Maven的依赖范围1234三种classpath 1. 编译 2. 测试 3. 运行 maven提供了6种可选依赖范围: compile: 默认范围，编译测试运行都有效。 provided: 在编译和测试时有效。（比如说在开发JavaEE时，你在本地运行的servlet，是需要调用已添加到项目中的servlet-api.jar这个jar包的。这个过程就包含了编译【就是把Java文件编译成class文件的过程中也要调用】和测试【测试就是在本地运行】，那么他说的运行是指，整个项目已开发完成，编译、测试通过后，将class文件或包含有class文件的war包发布到服务器上的Tomcat中运行，这时启动项目，就可以直接调Tomcat中的servlet-api.jar，不必再将自己的jar包添加到项目中去。也就是说当你选择provided时，项目发布时Maven不会将你添加的jar包，加入到项目中。） runtime: 在测试和运行时有效。(典型例子：JDBC驱动的实现。) test: 只在测试是有效。 system: 类似provided，与本机系统相关联，可移植性差。 import: 导入范围，他只是用在dependencyManagement中，表示从其他的pom中导入dependecy的配置。（以下引用官网案例并不难理解。） Importing Dependencies123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;maven&lt;/groupId&gt; &lt;artifactId&gt;B&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;B&lt;/name&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;maven&lt;/groupId&gt; &lt;artifactId&gt;A&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;test&lt;/groupId&gt; &lt;artifactId&gt;d&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;test&lt;/groupId&gt; &lt;artifactId&gt;a&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;test&lt;/groupId&gt; &lt;artifactId&gt;c&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; Assuming A is the pom defined in the preceding example, the end result would be the same. All of A’s managed dependencies would be incorporated into B except for d since it is defined in this pom. 假设A是前面示例中定义的pom，那么最终结果将是相同的。所有管理的依赖项都将被合并到B中，除了在这个pom中定义的d之外。 依赖冲突短路优先:C-&gt;B-&gt;A-&gt;X1(jar)C-&gt;B-&gt;X2(jar)「C依赖B,B依赖A,A和B都包含同一个不同版本的Jar,则取B的依赖版本。（c的pom.xml中不必注明jar坐标）」 先声明先优先如果路径相同长度相同，则谁先声明，先解析谁。「C依赖A和B,A和B都包含同一个不同版本的Jar,谁依赖在前取谁的依赖版本。」 聚合与继承聚合123456&lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;../HoictasStudio-MavenDemo01&lt;/module&gt; &lt;module&gt;../HoictasStudio-MavenDemo02&lt;/module&gt; &lt;module&gt;../HoictasStudio-MavenDemo03&lt;/module&gt; &lt;/modules&gt; 假设在HoictasStudio-MavenParent模块中添如以上代码，输入clean install命令后，即可同时安装多个jar到本地仓库中1234[INFO] HoictasStudio-MavenDemo01 .......................... SUCCESS [ 4.618 s][INFO] HoictasStudio-MavenDemo02 .......................... SUCCESS [ 0.828 s][INFO] HoictasStudio-MavenDemo03 .......................... SUCCESS [ 0.923 s][INFO] HoictasStudio-MavenParent .......................... SUCCESS [ 0.021 s] 继承根据官方文档说明继承会根据父模块与子模块的包含与否，对pom.xml的写法则有两种。 第一种写法假设我们有两个模块，前一个叫 com.mycompany.app:my-app:1，后一个叫com.mycompany.app:my-module:1。 my-app的pom文件为：123456&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/project&gt; my-module的pom文件为：123456&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-module&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/project&gt; 我们指定如下项目结构：1234.|-- my-module| `-- pom.xml`-- pom.xml 那么，我们需要my-module去继承my-app，则需要在my-module的pom文件中添加以下代码：1234567891011&lt;project&gt; &lt;parent&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-module&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/project&gt; 第二种写法However, that would work if the parent project was already installed inour local repository or was in that specific directory structure (parent pom.xml is one directory higher than that of the module’s pom.xml). But what if the parent is not yet installed and if the directory structure is12345.|-- my-module| `-- pom.xml`-- parent `-- pom.xml 上一段话摘自官网对继承的介绍，就是说如果你的父模块已在本地安装或者父模块不包含子模块，目录级别甚至是比子模块的还要高，就在第一种写法上添加&lt;relativePath&gt;标签。 &lt;project&gt; &lt;parent&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;my-module&lt;/artifactId&gt; &lt;/project&gt;]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--单例模式]]></title>
    <url>%2Fsingleton-pattern.html</url>
    <content type="text"><![CDATA[设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 单例模式介绍单例模式的目的： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 实现单例模式的实现方式有懒汉式和饿汉式 饿汉式顾名思义，类加载时就初始化，所以也容易产生垃圾对象，浪费内存,基于 classloder 机制避免了多线程的同步问题,也就没有加锁，执行效率会提高。12345678910111213public class Single&#123; //让构造函数为 private，这样该类就不会被实例化 private Single()&#123;&#125; //创建 SingleObject 的一个对象 private static Single instance = new Single(); //提供了一个静态方法，供外界获取它的静态实例 public static Single getInstance()&#123; return instance; &#125;&#125; 然后别的类通过 Single.getInstance() 获取 Single 类的唯一对象。 懒汉式线程不安全实现这种方式属于 lazy loading，因为没有加锁 synchronized，所以不支持多线程。1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 线程安全实现通过加 synchronized 保证在多线程中单例，每次调用 getInstance() 方法都需要进行线程锁定判断,加锁会影响效率。12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 双重校验锁利用双重校验锁，第一次检查是否实例已经创建，如果还没创建，再进行同步的方式创建单例对象,安全且在多线程情况下能保持高性能。1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 静态内部类类加载的时候并不会实例化 Singleton，而是在第一次调用 getInstance() 加载内部类 SigletonHolder，此时才进行初始化 instance 成员变量，确保内存中的对象唯一性。123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 枚举枚举的特点是，构造方法是 private 修饰的，并且成员对象实例都是预定义的，因此我们通过枚举来实现单例模式非常的便捷不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化,12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 总结实际上，我们应该采用饿汉式还是采用懒汉式，取决于我们希望空间换取时间，还是时间换取空间的抉择问题。一般情况建议使用饿汉式，类被加载时就实例化，因此无须考虑多线程安全问题，并且对象一开始就得以创建，性能方面要优于懒汉式，如果要求懒加载，可以考虑使用静态内部类或者双检锁方式。]]></content>
      <tags>
        <tag>Design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 数据访问与多数据源配置]]></title>
    <url>%2FSpringBoot-multi-datasource.html</url>
    <content type="text"><![CDATA[在一个应用中访问多个数据源的情况在开发场景中很常见，比如 MySQL 的分库场景，所以需要配置多个数据源。 引入 maven 依赖12345678910111213141516171819&lt;!-- 添加 jdbc 的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mysql 连接类 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 连接池类 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt;&lt;/dependency&gt; 数据源相关配置12345678910# mysqlspring.datasource.one.driver-class-name=com.mysql.jdbc.Driverspring.datasource.one.url=jdbc:mysql://localhost:3306/db1spring.datasource.one.username=rootspring.datasource.one.password=rootspring.datasource.two.driver-class-name=com.mysql.jdbc.Driverspring.datasource.two.url=jdbc:mysql://localhost:3306/db2spring.datasource.two.username=rootspring.datasource.two.password=root 创建 dataSource 和 jdbcTemplate设定主数据源为 spring.datasource.one 开头的配置，并添加 @Primary ，这样我们还可以享受 Spring Boot 提供的自动配置 DataSource 的机能。此外，第二数据源配置为 spring.datasource.two 开头的配置12345678910111213141516171819202122232425262728@Configuration@EnableTransactionManagementpublic class BeanConfig &#123; @Bean(name = "oneDataSource") @Qualifier("oneDataSource") @Primary @ConfigurationProperties(prefix="spring.datasource.one") public DataSource oneDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = "twoDataSource") @Qualifier("twoDataSource") @ConfigurationProperties(prefix="spring.datasource.two") public DataSource twoDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = "oneJdbcTemplate") public JdbcTemplate oneJdbcTemplate(@Qualifier("oneDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; @Bean(name = "twoJdbcTemplate") public JdbcTemplate twoJdbcTemplate(@Qualifier("twoDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 单元测试用例123456789101112131415@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(WebMain.class)public class JdbcTest &#123; @Resource(name="oneJdbcTemplate") protected JdbcTemplate jdbcTemplate1; @Resource(name="twoJdbcTemplate") protected JdbcTemplate jdbcTemplate2; @Test public void test() throws Exception &#123; jdbcTemplate1.update("insert into t_author(id, name, age) values(?, ?, ?)", 1, "gbt", "22"); jdbcTemplate2.update("insert into t_author(id, name, age) values(?, ?, ?)", 1, "wave", "23"); &#125;&#125;]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop 基础]]></title>
    <url>%2Fhadoop-basis.html</url>
    <content type="text"><![CDATA[初始大数据什么是大数据？123大数据是一个概念也是一门技术，是在以Hadoop为代表的大数据平台框架上进行各种数据分析的技术。大数据包括了以Hadoop和Spark为代表的基础大数据框架。还包括实时数据处理、离线数据处理；数据分析，数据挖掘和用机器算法进行预测分析等技术。 学习基础要求123会 Linux 常用命令有一定的 Python 或者 Java 编程基础对 Hadoop 有一定的了解，可以搭建自己的测试环境 Hadoop 的功能和优势hadoop 是开源的、分布式存储、分布式计算平台，可以用来搭建大型数据仓库,PB级数据的存储、处理、分析、统计等业务Hadoop包括两个核心组成: HDFS:分布式文件系统,存储海量的数据 MapReduce:并行处理框架,实现任务分解和调度 相关开源工具： hbase 放弃了事务的特性，追求更高的扩展，提供了数据的随机读写和实时访问，实现对表数据的读写功能 zookeeper 监控 hadoop 每个节点的状态，管理集群配置，维护节点间数据的一致性。 hive 将简单的 sql 语句转化为 hadoop 任务，降低使用 hadoop 的门槛 Hadoop 安装1231. 准备Linux环境2. 安装JDK Java编写3. 配置Hadoop hadoop安装及配置： 下载hdoop安装包并进行解压 配置hdoop-env.sh文件，目的是配置jdk，并在profile配置haddoop的安装位置export JAVA_HOME=安装好的JDK(配置的JAVA_HOME)export HADOOP_HOME=/opt/hadoop-1.2.1export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$HADOOP_HOME/bin:$PATH 配置core-site.xml文件：hdoop的核心文件，里面有关于hdoop的节点端口与主机端口 123456789101112&lt;configuration&gt;&lt;propery&gt;&lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/hadoop&lt;/value&gt; &lt;!-- 工作目录 --&gt;&lt;/propery&gt;&lt;name&gt;dfs.name.dir&lt;/name&gt;&lt;value&gt;/hadoop/name&lt;/value&gt; &lt;!-- 所有元数据的目录 --&gt;&lt;propery&gt;&lt;name&gt;fs.default.name&lt;/name&gt;&lt;value&gt;hdfs://imooc:9000&lt;/value&gt; &lt;!-- 表示文件系统如何访问 namenode --&gt;&lt;/propery&gt;&lt;/configuration&gt; 配置hdfs-site.xml文件：hadoop的文件存储的基本信息与目录 1234&lt;property&gt;&lt;name&gt;dfs.data.dir&lt;/name&gt;&lt;value&gt;/hadoop/data&lt;/value&gt; &lt;!-- 文件系统的数据存放路径 --&gt;&lt;/property&gt; 配置mapred-site.xml文件：hadoop的计算节点的端口号 1234&lt;property&gt;&lt;name&gt;mapred.job.tracker&lt;/name&gt;&lt;value&gt;imooc:9001&lt;/value&gt; &lt;!-- 配置任务调度器如何访问 --&gt;&lt;/property&gt; 格式化：hadoop namenode -format 启动 hadoop：start-all.sh 查看端口：jps,可以看到五大守护进程说明正确 停止 hadoop：stop-all.sh Hadoop 核心 HDFSHDFS 基本概念 块 Block 文件分块存储 默认64MB 逻辑单元 NameNode (管理节点，存放文件元数据) 文件与数据库的映射表 数据库与数据节点的映射表 DataNode (工作节点，存放数据块) 数据管理策略 hdfs是采用master-slave的模式关管理文件，即一个master(namenade:保存datanode的一些基本信息和元数据)和多个slave(datanode:真正的存贮单元，里面存储了真实数据) hdfs默认保存三份文件，有两份保存在同一台机器上，另外一份（备份文件）保存到另外一台机器上，确保当一台机器挂了时能保存数据的存在 namenade也有一个备用节点：Secondary NameNode,当namenode挂了时secondaryNameNode就变为nameNode的角色进行管理数据 datandoe会采用心跳的方式时不时的想namenode报告自己的基本信息，比如网络是否正常，运行是否正确常 HDFS 中文件读写的流程客户端发出读写请求，namenode根据元数据返回给客户端，下载需要的block并组装 HDFS 读取文件的流程： 客户端向namenode发起独立请求，把文件名，路径告诉namenode； namenode查询元数据，并把数据库返回客户端； 此时客户端就明白文件包含哪些块，这些块在哪些datanode中可以找到； HDFS 写入文件的流程： 客户端将文件拆分成块 客户端通知NameNode,NameNode返回可用的DataNode节点地址 客户端根据返回的DataNode将数据块写入到可用的DataNode中 因为数据块要有三份，所以会通过一个复制管道将每个数据块复制出另外两份并保存 更新元数据NameNode HDFS 特点 数据冗余，硬件容错（一式三份来保证） 流式数据访问：写一次，读多次，一旦写入无法修改，只能通过写入到新的块删除旧的块进行处理 存储大文件（特适合，因为小文件多，势必加重NameNode的负担） 优点：存储块大，吞吐量高，为存储大文件设计；适合一次写入多次读取，顺序读写缺点：延迟高，不适合交互式访问，不支持多用户并发写相同文件 HDFS 使用它提供了 shell 接口，可以进行命令行操作，常用Hadoop的shell命令：1234567#hadoop fs -format #格式化操作#hadoop fs -ls / #展示文件#hadoop fs -cat input/hsdf-site.xml #查看Hadoop里面的指定文件#hadoop fs -mkdir input #未指明目录，表示在Hadoop的文件系统下的默认目录/user/root下新建#hadoop fs -put hdsf-site.xml input/ #上传文件到Hadoop#hadoop fs -get hdfs-site.xml hdfs-site2.xml #从Hadoop下载文件#hadoop dfsadmin -report #查看HADF使用情况（所有信息） Hadoop 核心 MapReduceMapReduce 的原理Mapreduce原理：分而治之，一个大任务分成多个子任务（map），并行执行之后，合并结果（reduce）。eg：做统计的时候，把统计的文件拆分，然后分别统计每一个数据出现的次数，然后合并拆分项，就可以统计每一个数据出现的总次数。 在正式执行Map前，需要将输入数据进行”分片”。所谓分片，就是将输入数据切分为大小相等的数据块，每一块作为单个Map Worker的输入被处理，以便于多个Map Worker同时工作。 分片完毕后，多个Map Worker就可以同时工作了。每个Map Worker在读入各自的数据后，进行计算处理，最终输出给Reduce。Map Worker在输出数据时，需要为每一条输出数据指定一个Key。这个Key值决定了这条数据将会被发送给哪一个Reduce Worker。Key值和Reduce Worker是多对一的关系，具有相同Key的数据会被发送给同一个Reduce Worker，单个Reduce Worker有可能会接收到多个Key值的数据。 在进入Reduce阶段之前，MapReduce框架会对数据按照Key值排序，使得具有相同Key的数据彼此相邻。如果用户指定了”合并操作”(Combiner)，框架会调用Combiner，将具有相同Key的数据进行聚合。Combiner的逻辑可以由用户自定义实现。这部分的处理通常也叫做”洗牌”(Shuffle)。 接下来进入Reduce阶段。相同的Key的数据会到达同一个Reduce Worker。同一个Reduce Worker会接收来自多个Map Worker的数据。每个Reduce Worker会对Key相同的多个数据进行Reduce操作。最后，一个Key的多条数据经过Reduce的作用后，将变成了一个值。 MapReduce 的运行流程Job &amp; Task：一个 Job（任务、作业） 被切分为多个 Task，Task 又分为 MapTask 和 ReduceTask mapReduce 作业执行过程 JobTracker ：将一个Job拆分成多个Map和Reduce任务；分配Map和Reduce任务 作业调度 分配任务、监控任务 监控 TaskTracker 的状态 TaskTracker ：Map任务分发给下面的TaskTracker做实际 的任务；TaskTracker与DataNode保持对应关系 执行任务 向 JobTracker 汇报任务状态 mapReduce 容错机制 重复测试：如果一个TaskTracker节点在测试过程中失败，mapreduce会重新执行该任务，如果执行四次后仍失败，就停止执行该任务 推测测试：如果一个taskTracker执行得很慢，mapReduce就会重新开启一个taskTracker节点去计算相同的该任务，原来那个继续执行，重新开启的taskTracker如果先执行完，则mapReduce取到该结果后就会停止原来那个很慢的taskTracker节点]]></content>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 使用技巧]]></title>
    <url>%2Fidea-use-tips.html</url>
    <content type="text"><![CDATA[本着工欲善其事必先利其器的精神，闷头写代码之外花点时间研究一下自己用的 IDE，其带来的效率提升非常可观。 高效定位代码无处不在的跳转 项目之间跳转 下一个 ctrl + alt + ] 上一个 ctrl + alt + [ 文件之间跳转 最近的文件 ctrl + e 最近编辑的文件 ctrl + shift + e 浏览修改位置跳转 ctrl + shift + backspace 使用书签进行跳转 标记书签 ctrl + shift + 数字或字母 跳转书签 ctrl + 数字或者字母 总览书签 shift + F11 快速寻找功能快捷键 ctrl + shift + a 编辑区和文件区来回跳转 alt + 1 &amp; esc 精准搜索 类 ctrl + n 文件 ctrl + shift + n 符号 ctrl + alt + shift + n 字符串 ctrl + shift + f 代码小助手们列操作 选中单词 ctrl + &gt; 英文大小写切换 ctrl + shift + u 对所有选中单词进行操作 ctrl + alt + shift + j live template 位置：菜单-&gt;File-&gt;Setting-&gt;Editor-&gt;Live Templates 功能：定义模板，使用特定“字符”快速敲击出某段代码。 举例：psvm 敲出 public static void main(String[] args) postfix 位置：菜单-&gt;File-&gt;Setting-&gt;Editor-&gt;General-&gt;Postfix Completion 功能：使用后缀，快速敲出代码块。 举例：100.fori 敲出 for(int i=0;i&lt;100;i++){} alter + enter 自动创建函数 自动生成参数化 String.format 实现接口 单词拼写,单词建议 导包 编写高质量代码重构 重构变量：shift + F6 重构方法：ctrl + F6 抽取 抽取变量：ctrl + alt + v 抽取静态变量：ctrl + alt + c 抽取成员变量：ctrl + alt + f 抽取方法参数：ctrl + alt + p 抽取函数：ctrl + alt + m 关联一切Spring 的关联 位置：菜单-&gt;File-&gt;Project Structure-&gt;Facets 功能：帮助管理Spring容器。还提供了很多其他的管理，比如EJB 使用： 点击+号，选择Spring，选择模块 在Spring中，点击+号，起一个名字，选择spring配置文件。（SpringBoot中，选择类文件） 项目的各个文件中会出现spring的logo，其提供了很多功能。比如查看该Bean是在哪提供的。 与数据库的关联关联了数据库之后，如果需要重构字段或表名，不仅可以更改当前页面，还可以更改所有引用到该表的sql以及数据库表名或字段 调试程序断点调试 添加/取消断点 Ctrl + F8 调试 Shift + F10 运行 Shift + F9 单步运行 F8 跳到下一个断点 F9 查看所有断点 Shift + Ctrl + F8 禁止所有断点 debug后在左下角的Mute breakPoints 条件断点 在需要用条件断点的断点处，使用Shift + Ctrl + F8 动态求值 Alt + F8 运行到指定行 Alt + F9 动态改变值 F2 单元测试运行 运行上下文运行 ctrl+shift+F9 在当前可运行列表中选择一个运行 Shift + Alt + F9 其他操作文件操作 新建文件 Ctrl + Alt + Insert 复制文件 F5 移动文件 F6 文本操作 复制文件名 对着文件Ctrl+C 复制完整文件名 对着文件shift+Ctrl+C 批量复制 调用剪切板，shift+Ctrl+V 结构图 查看结构图 Ctrl+F12 查看类的继承关系 Ctrl+H 查看方法的调用和被调用 Ctrl+Alt+H 图表 ctrl+Alt+U]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 在 IDEA 中实现热部署]]></title>
    <url>%2FSpringBoot-hot-deployment-idea.html</url>
    <content type="text"><![CDATA[前阵子鼓捣了半天 JRebel ，打算借助 JRebel 热部署 SpringBoot 项目,提高开发测试效率,还是没搞定,后发现可以修改 IDE 启动命令实现热部署。 下载 Springloaded 的 Jar 包下载位置放到本地磁盘的某个目录下 修改启动方式配置点击 Edit Configurations配置 VM options,Springloaded jar 包的所在位置 打开自动编译1File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Compiler,选中 Build project automatically 打开运行时编译1按快捷键 Shift+Ctrl+Alt+/ ，点击 Registry 选中 compiler.automake.allow.when.app.running 然后重启 IDEA 即可。 还有一种方式是通过 spring-boot-devtools实现热部署，但是我个人极不推荐，觉得这种方式虽然配置简单，只需要引入依赖即可，但是每次修改后都会自动重启项目，和手动重启没有太大区别，影响性能。 通过 spring-boot-devtools 实现热部署的参考文章Spring boot 在Intellij IDEA 中的热部署Intellij IDEA 使用Spring-boot-devTools无效解决办法]]></content>
      <tags>
        <tag>IDEA</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 整合 Redis]]></title>
    <url>%2FSpringBoot-redis.html</url>
    <content type="text"><![CDATA[归纳总结 SpringBoot 整合 Redis,进行数据操作。 引入 maven 依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 数据源相关配置123456789spring.redis.host=localhostspring.redis.port=6379spring.redis.password=spring.redis.database=1spring.redis.pool.max-active=8spring.redis.pool.max-wait=-1spring.redis.pool.max-idle=500spring.redis.pool.min-idle=0spring.redis.timeout=0 数据访问层，使用 redisTemplate1234567891011121314@Repositorypublic class RedisBaseDao &#123; @Resource(name="redisTemplate") protected ValueOperations&lt;String, String&gt; valueOperations; public void addValue(String key, String value)&#123; valueOperations.set(key, value); &#125; public String getValue(String key)&#123; return valueOperations.get(key); &#125;&#125; 单元测试用例1234567891011121314151617@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootRedisApplicationTests &#123; public static Logger logger= LoggerFactory.getLogger(SpringbootRedisApplicationTests.class); @Test public void contextLoads() &#123; &#125; @Autowired RedisDao redisDao; @Test public void testRedis()&#123; redisDao.setKey("key","hello"); logger.info(redisDao.getValue("key")); &#125;&#125;]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 整合 eql 和 mybatis]]></title>
    <url>%2FSpringBoot-eql-or-mybatis.html</url>
    <content type="text"><![CDATA[归纳总结 SpringBoot 整合 mybatis 和 eql,并访问数据库。mybatis 框架已经十分流行了,eql 框架是一个简单，轻量的数据持久层的框架,可以用于代替ibatis/mybatis。 SpringBoot 整合 eql引入 maven 依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.bingoohuang&lt;/groupId&gt; &lt;artifactId&gt;eql&lt;/artifactId&gt; &lt;version&gt;0.0.73&lt;/version&gt;&lt;/dependency&gt; eql 相关配置123456789101112131415161718192021222324252627282930313233343536373839# 基本属性 ip port database url、user、passwordurl=jdbc:oracle:thin:@ip:port:databasedriver=oracle.jdbc.driver.OracleDriveruser=usernameusername=usernamepassword=passwd# 配置初始化大小、最小、最大initialSize=1minIdle=1maxActive=5# 配置获取连接等待超时的时间maxWait=60000# 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒timeBetweenEvictionRunsMillis=60000# 配置一个连接在池中最小生存的时间，单位是毫秒minEvictableIdleTimeMillis=300000validationQuery=SELECT 'x' FROM dual# 字段加解密 配置 startconnection.impl=org.n3r.eql.dbfieldcryptor.EqlSecretFieldsConnectionProxyproxy.connection.impl=org.n3r.eql.trans.EqlDruidConnectionsecret.fields.configable.impl=org.n3r.eql.dbfieldcryptor.refer.ReferSecretFieldsConfigsensitive.cryptor.impl=org.n3r.eql.dbfieldcryptor.refer.ReferSensitiveCryptorsecuretDatabaseFields.password=Ed23d930EEFfb1B8# 用于配置数据库表中需要加解密的字段，和存储过程中需要加解密的参数序号# 1.各个字段用空格分隔# 2.数据库字段：表名.字段名# 3.存储过程：存储过程名.参数的序号(序号从1开始)# 注意: 每行行末续行符反斜杠前添加至少一个空白字符（后面续行的前导空白会被自动去除）securetDatabaseFields.define=# 字段加解密 配置 end 在数据持久层使用在java代码中指明要执行的 sql 的id1234567891011121314151617181920import org.n3r.eql.Eql;import org.springframework.stereotype.Component;import java.util.List;import java.util.Map;/** * Created by wave_ on 2017/8/4. */@Componentpublic class DemoService &#123; public String queryProvinceName(String code) &#123; // 这里指定 eql 查询的id eg:queryNameByCode return new Eql().selectFirst("queryNameByCode").params(code).returnType(String.class).execute(); &#125; public List&lt;Map&gt; queryProvinceList() &#123; return new Eql().select("queryProvinceList").returnType(Map.class).execute(); &#125;&#125; 创建 eql 文件 在 resource 中创建 DemoService.eql 文件, 放在和 DemoService.class 一致的包路径下.目录结构 12345678- java - com - dao - DemoService.java- resource - com - dao - DemoService.eql 可以在持久层代码中直接指定eql的位置,就可以不用对应创建文件结构 123456789101112131415import org.n3r.eql.Eql;import org.springframework.stereotype.Component;import java.util.List;import java.util.Map;/** * Created by wave_ on 2017/8/4. */@Componentpublic class DemoService &#123; public String queryProvinceName(String code) &#123; // 这里指定 eql 文件所在的位置 return new Eql().useSqlFile("com/service/DemoService.eql").selectFirst("queryNameByCode").params(code).returnType(String.class).execute(); &#125;&#125; eql 文件存放 sql中括号中是相对应的 sql 的 id.12345-- [queryNameByCode]SELECT PROVINCE_CODE, PROVINCE_NAME FROM TF_M_PROVINCE WHERE PROVINCE_CODE = ##-- [queryProvinceList]SELECT PROVINCE_CODE, PROVINCE_NAME FROM TF_M_PROVINCE ORDER BY PROVINCE_CODE 这样通过持久层代码通过 Eql 指定要调用的 sql 的 id,然后把相应的 sql 语句写在相应的 eql 文件中即可。 SpringBoot 整合 mybatis引入 maven 依赖12345678910111213141516171819 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql 连接类 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 连接池类 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt;&lt;/dependency&gt; mybatis-spring-boot-starter依赖中存在spring-boot-starter-jdbc 在配置文件中配置数据源1234spring.datasource.url=jdbc:mysql://localhost:3306/hellospring.datasource.username=rootspring.datasource.password=momaspring.datasource.driver-class-name=com.mysql.jdbc.Driver 通过注解的方式使用 mybatis在 DAO 中123456789101112@Mapperpublic interface AuthorMapper &#123; @Insert("insert into account(name, money) values(#&#123;name&#125;, #&#123;money&#125;)") int add(@Param("name") String name, @Param("money") double money); @Update("update account set name = #&#123;name&#125;, money = #&#123;money&#125; where id = #&#123;id&#125;") int update(@Param("name") String name, @Param("money") double money, @Param("id") int id); @Delete("delete from account where id = #&#123;id&#125;") int delete(int id);&#125;]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 整合JdbcTemplate 访问 MySQL 数据库]]></title>
    <url>%2Fspringboot-JdbcTemplate-mysql.html</url>
    <content type="text"><![CDATA[归纳总结 SpringBoot 使用 JdbcTemplate 访问数据源的使用场景。 添加 maven 依赖1234567891011121314151617181920&lt;!-- 添加 jdbc 的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mysql 连接类 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 连接池类 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt;&lt;/dependency&gt; 配置文件中配置相关信息1234spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=moma 然后在数据持久层(Dao)使用即可12345678910111213141516import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;/** * @author botaogou@gmail.com * @create 2018-01-11 15:15 * **/public class JdbcDemoDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public int add(String str,String code) &#123; return jdbcTemplate.update("insert into account(title, code) values(?, ?)", str,code); &#125;&#125;]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建第一个SpringBoot工程]]></title>
    <url>%2Fbuild-first-springBoot-project.html</url>
    <content type="text"><![CDATA[学习和使用 SpringBoot 有一段时间了,现在开始陆陆续续会总结归纳 SpringBoot 学习中遇到的相关知识点。 SpringBoot设计目的是用来简化新Spring应用的初始搭建以及开发过程。为Spring生态系统提供了一种固定的、约定优于配置风格的框架。开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求。 环境准备 jdk1.8+ maven 3.0+ IDEA 搭建步骤12345- 打开 IDEA- New Project- Spring Initializr =&gt; next- 填写 group、artifact -&gt;钩上web(开启web功能）- next 工程结构1234567891011- src -main -java -package -SpringbootApplication -resouces - statics - templates - application.yml -test- pom pom文件为基本的依赖管理文件 resouces 资源文件 statics 静态资源 templates 模板资源 application.yml 配置文件 SpringbootApplication 程序的入口&amp;启动类 pom.xml 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.forezp&lt;/groupId&gt; &lt;artifactId&gt;springboot-first-application&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;springboot-first-application&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 测试 Demo123456789101112131415161718import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * 测试用例 * * @author botaogou@gmail.com * @create 2018-01-05 11:32 **/@RestControllerpublic class DemoController &#123; @RequestMapping("/hello") String index() &#123; return "Hello World!"; &#125;&#125; 然后启动 SpringbootApplication 的 main 方法, 然后打开游览器localhost:8080/hello,浏览器显示 Hello World! 测试通过~]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在IDEA启动多个Spring Boot工程实例]]></title>
    <url>%2Fhow-to-start-multiple-spring-boot-instances-with-idea.html</url>
    <content type="text"><![CDATA[step1在 IDEA 上点击 Edit Configuration step2打开配置后，将默认的 Single instance only (单实例)的钩去掉 step3通过修改 application 文件的server.port 的端口，启动。多个实例，需要多个端口，分别启动。]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>IDEA</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这一次，彻底弄懂 JavaScript 执行机制]]></title>
    <url>%2Fjs-execute-process.html</url>
    <content type="text"><![CDATA[推荐一篇介绍JavaScript 执行机制的文章。 Reference:这一次，彻底弄懂 JavaScript 执行机制]]></content>
      <tags>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 事务管理]]></title>
    <url>%2Fspring-transaction.html</url>
    <content type="text"><![CDATA[事务回顾什么是事务？ 事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。 事务的特性 原子性：是指事务是一个不可分割的工作单位，事务中的操作要么都发送，要么都不发生。 一致性：指事务前后数据的完整性必须保持一致。 隔离性：隔离性指多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要互相隔离。 持久性：是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，即使数据库发送故障也不应该对其有任何影响。 事务 API 介绍PlatformTransactionManager 事务管理器 TransactionDefinition 事务定义信息（隔离、传播、超时、只读）如果不考虑隔离性，会引发如下的安全问题： 脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的。 不可重复读：在同一个事务中，多次读取同一数据返回的结果有所不同。 幻读：一个事务读取了几行记录后，另一个事务插入一些记录，幻读就发生了。再后来的查询中，第一个事务就会发现有些原来没有的记录。 隔离级别的出现就是为了解决以上问题的。 数据库提供的事务的隔离级别(四种)： READ_UNCOMMITED：允许你读取还未提交的改变了的数据，可能导致脏，幻，不可重复读。 READ_COMMINTED: 允许在并发事务已经提交后读取，可防止脏读，但幻读和不可重复读还是有可能发生。 REPEATABLE_READ: 对相同字段的多次读取是一致的，除非数据被事务本身改变，可防止脏读，不可重复读，但幻读仍有可能出现。 SERILIZABLE: 完全服从ACID的隔离级别，确保不发生脏读，幻读，不可重复读，这在所有的隔离级别中是最慢的，它是典型的完全通过锁定在事务中涉及的数据表来完成的。 除了以上的数据库提供的事务隔离级别，spring提供了Default隔离级别，该级别表示spring使用后端数据库默认的隔离级别。 MySQL默认事务隔离级别：REPATABLE_READ(可能出现幻读)Oracle默认：READ_COMMITTED(可能出现不可重复读和幻读) TransactionDefinition 定义事务传播行为事务的传播行为：主要是解决业务层方法之间的相互调用的问题。Spring定义了7种事务的传播行为，可以分为3类： 是让整个业务处于一个事务当中PROPAGATION_REQUIRED,PROPAGATION_SUPPORTS,PROPAGATION_MANDATORY 是让业务不处于同一个事务当中PROPAGATION_REQUIRES_NEW,PROPAGATION_NOT_SUPPORTED,PROPAGATION_NEVER 是嵌套事务的执行，嵌套事务可以在第一个事务执行完毕时设置一个保存点，然后第二个业务操作发生异常时可以选择回滚到保存点，也可以回滚到初始状态。 TransactionStatus 事务具体运行状态TransactionStatus接口用来记录事务的状态,该接口定义了一组方法,用来获取或判断事务的相应状态信息.平台事务管理器(PlatformTransactionManager)会根据 TransactionDefinition 中定义的事务信息(包括隔离级别、传播行为)来进行事务的管理,在管理的过程中事务可能产生了保存点或事务是新的事务等情况,那么这些信息都会记录在 TransactionStatus 的对象中. 编程式事务管理为了简化设置事务的代码量,提供了TransactionTemplate事务管理模版类.在哪个地方需要用到事务,那么就在哪个地方注入这个模版.真正进行事务管理是由事务管理器来完成. 配置事务管理器：TranscationManager，一般在不适用Hibernate的情况下，使用DataSourceTranscationManager,需要注入数据源 配置事务管理器的事务管理的模板TransactionTemplate依赖于DataSourceTransactionManager数据源事务管理器(PlatformTransactionManager平台事务管理器的实现类). 配置文件中引入TransactionTemplate类,把数据源事务管理器对象注入到使用的事务的service层的类中，作为该bean的transactionManager属性.DataSourceTransactionManager数据源管理器又依赖于DataSource.因此把数据源对象注入到数据源管理器的dataSource属性中. 在service中，要定义一个TransactionTemplate的成员变量,并生成set()方法.因此要把TransactionTemplate的bean注入到Service实体类中的TransactionTemplate类型的属性中。执行transcationTemplate提供的execute方法，方法中进行事务的操作，这个方法中有个参数，transcationcallback，如果事务出现回滚，将会调用这个参数进行操作。如果匿名内部类要拿到外层包裹它的方法的参数，那么要将参数修饰成final 这里调用模板方法将两个dao操作放在一个事务里。 声明式事务管理基于 TransactionProxyFactoryBean 的声明式事务管理（创建代理对象） 基于 AspectJ 的XML方式 基于注解的方式 总结Spring将事务管理分成了两类:123456789* 编程式事务管理 * 手动编写代码进行事务管理.(很少使用)* 声明式事务管理: * 基于TransactionProxyFactoryBean的方式.(很少使用) * 需要为每个进行事务管理的类,配置一个TransactionProxyFactoryBean进行增强. * 基于AspectJ的XML方式.(经常使用) * 一旦配置好之后,类上不需要添加任何东西 * 基于注解方式.(经常使用) * 配置简单,需要在业务层上添加一个@Transactional的注解. 案例代码]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 遇见数据采集]]></title>
    <url>%2Fpython-data-collection.html</url>
    <content type="text"><![CDATA[Python 开发环境检测是否安装成功 python1python urllib 1from urllib.request import urlopen BeautifulSoup4 1from bs4 import BeautifulSoup 安装 BeautifulSoup4 Linux： 1sudo apt-get install python-bs4 Mac: 1sudo easy_install pip pip install beautifulsoup4 windows: 1pip install beautifulsoup4 pip3 install beautifulsoup4 urllib 和 BeautifulSoupurllib 基本用法 使用步骤 模拟浏览器 使用 urllib 发送 post 请求12345678910111213141516171819from urllib.request import urlopen # 引入urlopen 模块from urllib.request import Request # 引入urlrequest 模块from urllib import parse # 引入parse 模块req = Request(&quot;http://www.thsrc.com.tw/tw/TimeTable/SearchResult&quot;)postDate = parse.urlencode([(&quot;StartStation&quot;, &quot;2f940836-cedc-41ef-8e28-c2336ac8fe68&quot;),(&quot;EndStation&quot;, &quot;977abb69-413a-4ccf-a109-0272c24fd490&quot;),(&quot;SearchDate&quot;, &quot;2016/08/31&quot;),(&quot;SearchTime&quot;, &quot;21:30&quot;),(&quot;SearchWay&quot;, &quot;DepartureInMandarin&quot;)])req.add_header(&quot;Origin&quot;, &quot;http://www.thsrc.com.tw&quot;)req.add_header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; rv:48.0) Gecko/20100101 Firefox/48.0)&quot;)resp = urlopen(req,data=postDate.encode(&quot;utf-8&quot;))print(resp.read().decode(&quot;utf-8&quot;)) BeautifulSoup 简介 &amp; 使用官方文档 注意： beautifulsoup.findAll返回的是列表而不是字符串，应该用for循环来读取列表 获取维基百科词条信息12345678910from urllib.request import urlopenfrom bs4 import BeautifulSoup as bsimport reresp = urlopen(&quot;https://en.wikipedia.org/wiki/Main_Page&quot;).read().decode(&quot;utf-8&quot;)soup = bs(resp,&quot;html.parser&quot;)listUrls = soup.findAll(&quot;a&quot;, herf=re.compile(&quot;^/wiki/&quot;))for url in listUrls: if not re.search(&quot;\.(jpg|JPG)$&quot;,url[&quot;href&quot;]): print(url.get_text(),&quot;:&quot;,&quot;https://en.wikipedia.org&quot;+url[&quot;herf&quot;]) 存储数据到 MySQL存储数据到 MySQL1234567891011121314151617181920212223import urllib2import refrom bs4 import BeautifulSoupimport pymysqlresp = urllib2.urlopen(&quot;http://baike.so.com/doc/1790119-1892991.html&quot;).read().decode(&quot;utf-8&quot;)soup = BeautifulSoup(resp, &quot;html.parser&quot;)listUrls = soup.findAll(&quot;a&quot;, href = re.compile(&quot;^/doc/&quot;))for url in listUrls: print url.get_text(), &quot;http://baike.so.com&quot;+url[&quot;href&quot;]connection = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;&apos;, db=&apos;360mysql&apos;, charset=&apos;utf8&apos;)try: with connection.cursor() as cursor: for url in listUrls: sql = &quot;insert into `urls`(`name`,`url`)values(%s,%s)&quot; cursor.execute(sql,(url.get_text(),&quot;http://baike.so.com&quot;+url[&quot;href&quot;])) connection.commit();finally: connection.close(); 读取 MySQL 数据 得到总记录数： cursor.execute() 查询下一行： cursor.fetchone() 得到指定大小： cursor.fetchmany(size=None) 得到全部： cursor.fetchall() 关闭: connection.close() 常见文档读取（PDF）读取 pdf123456789101112131415161718192021222324# coding:utf-8from pdfminer.pdfparser import PDFParser,PDFDocumentfrom pdfminer.pdfinterp import PDFResourceManager,PDFPageInterpreterfrom pdfminer.pdfdevice import PDFDevicefrom pdfminer.layout import LAParamsfrom pdfminer.converter import PDFPageAggregatorfp = open(&quot;1.pdf&quot;,&quot;rb&quot;) # 打开对象，使用二进制方式parser = PDFParser(fp) # 创建对应的解释器，传入文件对象，可理解为解释文件doc = PDFDocument() # 创建文档对象parser.set_document(doc) # 两步方法将fp的解释器和doc文档关联起来doc.set_parser(parser) # 两步方法将fp的解释器和doc文档关联起来doc.initialize() # 关联了解释器的文档，进行初始化resource = PDFResourceManager() # 创建pdf的资源管理器laparams = LAParams() # 创建pdf的参数分析器device = PDFPageAggregator(resource,laparams=laparams) # 使用聚合器将资源管理器和参数分析器聚合在一起interpreter = PDFPageInterpreter(resource,device) # 创建页面解析器，将资源管理器和聚合其结合在一起for page in doc.get_pages(): # 获取文档对象的每一页 interpreter.process_page(page) # 使用页面解析器解析每一页 layout = device.get_result() # 使用聚合其获取解析的结果 for out in layout: # 遍历获取的结果 print(out.get_text()) # 输出]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 操作 MySQL 数据库]]></title>
    <url>%2Fpython-operations-MySQL-Database.html</url>
    <content type="text"><![CDATA[学习目标：能够开发完整的数据库操作程序。 开发环境Python DB API 是 Python 访问数据库的统一接口规范。官方接口说明 Python DB API 包含的内容 Python MySQL 开发环境 Python 操作数据库对象Python-数据库连接对象 connection 连接对象：建立 Python 客户端与数据库的网络连接 创建方法：MySQLdb.Connect(参数) host //MySQL 服务器地址 port //服务器端口号 user //用户名 passwd //密码 db //数据库名称 charset //连接编码 connection 对象支持的方法： cursor() //使用该连接创建并返回游标 commit() //提交当前事务 rollback() //回滚当前事务 close() //关闭连接 Python-游标对象 cursor 游标对象：用于执行查询和获取对象 cursor 对象支持的方法： execute(op[,args]) //执行一个数据库查询和命令 fetchone() //取得结果集的下一行 fetchmany(size) //获取结果集的剩下的所有行 rowcount //最近一次excute返回数据的行数和影响行数 close() //关闭游标对象 Python 增删改查数据库实例演示 select 查询数据 查询流程 实例代码123456789101112131415161718192021222324import MySQLdbconn = MySQLdb.Connect(host=&apos;127.0.0.1&apos;,port=3306,user=&apos;root&apos;,passwd=&apos;123456&apos;,db=&apos;IMOOC&apos;,charset=&apos;utf8&apos;)cur = conn.cursor()sql=&quot;select * from user&quot;cur.execute(sql)print cur.rowcountrs=cur.fetchone()print rsrs=cur.fetchmany(3)print rsrs=cur.fetchall()print rsfor row in rs: print &apos;userid=%d,username=%s&apos;%rowcur.close()conn.close() 实例演示 insert/update/delete 更新数据库 执行流程 实例代码 12345678910111213141516sql_insert = &apos;insert into stud(userid, username) values(&quot;12&quot;,&quot;name12&quot;)&apos;sql_upudate = &apos;update stud set username=&quot;name19&quot; where userid=&quot;9&quot;&apos;sql_insert = &apos;delete from stud where userid&lt;&quot;3&quot;&apos;try: cursor.execute(sql_insert) print cursor.rowcount cursor.execute(sql_upudate) print cursor.rowcount cursor.execute(sql_insert) print cursor.rowcount conn.commit()except Exception as e: print e conn.rollback() 使用 Python 实现实例银行转账实例 流程 实例代码主方法12345678910111213141516if __name__ ==&quot;__main__&quot;: source_id = sys.argv[1] aim_id=sys.argv[2] money=sys.argv[3] conn = MySQLdb.Connect(host=&apos;127.0.0.1&apos;,port=3306,user=&apos;root&apos;,passwd=&apos;root&apos;, db=&apos;test&apos;, charset=&apos;utf8&apos; ) trans = TransMoney(conn) try: trans.changeMoney(source_id,aim_id,money) except Exception as e: print &apos;出现问题&apos;+str(e) finally: conn.close()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch入门]]></title>
    <url>%2Fes-introductory-learning.html</url>
    <content type="text"><![CDATA[ES 简介什么是ElasticSearch 基于Apache Lucene 构建的开源搜索引擎 采用java编写，提供简单易用的Restful API 轻松的横向扩展，可支持PB级的结构化或非结构化数据处理 应用场景 海量数据分析 站内搜索引擎 数据仓库 环境要求 IDE工具：IDEA、Eclipse等。 Java JDK1.8 其他依赖 Maven、NodeJs(6.0以上) 基础概念 索引：含有相同属性的文档集合 类型：索引可以定义一个或多个类型，文档必须属于一个类型 文档：文档是可以被索引的基本数据单位 分片：每个索引都有多个分片，每个分片都是一个Lucene索引 备份：拷贝一份分片就完成了分片的备份 重点 ES的响应是json格式，可读性不是很好，最好再安装一个插件，首推head； rest提供了很好的restful api，问题是，这些都需要去记忆； rest的查询功能很强大，前提是需要学习requestBody json的写法，以及记住一些标准字段key，才会被ES解析，进而查询给出结果； 还有ES用于查询的话，关键字怎么定义，分词做么做，很核心 基本用法ES 的 API 属性结构 是以 RESTFul API 风格来命名自己的 API 的。 API 基本格式：http://:/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt; 常用 HTTP 动词：GET/PUT/POST/DELETE 索引的创建 结构化索引的创建 非结构化索引的创建 插入通过使用 put 方法向ES发送请求，以json格式的形式传入数据。 指定文档 id 插入 自动产生文档 id 插入 修改 直接修改文档 脚本修改文档通过 post 方法， api 格式：http://:/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt;/_update 删除 删除文档 删除索引 通过 delete 方法，api 格式：http://:/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt;，这样就删除了一个文档。 通过 delete 方法，http://:/&lt;索引&gt;， 这样就删除了一个索引，还可以在head 里通过图形化界面删除。 查询 通过 get 方法， api 格式：http://:/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt; 条件查询: 通过 post 方法， api 格式：http://:/&lt;索引&gt;/_search 1234567891011121314151617&#123; "query":&#123; // 匹配所有// "match_all":&#123;&#125;// 匹配条件 "match":&#123; "title":"Elastic" &#125; &#125;, "sort":[ &#123;"publish_date":&#123;"order":"desc"&#125;&#125; ], // 从哪里返回 "from":1, // 返回几条数据 "size":4&#125; 聚合查询 1234567891011121314&#123; "aggs":&#123; "group_by_word_count":&#123; "terms":&#123; "field":"word_count" &#125; &#125;, "group_by_publish_date":&#123; "terms":&#123; "field":"publish_date" &#125; &#125; &#125;&#125; 高级查询自条件查询 特定字段查询所指特定值 Query context常用查询： 全文本查询：针对文本类型数据关键词：match,match_phrase,multi_match,query_string 字段级别查询：针对结构化数据，如数字、日期等关键词：query,term,range Filter context 在查询过程中，只判断该文档是否满足条件，只有 Yes 和 No. 复合条件查询 以一定逻辑组合自条件查询常用查询 固定分数查询 123456789101112&#123; "query":&#123; "constant_score":&#123; "filter":&#123; "match":&#123; "title":"ElasticSearch" &#125; &#125;, "boost":2 &#125; &#125;&#125; 布尔查询 { "query":{ "bool":{ // must 必须满足 与 "should":[ // 或 { "match":{ "author":"aaaa" } }, { "mathc":{ "title":"ElasticSearch" } } ] } } } Spring Boot 集成 Es spring-boot-elasticsearch 包含增删改查以及复合查询的实例。 Reference: 慕课网－ElasticSearch入门]]></content>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 进阶篇[转]]]></title>
    <url>%2Fcss-advanced.html</url>
    <content type="text"><![CDATA[一、CSS2 高阶知识（常用）1. css 优先权优先权（从低到高）1234浏览器缺省设置外部样式表内部样式表（位于 &lt;head&gt; 标签内部）内联样式（在 HTML 元素内部） 因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明： 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。 2. 背景定位（background-position） 可以利用 background-position 属性改变图像在背景中的位置。123456body &#123; background-image:url('/img/bg_03.png'); background-repeat:no-repeat; background-position:50px 100px; &#125; 3. 缩进文本 （text-indent）把 Web 页面上的段落的第一行缩进，这是一种最常用的文本格式化效果。CSS 提供了 text-indent 属性，该属性可以方便地实现文本缩进。1p &#123;text-indent: 5em;&#125; 同时也可用做文本信息隐藏（-99999px） 4. 字（单词）间隔 （word-spacing）1p.spread &#123;word-spacing: 30px;&#125; 5. 字母间隔（letter-spacing）1h1 &#123;letter-spacing: -2px;&#125; 6. 字符大小写转换（text-transform）none（默认无操作） uppercase（全大写） lowercase（全小写） capitalize（首字母大写） 1h1 &#123;text-transform: uppercase;&#125; 7. 处理空白符（white-space）1. 值 nowrap（防止元素中的文本换行）1p&#123;white-space: nowrap;&#125; 2. 单行文本溢出显示 …（text-overflow）12345span &#123; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125; 8. table 表格（border-collapse 单一边框）border-collapse 属性设置是否将表格边框折叠为单一边框：1234567table&#123; border-collapse:collapse;&#125;table,th, td&#123; border: 1px solid black;&#125; 9. 选择子元素（&gt;）如果您不希望选择任意的后代元素，而是希望缩小范围，只选择某个元素的子元素，请使用子元素选择器（Child selector）。例如，如果您希望选择只作为 h1 元素子元素的 strong 元素，可以这样写：1h1 &gt; strong &#123;color:red;&#125; 这个规则会把第一个 h1 下面的两个 strong 元素变为红色，但是第二个 h1 中的 strong 不受影响：12&lt;h1&gt;This is &lt;strong&gt;very&lt;/strong&gt; &lt;strong&gt;very&lt;/strong&gt; important.&lt;/h1&gt;&lt;h1&gt;This is &lt;em&gt;really &lt;strong&gt;very&lt;/strong&gt;&lt;/em&gt; important.&lt;/h1&gt; 10. 选择相邻兄弟 （＋）如果需要选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器（Adjacent sibling selector）。例如，如果要增加紧接在 h1 元素后出现的段落的上边距，可以这样写：1h1 + p &#123;margin-top:50px;&#125; 11. 伪类 (Pseudo-classes)CSS 伪类用于向某些选择器添加特殊的效果。 1. 锚伪类在支持 CSS 的浏览器中，链接的不同状态都可以不同的方式显示，这些状态包括：活动状态，已被访问状态，未被访问状态，和鼠标悬停状态。 a:link {color: #FF0000} /* 未访问的链接 */ a:visited {color: #00FF00} /* 已访问的链接 */ a:hover {color: #FF00FF} /* 鼠标移动到链接上 */ a:active {color: #0000FF} /* 选定的链接 */ 2. CSS2 - :first-child 伪类（第一个子元素）可以使用 :first-child 伪类来选择元素的第一个子元素。 12345678&lt;style type="text/css"&gt;p:first-child&#123; font-weight:bold&#125;&lt;/style&gt;&lt;p&gt;I am a &lt;em&gt;strong&lt;/em&gt; man. I am a &lt;em&gt;strong&lt;/em&gt; man.&lt;/p&gt;&lt;p&gt;I am a &lt;em&gt;strong&lt;/em&gt; man. I am a &lt;em&gt;strong&lt;/em&gt; man.&lt;/p&gt; 3. :first-line 伪元素（首行）“first-line” 伪元素用于向文本的首行设置特殊样式。1234p:first-line&#123; color:#ff0000; font-variant:small-caps;&#125; “first-line” 伪元素只能用于块级元素。 4. :first-letter 伪元素（首字母）“first-letter” 伪元素用于向文本的首字母设置特殊样式：1234p:first-letter &#123; color:#ff0000; font-size:xx-large;&#125; 5. CSS2 - :before 伪元素“:before” 伪元素可以在元素的内容前面插入新内容。123h1:before &#123; content:url(logo.gif);&#125; 6. CSS2 - :after 伪元素“:after” 伪元素可以在元素的内容之后插入新内容。123h1:after &#123; content:url(logo.gif);&#125; 12. 使用 margin 属性来水平对齐可通过将左和右外边距设置为 “auto”，来对齐块元素。123456.center &#123; margin-left:auto; margin-right:auto; width:70%; background-color:#b0e0e6;&#125; 13. 改变光标 （cursor:pointer）1234span.pointer &#123;cursor:pointer;&#125;span.crosshair &#123;cursor:crosshair;&#125;span.help &#123;cursor:help;&#125;span.wait &#123;cursor:wait;&#125; 14. 透明度 （opacity）定义透明效果的 CSS3 属性是 opacity。1234img&#123; opacity:0.4; filter:alpha(opacity=40); /* 针对 IE8 以及更早的版本 */&#125; IE9, Firefox, Chrome, Opera 和 Safari 使用属性 opacity 来设定透明度。opacity 属性能够设置的值从 0.0 到 1.0。值越小，越透明。IE8 以及更早的版本使用滤镜 filter:alpha(opacity=x)。x 能够取的值从 0 到 100。值越小，越透明。 15. 颜色透明（RGBA）1background: rgba(0, 0, 0, 0.6) ; 二、CSS3 新特性CSS3 标准W3C 仍然在对 CSS3 规范进行开发。不过，现代浏览器已经实现了相当多的 CSS3 属性。 １. CSS3 圆角边框（border-radius）123456div&#123; text-align:center; border:2px solid #a1a1a1; border-radius:25px; -moz-border-radius:25px; /* 老的 Firefox */&#125; 2. CSS3 边框阴影（box-shadow）语法：box-shadow: h-shadow v-shadow blur spread color inset;1234567div&#123; width:300px; height:100px; background-color:#ff9900; -moz-box-shadow: 10px 10px 5px #888888; /* 老的 Firefox */ box-shadow: 10px 10px 5px #888888;&#125; 3. CSS3 文本阴影（text-shadow）您能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色：123h1&#123; text-shadow: 5px 5px 5px #FF0000;&#125; 4. CSS3 自动换行（word-wrap）在 CSS3 中，word-wrap 属性允许您允许文本强制文本进行换行 - 即使这意味着会对单词进行拆分。允许对长单词进行拆分，并换行到下一行：1p &#123;word-wrap:break-word;&#125; 5. CSS3 字体（@font-face）使用您需要的字体在新的 @font-face 规则中，您必须首先定义字体的名称（比如 myFirstFont），然后指向该字体文件。如需为 HTML 元素使用字体，请通过 font-family 属性来引用字体的名称 (myFirstFont)：123456789@font-face &#123; font-family: myFirstFont; src: url('Sansation_Light.ttf'), url('Sansation_Light.eot'); /* IE9+ */&#125;div &#123; font-family:myFirstFont;&#125; 6. CSS3 2D 转换Internet Explorer 10、Firefox 以及 Opera 支持 transform 属性。Chrome 和 Safari 需要前缀 -webkit-。注释：Internet Explorer 9 需要前缀 -ms-。 通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。 1. translate()方法 （位置移动）通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数：1234567div &#123; transform: translate(50px,100px); -ms-transform: translate(50px,100px); /* IE 9 */ -webkit-transform: translate(50px,100px); /* Safari and Chrome */ -o-transform: translate(50px,100px); /* Opera */ -moz-transform: translate(50px,100px); /* Firefox */&#125; 2. rotate()方法（顺时针旋转角度）通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。1234567div &#123; transform: rotate(30deg); -ms-transform: rotate(30deg); /* IE 9 */ -webkit-transform: rotate(30deg); /* Safari and Chrome */ -o-transform: rotate(30deg); /* Opera */ -moz-transform: rotate(30deg); /* Firefox */&#125; 3. scale() 方法（改变尺寸）通过 scale() 方法，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数：1234567div &#123; transform: scale(2,4); -ms-transform: scale(2,4); /* IE 9 */ -webkit-transform: scale(2,4); /* Safari 和 Chrome */ -o-transform: scale(2,4); /* Opera */ -moz-transform: scale(2,4); /* Firefox */&#125; 值 scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。 4. skew() 方法（元素翻转角度）通过 skew() 方法，元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数：1234567div &#123; transform: skew(30deg,20deg); -ms-transform: skew(30deg,20deg); /* IE 9 */ -webkit-transform: skew(30deg,20deg); /* Safari and Chrome */ -o-transform: skew(30deg,20deg); /* Opera */ -moz-transform: skew(30deg,20deg); /* Firefox */&#125; 值 skew(30deg,20deg) 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。 5. matrix() 方法（2D 转换方法组合）matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。 7. CSS3 3D 转换Internet Explorer 10 和 Firefox 支持 3D 转换。Chrome 和 Safari 需要前缀 -webkit-。Opera 仍然不支持 3D 转换（它只支持 2D 转换）。 1. rotateX() 方法（X 轴旋转）通过 rotateX() 方法，元素围绕其 X 轴以给定的度数进行旋转。12345div &#123; transform: rotateX(120deg); -webkit-transform: rotateX(120deg); /* Safari 和 Chrome */ -moz-transform: rotateX(120deg); /* Firefox */&#125; 2. rotateY() 方法（Y 轴旋转）通过 rotateY() 方法，元素围绕其 Y 轴以给定的度数进行旋转。12345div &#123; transform: rotateY(130deg); -webkit-transform: rotateY(130deg); /* Safari 和 Chrome */ -moz-transform: rotateY(130deg); /* Firefox */&#125; 8. CSS3 过渡（transition）CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。 1. transition: width应用于宽度属性的过渡效果，时长为 2 秒：12345678910div &#123; transition: width 2s; -moz-transition: width 2s; /* Firefox 4 */ -webkit-transition: width 2s; /* Safari 和 Chrome */ -o-transition: width 2s; /* Opera */&#125;div:hover &#123; width:300px;&#125; 2. width 2s, height 2s, transform 2s（多项改变）如需向多个样式添加过渡效果，请添加多个属性，由逗号隔开：123456div &#123; transition: width 2s, height 2s, transform 2s; -moz-transition: width 2s, height 2s, -moz-transform 2s; -webkit-transition: width 2s, height 2s, -webkit-transform 2s; -o-transition: width 2s, height 2s,-o-transform 2s;&#125; 所有的转换属性|属性|描述|CSS||—|:—|:—||transition|简写属性，用于在一个属性中设置四个过渡属性。 |3||transition-property|规定应用过渡的 CSS 属性的名称。 |3||transition-duration|定义过渡效果花费的时间。默认是 0。|3||transition-timing-function|规定过渡效果的时间曲线。默认是 “ease”。 |3||transition-delay|规定过渡效果何时开始。默认是 0。|3| 3. 使用所有过渡属性123456789101112131415161718192021div&#123; transition-property: width; transition-duration: 1s; transition-timing-function: linear; transition-delay: 2s; /* Firefox 4 */ -moz-transition-property:width; -moz-transition-duration:1s; -moz-transition-timing-function:linear; -moz-transition-delay:2s; /* Safari 和 Chrome */ -webkit-transition-property:width; -webkit-transition-duration:1s; -webkit-transition-timing-function:linear; -webkit-transition-delay:2s; /* Opera */ -o-transition-property:width; -o-transition-duration:1s; -o-transition-timing-function:linear; -o-transition-delay:2s;&#125; 4. 简写的 transition （property，duration，timing-function，delay）属性的名称，花费的时间，时间曲线，何时开始123456789div &#123; transition: width 1s ease 2s; /* Firefox 4 */ -moz-transition:width 1s ease 2s; /* Safari and Chrome */ -webkit-transition:width 1s ease 2s; /* Opera */ -o-transition:width 1s ease 2s;&#125; 9. CSS3 动画通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。 CSS3 @keyframes 规则如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。 1. 关键字 “from”“to”12345678910111213141516171819@keyframes myfirst&#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125;&#125;/* Firefox */@-moz-keyframes myfirst &#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125;&#125;/* Safari 和 Chrome */@-webkit-keyframes myfirst &#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125;&#125;/* Opera */@-o-keyframes myfirst &#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125;&#125; 通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器： 1. 规定动画的名称 2. 规定动画的时长 把 “myfirst” 动画捆绑到 div 元素，时长：5 秒：123456div &#123; animation: myfirst 5s; -moz-animation: myfirst 5s; /* Firefox */ -webkit-animation: myfirst 5s; /* Safari 和 Chrome */ -o-animation: myfirst 5s; /* Opera */&#125; 2. 0% 和 100% 选择器必须定义动画的名称和时长。如果忽略时长，则动画不会允许，因为默认值是 0。您可以改变任意多的样式任意多的次数。请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。0% 是动画的开始，100% 是动画的完成。为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。 例：当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变：123456789101112131415161718192021222324252627@keyframes myfirst &#123; 0% &#123;background: red;&#125; 25% &#123;background: yellow;&#125; 50% &#123;background: blue;&#125; 100% &#123;background: green;&#125;&#125;/* Firefox */@-moz-keyframes myfirst &#123; 0% &#123;background: red;&#125; 25% &#123;background: yellow;&#125; 50% &#123;background: blue;&#125; 100% &#123;background: green;&#125;&#125;/* Safari 和 Chrome */@-webkit-keyframes myfirst &#123; 0% &#123;background: red;&#125; 25% &#123;background: yellow;&#125; 50% &#123;background: blue;&#125; 100% &#123;background: green;&#125;&#125;/* Opera */@-o-keyframes myfirst &#123; 0% &#123;background: red;&#125; 25% &#123;background: yellow;&#125; 50% &#123;background: blue;&#125; 100% &#123;background: green;&#125;&#125; 3. 改变背景色和位置：1234567@keyframes myfirst&#123; 0% &#123;background: red; left:0px; top:0px;&#125; 25% &#123;background: yellow; left:200px; top:0px;&#125; 50% &#123;background: blue; left:200px; top:200px;&#125; 75% &#123;background: green; left:0px; top:200px;&#125; 100% &#123;background: red; left:0px; top:0px;&#125;&#125; 下面的表格列出了 @keyframes 规则和所有动画属性： 属性 描述 CSS @keyframes 规定动画。 3 animation 所有动画属性的简写属性，除了 animation-play-state 属性。 3 animation-name 规定 @keyframes 动画的名称。 3 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 3 animation-timing-function 规定动画的速度曲线。默认是 “ease”。 3 animation-delay 规定动画何时开始。默认是 0。 3 animation-iteration-count 规定动画被播放的次数。默认是 1。 3 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 3 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 3 animation-fill-mode 规定对象动画时间之外的状态。 3 4. 使用所有动画属性12345678910div&#123; animation-name: myfirst; animation-duration: 5s; animation-timing-function: linear; animation-delay: 2s; animation-iteration-count: infinite; animation-direction: alternate; animation-play-state: running; 浏览器兼容代码省略...&#125; 5. 使用简写的动画 animation 属性动画的名称,一个周期所花费的秒,速度曲线,何时开始,播放的次数123456789div&#123; animation: myfirst 5s linear 2s infinite alternate; /* Firefox: */ -moz-animation: myfirst 5s linear 2s infinite alternate; /* Safari 和 Chrome: */ -webkit-animation: myfirst 5s linear 2s infinite alternate; /* Opera: */ -o-animation: myfirst 5s linear 2s infinite alternate;&#125; 10. CSS3 多列通过 CSS3，您能够创建多个列来对文本进行布局 - 就像报纸那样！ 1. CSS3 创建多列（column-count）把 div 元素中的文本分隔为三列：12345div&#123; -moz-column-count:3; /* Firefox */ -webkit-column-count:3; /* Safari 和 Chrome */ column-count:3;&#125; 2. CSS3 规定列之间的间隔（column-gap）规定列之间 40 像素的间隔：12345div&#123; -moz-column-gap:40px; /* Firefox */ -webkit-column-gap:40px; /* Safari 和 Chrome */ column-gap:40px;&#125; 3. CSS3 列规则（column-rule）规定列之间的宽度、样式和颜色规则：12345div&#123; -moz-column-rule:3px outset #ff0000; /* Firefox */ -webkit-column-rule:3px outset #ff0000; /* Safari and Chrome */ column-rule:3px outset #ff0000;&#125; 11. CSS3 用户界面在 CSS3 中，新的用户界面特性包括重设元素尺寸、盒尺寸以及轮廓等。 1. CSS3 Resizing（可调整大小）规定 div 元素可由用户调整大小：1234div&#123; resize:both; overflow:auto;&#125; 2. CSS3 Box Sizingbox-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。border 或 padding的数值计入父宽高内（意思为不会增加父容器宽度）。 规定两个并排的带边框方框：1234567div&#123; box-sizing:border-box; -moz-box-sizing:border-box; /* Firefox */ -webkit-box-sizing:border-box; /* Safari */ width:50%; float:left;&#125; 3. CSS3 Outline Offsetoutline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。 规定边框边缘之外 15 像素处的轮廓：12345div&#123; border:2px solid black; outline:2px solid red; outline-offset:15px;&#125; 三、编写 CSS 注意事项1. 修饰选择器（尽量少用）能写.nav{}就尽量不要写ul.nav{}。过分修饰选择器将影响性能，影响 class 复用性，会增加选择器私有度。这些都应当竭力避免的。如果想描述我们规划的 class 作用范围，可以在选择器前加上注释，如下写法：12/*ul*/.nav&#123;&#125; 这样我们就能在不影响代码私有度的前提下获知 class 作用范围。 2. 布局（宽度和高度）所有内部组件都不要声明宽度，而由其外层父容器块（格栅系统）来决定。理想情况下，格栅系统应当用百分比设定。坚决不要声明高度。高度应当仅用于尺寸已经固定的东西，例如图片。在 p，ul，div 等元素上不应当声明高度。如果需要的话可以写 line-height，这个更加灵活。。 3. 简写（谨慎使用）编写像1background:red; 这样的属性的确很省事，但是你这么写的意思其实是同时声明1234background-image:none;background-position:top left;background-repeat: repeat;background-color:red; 最优应当改为1background-color:red; 类似的，像 margin:0; 这样的声明的确简洁清爽，但是还是应当尽量写清楚。如果你只是想修改底边边距，就要具体一些，写成 margin-bottom:0;。简写虽然是好东西，但是注意切勿滥用。 4. ID（CSS 里坚决不要用 ID）在 HTML 里 ID 可以用于 JS 以及锚点定位，但是在 CSS 里只要用 class，一个 ID 也不要用。 Class 的优势在于复用性，而且私有度也并不高。私有度非常容易导致问题，所以将其降低就尤为重要。ID 的私有度是 class 的 255 倍，所以在 CSS 中坚决不要使用。 5. 选择器（保持选择器简短高效） 结构复杂的选择器将会影响性能。（如.sidebar h3 span{}为三层，.content ul p a{}是四层），层级越深浏览器的消耗就越大。选择器应当尽量简短，更好的办法是直接给你想要添加样式的元素直接添加一个 class。 class 名则不应当过于简略，例如.user-avatar就远比 .usr-avt 好。 6. !important（优先级高，一般情况不要用）用 !important 提升优先级也可以，例如如果你要让某条规则一直生效的话，可以用 .error{ color:red !important; }。 避免主动使用 !important。例如 CSS 写得很复杂时不要用它来取巧，要好好整理并重构之前的部分，保持选择器简短并且避免用 ID 将效果拔群。 7. 魔数与绝对定位（「凑巧有效果」的数字）魔数（Magic Number）是指那些「凑巧有效果」的数字，这东西非常不好，缺乏拓展性。例如 .dropdown-nav li:hover ul{ top:37px; } 把下拉菜单移动下来，远非良策，因为这里的 37px 就是个魔数。37px 会生效的原因是因为这时 .dropbox-nav 碰巧高 37px 而已。 这时你应该用 .dropdown-nav li:hover ul{ top:100%; }，也即无论 .dropbox-down 多高，这个下拉菜单都会往下移动 100%。每当你要在代码中放入数字的时候，请三思而行。 8. Debugging（调试）如果你要解决 CSS 问题的话，先把旧代码拿掉再写新的。如果旧的 CSS 中有问题的话，写新代码是解决不了的。把 CSS 代码和 HTML 部分删掉，直到没有 BUG 为止，然后你就知道问题出在哪里了。有时候写上一个 overflow:hidden 或者其它能把问题藏起来的代码的确效果立竿见影，但是 overflow 方面可能根本就没问题。所以要治本，而不是单纯治标。 Reference: 中国风2012——CSS 进阶篇]]></content>
      <tags>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 触发器]]></title>
    <url>%2Foracle-trigger.html</url>
    <content type="text"><![CDATA[触发器相关概念及语法触发器概述什么是触发器 触发器是一种特殊的存储过程，和存储过程和存储函数一样是一个pl/sql程序块，触发器是不能接受参数，不能显示调用，只是随着事件触发隐式运行的存储过程程序块。 触发器的应用场景 复杂的安全性检查 数据确认 实现审计功能 完成数据的备份和同步 触发器概念和第一个触发器概念 数据库触发器是一个与表相关联的，存储的PL/SQL程序，每当一个特定的数据库操作语句（insert ，update，delete）在指定的表上发出时，Oracle自动地执行触发器中定义得语句序列。 第一个触发器123456789-- 第一个触发器：每当成功插入新员工后，自动打印“成功插入新员工”-- 触发器单词：triggercreate trigger saynewem -- 创建触发器名称after insert -- 在插入操作以后on emp -- 针对emp的表declare -- 操作体begin dbms_output.put_line(&apos;成功插入新员工&apos;); -- 触发器操作的内容 end; 触发器的应用场景 复杂的安全性的场景(涉及到权限的问题)； 数据的确认(涉及数据是否合理问题)； 数据的审计(涉及到数据的增、删、改的操作记录)； 数据的备份和同步(备份和同步重要); 触发器的语法123456create[or replace] trigger 触发器名&#123;before|after&#125;&#123;delete|insert|update[of 列名]&#125;on 表名[for each row [when(条件)]] (有这条语句的话就是行级触发器,否则就是语句级触发器)PLSQL 块 触发器的类型语句级触发器 在指定的操作语句操作之前或之后执行一次，不管这条语句影响了多少行。(针对的是表，触发最多一次) 行级触发器 触发语句作用的每一条记录都被触发。在行级触发器中使用 :old 和 :new 伪记录变量，识别值的状态。(针对的是行，触发器触发次数不一样，有多少行满足条件就触发多少次) 触发器应用应用一——复杂的安全性检查1234567891011121314151617-- 例如禁止在非工作时间插入数据/** 1.周末： to_char(sysdate,&apos;day&apos;) in (&apos;星期六&apos;，‘星期日’) 2.上班前，下班后： to_number(to_char(sysdate,&apos;hh24&apos;)) not between 9 and 18/create or replace trigger securityempbefore insert on emp begin if to_char(sysdate,&apos;day&apos;) in (&apos;星期六&apos;, &apos;星期日&apos;) or to_number(to_char(sysdate,&apos;hh24&apos;)) not between 9 and 18 then raise_application_error(-20001,&apos;禁止在非工作时间插入新员工&apos;); end if;end;/ 应用二——数据确认1234567891011121314151617-- 涨工资不能越涨越少/** * :old 和 :new 代表同一条记录 * :old 表示操作该行之前，这一行的值 * :new 表示操作该行值后，这一行的值 */create or replace trigger check_salarybefore update on empfor each rowbegin if :new.sal&lt;:odl.sal thenraise_application_error(-20002,&apos;涨后薪水不能少于涨前薪水。 涨后薪水为：&apos;||:new.sal ||&apos;涨前的薪水：&apos;||:old.sal);end if;end; 应用三——实现审计功能12345678910111213141516-- 给员工涨工资，当涨后的薪水超过6000块时候，审计该员工的信息-- 创建表，用于保存审计信息create table audit_info(information varchar2(200));create or replace trigger do_audit_emp_salaryafter update on empfor each row begin if :new.sal&gt;6000 then insert into audit_info values(:new.empno||&apos; &apos;||:new.ename||&apos; &apos;||:new.sal);end if;end; 应用四——完成数据的备份和同步12345678910111213-- 创建备份表create table emp_back as select * from emp;-- 利用触发器实现数据的同步部分-- 当给员工涨完工资后，自动备份新的工资到备份表中create or replace trigger sync_salaryafter update on empfor each row begin -- 当主表更新后，自动更新备份表 update emp_back set sal=:new.sal where empno=:new.empno; end;/ Reference: 慕课网－oracle 触发器]]></content>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle存储过程和自定义函数]]></title>
    <url>%2Foracle-procedure-function.html</url>
    <content type="text"><![CDATA[概述 存储过程和存储函数是指存储在数据库中供所有用户程序调用的子程序叫存储过程、存储函数。 异同点： 存储过程和存储函数的相同点：完成特定功能的程序。 存储过程和存储函数的区别：是否用return语句返回值。 存储过程的创建和调用第一个存储过程：打印 hello world1234567create or replace procedure sayhellowordas -- 说明部分,as一定要写begin dbms_output.put_line(&apos;Hello World&apos;);end;/ 调用存储过程 exec sayhelloworld() 123456-- 调用两次begin sayhelloworld(); sayhelloworld();end;/ oracle 带参数的存储过程1234567891011121314151617181920212223-- 创建一个带参数的存储过程-- 给指定的员工涨100块钱的工资，并且打印涨前后涨后的薪水create or replace procedure raisesalary(eno in number) -- in 这是一个输入参数as -- 定义一个变量保存涨前的薪水 psal emp.sal%type;begin -- 得到员工涨前的薪水 select sal into psal from emp where empno=eno; -- 给该员工涨100块钱 update emp set sal=sal+100 where empno=eno; -- 一般，这里不需要 commit ！ 也不需要 rollback -- 注意：一般不在存储过程或者存储函数中，commit 和 rollback -- 打印 dbms_output.put_line(&apos;涨前：&apos;||psal||&apos;，涨后：&apos;||(psal+100));end;/-- 调用：begin raisesalary(7839); raisesalary(7566); end;/ 如何调试存储过程 调试存储过程最好放到Oracle数据库所在的系统或虚拟机上，解压SQL developer ，双击运行。 为了确保存储过程或函数是可调试的，右键“以编译并进行调试”，点击红色按钮“调试” 利用已写好的调用函数进行调试。 给调试账户授权1grant DEBUG CONNECT SESSION ,DEBUG ANY PROCEDURE to scott; 存储函数函数的定义 是一个命名的存储程序，可带参数，并返回一个计算值。必须有return 子句，用于返回函数值。 创建存储函数语法123456create or replace function 函数名(参数列表)return 函数值类型asbegin PLSQL子程序体;end; 注意 表达式中某个字段为空时，表达式返回值为空。为防止含有表达式的返回值错误，在可能为空的字段上加上NVL(字段名，0)。12345678910111213--查询某个员工的年收入create or replace function queryemp_income(eno in number)return numberas --定义变量接收薪水和奖金 p_sal emp.sal%type; p_comm emp.comm%type;begin select sal,comm into p_sal,p_comm from emp where empno=eno; --nvl为遇空函数，如果p_comm为空则返回0 return nvl(p_comm,0)+p_sal*12;end;/ out 参数 存储过程和存储函数都可以有多个输入（in）和输出参数（out），都可以通过out参数实现返回多个值。12345678910-- out参数：查询某个员工姓名、月薪和职位-- 原则： 如果只有一个返回值，用存储函数；否则，就用存储过程。create or replace procedure queryempinfor(eno in number,pename out varchar2, psal out number,pjob out varchar2)as begin -- 得到该员工的姓名、月薪和职位 select ename,sal,empjob into pename,psal,pjob from emp where empno=eno;end;/ 在 out 参数中访问光标申明包结构 包头(申明) 包体(实现) 案例123456789101112131415-- 查询某个部门中所有员工的所有信息 //ref(reference引用) cursor(光标)#包头create or replace package mypackage astype empcursor is ref cursor;procedure queryEmpList(dno in number,empList out empcursor);end mypackage;#包体create or replace package body mypackage asprocedure queryEmpList(dno in number,empList out empcursor) as begin open empList for select * from emp where deptno=dno; end queryEmpList;end mypackage;***********包体需要实现包头中声明的所有方法********************* 在应用程序中访问 在java应用程序中访问存储过程和存储函数以及访问包下的存储过程，可以查看java API文档。 Reference: 慕课网－oracle 存储过程和自定义函数]]></content>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射]]></title>
    <url>%2Fjava-reflect.html</url>
    <content type="text"><![CDATA[Class 类的使用在面向对象的世界里，万事万物皆对象。(静态成员、普通数据类型) 类是对象，类是java.lang.Class类的实例对象 这个对象的表示方式有三种： 第一种表示方式： 1Class c1 = Foo.class; //任何一个类都有一个隐含的静态成员变量class 第二种表示方式： 1Class c2 = foo1.getClass //已知该类的对象，通过getClass方法得到这个实例类的class(类类型) 第三种表达方式 1Class c3 = Class.forName(&quot;imooc.reflect.Foo&quot;); 三种方式创建的类类型都相等，都是Foo的类类型 可以通过类类型创建该类的类对象1Foo foo=(Foo)c1.newInstance(); 前提是需要有无参数的构造方法，它要调用 动态加载类1Class.forName(&quot;类的全称&quot;)： 不仅表示了类的类类型，还代表了动态加载类 请区分编译、运行 编译时刻加载类是静态加载类、运行时刻加载类是动态加载类 用new创建对象，属于静态加载类，在编译时刻就需要加载所有的可能使用到的类，只要有一个类缺失或者类中某个成员缺失，就会报错（不管实际上有没有用到这个类），导致整个程序都无法运行。 于是我们希望：要用哪个类的时候再加载这个类，不用就不加载。通过动态加载类可以解决上述问题。本例中举了Word类、Excel类加载的例子，现在做动态加载：123456789Class c = Class.forName(args[0]);//通过类类型，创建该类对象，这里就产生一个问题：是生成Word呢还是生成Excel?老师的解决思路是：只创建一个新类OfficeAble，作为接口，令Word类、Excel类都实现这个接口就可以了：OfficeAble oa = (OfficeAble)c.newInstance();oa.start();class Word implements OfficeAble&#123; public void start()&#123;&#125;&#125; 代码设计思路：功能性的类最好使用动态加载。12Class c = Class.forname(参数);//动态加载类返回该类的类类型。接口 x = (接口)c.newInstance();通过转换为接口的类型，用来实现方法。 获取方法信息基本数据类型，void关键字都存在类类型 class.getMethods()方法获取是该类的所有public方法，包括从父类继承的方法； class.getDeclareMethods()方法获取该类自行声明的所有方法，不论访问权限； method.getName()获取方法名 method.getReturnType()获取方法的返回值 method.getParameterTypes()，获取方法的参数类型的类类型数组class[] 获取方法信息： 基本的数据类型，void关键字等都存在类类型Class c = 基类.class （int,String,double,void等） Class类的基本API操作 c.getName()可以获取类的名称 c.getSimpleName();//不包含包名的类的名称 c.getMethods()获取类的【public方法】集合，【包括继承来的】注意【所有方法都是Method类的对象】 c.getDeclaredMethods()获取的是所有该类【自己声明】的方法，【不问访问权限】 Method类提供了一些操作方法的方法 .getReturnType()得到该方法的返回值类型的类类型（class），如int.class String.class .getName()得到方法的名称 .getParameterTypes()获得参数列表类型的类类型，如参数为(int,int)则得到 实例123456789Class c1 = int.class; int的类类型Class c2 = String.class; String类的类类型 String类字节码Class c3 = double.class; double这个数据类类型的字节码表示方式Class c4 = Double.class; Double这个类的类类型字节码表示方式Class c5 = void.class; 表达了void这个类的类类型getName为这个类的类类型的具体名称 c1.getName ---&gt; intc2.getName ---&gt; java.lang.String 类的全称c2.getSimpleName ---&gt; String 不包含包名的类的名称 获取成员变量构造函数信息Java反射机制－获取成员变量&amp;构造函数 成员变量是java.lang.reflect.Field的对象 Field类封装了关于成员变量的操作 Field[] fs = c.getFields()方法获取所有public的成员变量Field[]信息 c.getDeclaredFields获取的是该类自己声明的成员变量信息 field.getType()获得成员类型的类类型 field.getName()获得成员的名称 构造函数是java.lang.Constructor类的对象 通过Class.getConstructor()获得Constructor[]所有公有构造方法信息 建议getDeclaredConstructors()获取自己声明的构造方法 Constructor.getName():String Constructor.getParameterTypes():Class[] 成员变量也是对象，是java.lang.reflect.Field的对象 反射——获取成员变量的信息 Class c = obj.getClass();Field[] fs = c.getFields(); 获取成员变量： 获取成员变量的类型的类类型Class fieldType = field.getType(); //获取成员变量的类型的名字fieldType.getName(); //获取成员变量的名称getName() 反射——获取构造函数的信息 Class c = obj.getClass(）;Constructor[] cs = c.getConstructors(); 获取构造函数的参数列表，得到的是参数列表的类型的类类型Class[] paramTypes =constructor.getParammeterTypes(); //获取参数类型的名称paramTypes.getName();方法反射的基本操作获取A类中的print(int,int)方法： 要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型A a1=new A(); Class c= a1.getClass(); 获取方法 由名称和参数列表来决定,getMethod获取的是public方法，getDelcaredMethod获取自己声明的方法Method m =c.getMethod(methodName,paramtypes); //paramtypes可以用数组的形式 表示new Class[]{int.class,int.class}，也可以直接列举类类型方法的反射操作：是用m对象来进行方法调用，和a1.print(10,20)调用的方法相同 m.invoke（a1，new Object[]｛10,20｝） Object o=m.invoke(对象名,参数);//方法如果没有返回值返回null，如果有返回值返回具体值，参数可用数组的方式表示，也可以直接列举，没有参数就不写123456789101112public Class A&#123; public void print()&#123;&#125;; public void Print(Sting a,String b)&#123;&#125; public void Print(int a,int b)&#123;&#125;;&#125; public Class B&#123; public static void main(String[] args)&#123; A a1 = new A(); Class c= a1.getclass; Method getMet=c.getMethod(&quot;print&quot;,String.class,String.class); Object obj=getMet.invoke(a1,&quot;df&quot;,&quot;df&quot;); &#125;&#125; 通过反射了解集合泛型的本质 反射的操作都是编译之后的操作 集合的泛型只为了防止错误输入，编译阶段有效，绕过编译，使用反射是不会控制集合中的数据类型的。 反射操作类方法：通过对象的类类型得到方法的对象Method，通过方法对象的invoke方法操作对象，调用对象的方法。实例123Class c1=对象a.getClass()Method m = c1.getMethod(方法名，参数列表)Object o =m.invoke(对象a，参数列表，可以一一列举，也可以用数组) Reference: IMOOC-反射——Java高级开发必须懂的]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeMarker解析json数据]]></title>
    <url>%2Ffreemark-analysis-json-string.html</url>
    <content type="text"><![CDATA[模拟后台传过来的 json 字符串text123&lt;#assign text&gt;&#123;&quot;res&quot;:&quot;0&quot;,&quot;msg&quot;:&quot;OK&quot;,&quot;userlist&quot;:[&#123;&quot;id&quot;:&quot;3&quot;,&quot;name&quot;:&quot;cc&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:&quot;20&quot;&#125;]&#125;&lt;/#assign&gt; 在 ftl 页面，将字符串当ftl代码看1&lt;#assign json=text?eval /&gt; 然后字符串就解析成 json 格式，可以按 key 进行取值12345&lt;#list json.userlist as item&gt;id:$&#123;item.id&#125;, name:$&#123;item.name&#125;,sex:$&#123;item.sex&#125;&lt;/#list&gt; Reference:o0自由的风0o-《FreeMarker处理json》]]></content>
      <tags>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-176. Second Highest Salary]]></title>
    <url>%2Fleetcode-second-height-salary.html</url>
    <content type="text"><![CDATA[Write a SQL query to get the second highest salary from the Employee table. 1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ For example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null.12345+---------------------+| SecondHighestSalary |+---------------------+| 200 |+---------------------+ 思路： 按薪水salary 倒序排序，然后从第一个开始，取下一个。 一开始我的SQL(Wrong Answer)1234 SELECT DISTINCT Salary as SecondHighestSalary FROM EmployeeORDER BY Salary DESC LIMIT 1 OFFSET 1 忽略了如果表中salary的值只有一种的情况，这样就没有the second highest salary，输出 null.正确写法：123456SELECT IFNULL( (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1), NULL) AS SecondHighestSalary IFNULL 这儿用到了 MySQL 的 IFNULL(expr1,expr2)函数，如果 expr1 不是 NULL，IFNULL() 返回 expr1，否则它返回 expr2。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当然我在扯淡]]></title>
    <url>%2Ftalk-nonsense.html</url>
    <content type="text"><![CDATA[你没法对别人解释北京。 2013年，那是我第一次离开西北。在去哈尔滨求学的途中路过北京，那时生活正在跃出一段崭新的弧线。我以为我知道我将要面对的所有可能性，并无丝毫畏惧。就像汪峰在《北京北京》中唱的那样： 在这儿我能感觉到我的存在在这儿有太多让我眷恋的东西我在这里欢笑我在这里哭泣我在这里活着也在这儿死去 “在这儿我能感觉到我的存在”。 17年顺利拿到学位证书后回到北京，在接下来的日子里，理想、情怀开始澎湃地展现在我眼前，高速公路上红色和黄色的车灯奔涌入海，驰掣的地跌裹挟这风尘带着些许机车的腥气，北京的灯火如星辰一般铺在脚下。这是梦和幻觉构筑的城市。 《北京北京》似乎是写给这座城市的情书。不论你有多洒脱，但你只要北漂过的话，就知道这里面的那些细节有多么微妙和真切。 这是我曾经昂首阔步走过的地方，这是我一直心心念念要来的地方，我不知道终将会发生什么事，而生活终将改弦更张，现实经历的任何生活转折，和我当时以为我要为之奋斗的那个未来和真实的未来近乎南辕北辙。 但生活并不止步于此，你知道没有什么 good ending 或者 bad ending，有的只是一个又一个选择，和伴随着每个选择而来的那个无可避免的 what if。那不是抽象的可能性，而是一段又一段具体而微的生活轨迹，是真实的家庭细节和职业道路，是餐厅里的烛光和欢声笑语，是无数个清晨的问候和午夜的叹息，是同样沦肌浃髓的血汗和泪水。它们永远消失在了命运的岔口里。 你永远都不知道这是否值得。 时常自己跟自己较劲，为什么要来北漂，风尘仆仆的上下班，我似乎又找不到存在的意义，也常常问change: 我的选择错误了吗？ 兜兜转转这么久了，我还是一无所有 change回复道： emm… 不会啊，你还有我啊 很暖心，很想哭，所以越发无力感，时间已经过去了很久，但又像是只在转瞬之间。兜兜转转的千百种人生汇聚于此刻，如梦幻泡影。每个选择都可能是种错误，每种未来都隐约活色生香。要搞砸那么多次，失望那么多次，才换来这进退失据的当下片刻。 就像宋冬野在《空港曲》中唱的： 脏水洗身 浊杯赴宴如来的饭碗 荒诞世间你我登船 送命或寻欢可信仰不过是忘记真相 但至少，你在那些岔口面前沉吟过，你曾经放手一搏地尝试过，致那些破碎了的心，和跌跌撞撞的生活。]]></content>
      <tags>
        <tag>Life-Talk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome 插件-汇集]]></title>
    <url>%2Fchrome-plug-collection.html</url>
    <content type="text"><![CDATA[这里收集一些很好用的chrome插件，会不断补充，欢迎大家补充。 Chrome 标签页美化 infinity-proChrome 新标签页应用,重绘了几百个图标,支持自定义搜索,集成天气,带有备忘与 Todo,还可以每日更换壁纸 开发DHC REST ClientREST &amp; HTTP API developer’s pocket knife. Easy to use and configurable. HATEOAS, Hypermedia, Requests History+Repository, and more.用于测试 http 请求等等 Page RulerDraw a ruler to get pixel dimensions and positioning, and measure elements on any web page.前端尺子 Eye DropperEye Dropper is open source extension which allows you to pick colors from web pages, color picker and your personal color history.拾色器，还可以保存颜色记录 Proxy SwitchyOmegaManage and switch between multiple proxies quickly &amp; easily.代理工具，很方便定义规则。我觉得可以接替 foxyproxy 产品Chrome 壁纸插件 Momentum如果可以翻墙，可以直接在chrome extension app store 下载 WappalyzerIdentifies software on the web分析网站技术栈 SimilarWebSee real in-depth website engagement, traffic sources, and site ranking information with SimilarWeb分析网站流量 效率Sexy Undo Close TabAccidentally closed your last tab? Tired of losing tabs in Incognito? Don’t worry, everything is possible with this sexy extension!恢复关闭的页面 Evernote Web ClipperUse the Evernote extension to save things you see on the web into your Evernote account.印象笔记 剪藏；用印象笔记肯定是要安装的插件 Personal Blocklist (by Google)在 Google 搜索结果了，自定义屏蔽网站，比如屏蔽：百度知道什么的]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 进程管理]]></title>
    <url>%2Flinux-process-manage.html</url>
    <content type="text"><![CDATA[一、 进程管理1. 什么是进程 进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的运行空间，并占有一定的系统资源。 2. 进程管理的作用 判断服务器健康状态 查看系统中所有进程 杀死进程 3. 进程的查看ps命令 ps aux 查看系统中所有进程，使用BSD操作系统格式 ps -le 查看系统中所有进程，使用Linux标准命令格式 选项 a：显示一个终端的所有进程，除了会话引线 u：显示进程的归属用户及内存使用情况 x：显示没有控制终端的进程 -l：长格式显示，显示更加详细的信息 -e：显示所有进程，和a作用一致 pstree [选项] 查看进程树 选项 -p：显示进程的pid -u：显示进程的所属用户 STAT：进程状态。常见的状态有： R：运行 S：睡眠 T：停止状态 s：包含子进程 +：位于后台 4. 进程的查看top命令 top [选项] 查看系统健康状态 选项 -d：秒数：指定top命令每隔几秒更新。默认是3秒 -b：使用批处理模式输出。一般和-n选项合用 -n：次数：指定top命令执行的次数 在top命令的交互模式中可以执行的命令： ?或h：显示交互模式的帮助 P：以CPU使用率排序，默认就是此项 M：以内存的使用率排序 N：以PID排序 q：退出top 使用top查看所有进程12// 将所有进程的情况输出到 top.log文本文档中top -b -n 1 &gt; top.log 5. 杀死进程 kill命令 杀死单一进程 kill -l：查看可用的进程信号 kill -1 4399：重启进程 kill -9 4399：强制杀死进程 killall命令 killall [选项][进程]进程名：按照进程名杀死进程 选项： -i：交互式，询问是否要杀死某个进程 -I：忽略进程名的大小写 pkill命令 pkill [选项][进程]进程名：按照进程名终止进程 选项： -t：终端号：按照终端号剔除用户 //踢掉用户 pkill -9 -t pts/? 6. 进程优先级 Linux 操作系统是一个多用户，多任务的操作系统，Linux 系统中同时运行着非常多的进程。但 CPU 在同一时钟周期内只能运算一个指令。进程优先级决定了每个进程处理的先后顺序。 注意：系统优先级：只有NI可以改，priority由两个值PRI,NI相加nice：使用前必须先停止进程renice：可以修正在运行的进程 nice命令 nice [选项] 命令：可以给新执行的命令直接赋NI值，但不能修改已经存在的进程的NI值 选项： -n NI值：给命令赋予NI值 例如： nice -n -5 service httpd start renice命令 renice [优先级] PID：修改已经存在进程的NI值的命令 例如： renice -10 2125 修改NI值时有几个注意事项 NI 的值的范围是 -20~19 普通用户调整 NI 的值的范围是 0~19，而且只能调整自己的进程 普通用户只能调高 NI值，不能降低 root 用户才能设定进程 NI 值为负值，而且可以调整任何用户的进程 PRI（最终值） = PRI（原始值）+ NI 用户只能修改 NI 值，不能直接修改时 PRI 数字越小，优先级越高 二、工作管理 工作管理指的是在单个登录终端中（也就是登录的 shell 界面中）同时管理多个工作的行为 注意事项： 当前的登录终端，只能管理当前终端的工作，而不能管理其他登录终端的工作 放入后台的命令必须可以持续运行一段时间，这样我们才能捕捉和操作这个工作 放入后台执行的命令不能和前台用户有交互或需要前台输入，否则放入后台只能暂停，而不能执行 1. 把进程放入后台 tar -zcf etc.tar.gz/etc &amp; #在命令后加入&amp;,把命令放在后台执行 按下ctrl + z快捷键，放在后台暂停 2. 查看后台的工作 jobs [-l] 选项： -l：显示工作的 PID 注意： + 代表最近一个放入后台的工作，也是工作回复时，默认恢复的工作 - 代表倒数第二个放入后台的工作 3. 将后台暂停的工作恢复到前台执行 fg %工作号 #恢复前台运行 bg %工作号 #恢复后台运行(不能有交互) 4. 后台命令脱离终端执行把命令放入后台，只能在当前登录终端执行。一旦退出或关闭终端，后台程序就会停止 后台命令脱离登录终端执行的方法： 把需要后台执行的命令加入 /etc/rc.local文件 使用系统定时任务，让系统在指定的时间执行某个后台命令 使用 nohup命令（常用）nohup 命令 &amp; 三、系统资源查看1. vmstat 命令监控系统资源 vmstat [刷新延时 刷新次数] 例如： vmstat 1 3 2. dmsg 开机时内核检测信息 dmesg dmesg | grep CPU 3. free 命令查看内存使用状态 free [-b|-k|-m|-g] 选项： -b：以字节为单位显示 -k：以KB为单位显示，默认就是以KB为单位显示 -m：以MB为单位显示 -g：以GB为单位显示 4. 查看 cpu 信息 cat /proc/cpuinfo 5. uptime 命令 uptime #显示系统的启动时间和平均负载，也就是top命令的第一行。w命令也可以看到这个数据 6. 查看系统与内核相关信息 uname [选项] 选项： -a：查看系统所有相关信息； -r：查看内核版本； -s：查看内核名称。 7. 列出进程打开或使用的文件信息 lsof [选项] #列出进程调用或打开的文件信息 选项： -c 字符串：只列出以字符串开头的进程打开的文件 -u 用户名：只列出某个用户的进程打开的文件 -p pid：列出某个PID进程打开的文件 缓冲和缓存的区别缓存（cache ) 是用来加速数据从硬盘中读取的缓冲（buffer）是用来加速数据写入硬盘的 查看当前Linux系统的发现版本lsb_release -a 判断当前系统的位数file /bin/ls 四、系统定时任务1. at 一次执行① 确定 at 安装 chkconfig --list | grep atd #at服务是否安装 service atd restart #at服务的启动 ② at的访问控制 如果系统中有/etc/at.allow文件，那么只有写入/etc/at.allow文件（白名单）中的用户可以使用at命令（/etc/at.deny文件会被忽略） 如果系统中没有/etc/at.allow文件，只有/etc/at.deny文件，那么写入/etc/at.deny文件（黑名单）中的用户不能使用at命令（注意：对root用户不起作用） 如果系统中这两个文件都不存在，那么只有root用户可以使用at命令 ③ at命令 at [选项] 时间 m：当at工作完成后，无论是否命令有输出，都用email通知执行at命令的用户 c 工作号：显示该at工作的实际内容 时间： HH:MM HH:MM YYYY-MM-DD HH:MM[am|pm] [month][date] HH:MM +[minutes|hours|days|weeks] ④ 例子在两分钟之后执行hello.sh脚本at now + 2 minutesat&gt; /root/hello.sh &gt;&gt; /root/hello.log ⑤ 其他at管理命令 atq #查询当前服务器上的at工作 atrm [工作号] #删除指定的at任务 2. crontab 循环定时① crond 服务管理与访问控制 service crond restar chkconfig crond on ② 用户的 crontab 设置 crontab [选项] 选项： -e：编辑crontab定时任务 -l：查询crontab任务 -r：删除当前用户所有的crontab任务 ③ 常用命令 crontab -l #查看root用户的crontab任务 crontab -r #删除root用户所有的定时任务 crontab -e ＃添加crontab任务 ④ crontab 注意事项 六个选项不能为空 crontab定时任务最小有效时间为分钟，最大为月 日期和星期最好不要同时出现 执行任务写绝对路径 访问控制 如果系统中有/etc/cron.allow文件(白名单)，那么只有在此名单下的用户可以使用cron命令； 如果系统中没有/etc/cron.allow文件，只有/etc/cron.deny文件(黑名单)，那么在此名单下的用户不能使用cron命令【对root不起作用】 如果系统这两个文件都不存在，那么只有root用户可以使用cron命令 crontab格式： * * * * * 执行的任务 第一个*：一小时当中的第几分钟，范围0-59 第二个*：一天当中的第几小时，范围0-23 第三个*：一个月当中的第几天，范围1-31 第四个*：一年当中的第几月，范围1-12 第五个*：一周当中的星期几，范围0-7（0和7都代表星期日） crontab 举例： 45 22 * 命令：在22点45分执行命令 0 17 1 命令：每周一的17点0分执行命令 0 5 1,15 命令：每月1号和15号的凌晨5点0分执行命令 40 4 1-5 命令：每周一到五的凌晨4点40分执行命令 /10 4 命令：每天的凌晨4点，每隔10分钟执行一次命令 0 0 1,15 * 1 命令：每月1号和15号，以及每周一的0点0分都执行命令 3. 执行系统的定时任务的方法：第一种：手工执行定时任务（crontab -e，默认当前用户）第二种：系统定时任务 把需要定时执行的脚本复制到/etc/cron.{daily,weekly,monthly}目录中的任意一个 修改/etc/crontab配置文件（必须指定用户） Reference: IMOOC-Linux系统管理]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 优化]]></title>
    <url>%2Fmysql-optimize.html</url>
    <content type="text"><![CDATA[下面说的优化基于 MySQL 5.6，理论上 5.5 之后的都算试用，具体还是要看官网 服务状态查询 查看当前数据库的状态，常用的有： 查看当前MySQL中已经记录了多少条慢查询，前提是配置文件中开启慢查询记录了. SHOW STATUS LIKE &#39;%slow_queries%&#39;; 查询当前MySQL中查询、更新、删除执行多少条了，可以通过这个来判断系统是侧重于读还是侧重于写，如果是写要考虑使用读写分离。 SHOW STATUS LIKE &#39;%Com_select%&#39;; SHOW STATUS LIKE &#39;%Com_update%&#39;; SHOW STATUS LIKE &#39;%Com_delete%&#39;; 显示MySQL服务启动运行了多少时间，如果MySQL服务重启，该时间重新计算，单位秒 SHOW STATUS LIKE &#39;uptime&#39;; 查询优化 使用 EXPLAIN 进行 SQL 语句分析：EXPLAIN SELECT * FROM sys_user; 得到的结果有下面几列： id，该列表示当前结果序号，无特殊意义，不重要 select_type，表示 SELECT 语句的类型，有下面几种 SIMPLE，表示简单查询，其中不包括连接查询和子查询 PRIMARY，表示主查询，或者是最外面的查询语句。比如你使用一个子查询语句，比如这条 SQL：EXPLAIN SELECT * FROM (SELECT sys_user_id FROM sys_user WHERE sys_user_id = 1) AS temp_table; 这条 SQL 有两个结果，其中有一个结果的类型就是 PRIMARY UNION，使用 UNION 的SQL是这个类型 DERIVED，在 SQL 中 From 后面子查询 SUBQUERY，子查询 还有其他一些 table，表名或者是子查询的一个结果集 type，表示表的链接类型，分别有（以下的连接类型的顺序是从最佳类型到最差类型）（这个属性重要）： 性能好： system，表仅有一行，这是const类型的特列，平时不会出现，这个也可以忽略不计。 const，数据表最多只有一个匹配行，因为只匹配一行数据，所以很快，常用于PRIMARY KEY或者UNIQUE索引的查询，可理解为const是最优化的。 eq_ref，mysql手册是这样说的:”对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE(唯一键)也不是PRIMARY KEY(主键)”。eq_ref可以用于使用=比较带索引的列。 ref，查询条件索引既不是UNIQUE(唯一键)也不是PRIMARY KEY(主键)的情况。ref可用于=或&lt;或&gt;操作符的带索引的列。 ref_or_null，该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。 性能较差： index_merge，该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。 unique_subquery，该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr)。unique_subquery 是一个索引查找函数,可以完全替换子查询,效率更高。 index_subquery，该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr) range，只检索给定范围的行,使用一个索引来选择行。 index，该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。 性能最差： ALL，对于每个来自于先前的表的行组合,进行完整的表扫描。（性能最差） possible_keys，指出MySQL能使用哪个索引在该表中找到行。如果该列为NULL，说明没有使用索引，可以对该列创建索引来提供性能。（这个属性重要） key，显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。（这个属性重要） key_len，显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。注意：key_len是确定了MySQL将实际使用的索引长度。 ref，显示使用哪个列或常数与key一起从表中选择行。 rows，显示MySQL认为它执行查询时必须检查的行数。（这个属性重要） Extra，该列包含MySQL解决查询的详细信息： Distinct:MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。 Not exists:MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。 range checked for each record (index map: #):MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。 Using filesort:MySQL需要额外的一次传递,以找出如何按排序顺序检索行。 Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。 Using temporary:为了解决查询,MySQL需要创建一个临时表来容纳结果。 Using where:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。 Using sort_union(…), Using union(…), Using intersect(…):这些函数说明如何为index_merge联接类型合并索引扫描。 Using index for group-by:类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。 了解对索引不生效的查询情况 （这个属性重要） 使用LIKE关键字的查询，在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不起作用。只有“%”不在第一个位置，索引才会生效。 使用联合索引的查询，MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于联合索引，只有查询条件中使用了这些字段中第一个字段时，索引才会生效。 使用OR关键字的查询，查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引列时，索引才会生效，否则，索引不生效。 子查询优化 MySQL从4.1版本开始支持子查询，使用子查询进行SELECT语句嵌套查询，可以一次完成很多逻辑上需要多个步骤才能完成的SQL操作。 子查询虽然很灵活，但是执行效率并不高。 执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响。 优化： 可以使用连接查询（JOIN）代替子查询，连接查询时不需要建立临时表，其速度比子查询快。 数据库结构优化 将字段很多的表分解成多个表 对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。 因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。 增加中间表 对于需要经常联合查询的表，可以建立中间表以提高查询效率。 通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。 增加冗余字段 设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。 插入数据的优化（适用于 InnoDB） 插入数据时，影响插入速度的主要是索引、唯一性校验、一次插入的数据条数等。 开发环境情况下的考虑： 开发场景中，如果需要初始化数据，导入数据等一些操作，而且是开发人员进行处理的，可以考虑在插入数据之前，先禁用整张表的索引， 禁用索引使用 SQL：ALTER TABLE table_name DISABLE KEYS; 当导入完数据之后，重新让MySQL创建索引，并开启索引：ALTER TABLE table_name ENABLE KEYS; 如果表中有字段是有唯一性约束的，可以先禁用，然后在开启： 禁用唯一性检查的语句：SET UNIQUE_CHECKS = 0; 开启唯一性检查的语句：SET UNIQUE_CHECKS = 1; 禁用外键检查（建议还是少量用外键，而是采用代码逻辑来处理） 插入数据之前执行禁止对外键的检查，数据插入完成后再恢复，可以提供插入速度。 禁用：SET foreign_key_checks = 0; 开启：SET foreign_key_checks = 1; 使用批量插入数据 禁止自动提交 插入数据之前执行禁止事务的自动提交，数据插入完成后再恢复，可以提供插入速度。 禁用：SET autocommit = 0; 开启：SET autocommit = 1; 服务器优化 好硬件大家都知道，这里没啥好说 通过优化 MySQL 的参数可以提高资源利用率，从而达到提高 MySQL 服务器性能的目的。]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-290. Word Pattern]]></title>
    <url>%2Fleetcode-290-word-pattern.html</url>
    <content type="text"><![CDATA[Given a pattern and a string str, find if str follows the same pattern.Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Examples:1234pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot; should return true.pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot; should return false.pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot; should return false.pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot; should return false. Notes:You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.代码123456789101112131415public boolean wordPattern(String pattern, String str) &#123; String[] strs = str.split(&quot; &quot;); if(pattern.length() != strs.length) return false; Map&lt;Character, String&gt; map = new HashMap&lt;Character, String&gt;(); for(int i=0;i&lt;pattern.length();i++) &#123; if(!map.containsKey(pattern.charAt(i))) &#123; if(map.containsValue(strs[i])) return false; map.put(pattern.charAt(i), strs[i]); &#125;else &#123; if(strs[i].equals(map.get(pattern.charAt(i)))) continue; else return false; &#125; &#125; return true; &#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-205. Isomorphic Strings]]></title>
    <url>%2Fleetcode-205-isomorphic-strings.html</url>
    <content type="text"><![CDATA[Given two strings s and t, determine if they are isomorphic.Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.For example,Given &quot;egg&quot;, &quot;add&quot;, return true.Given &quot;foo&quot;, &quot;bar&quot;, return false.Given &quot;paper&quot;, &quot;title&quot;, return true. Note:You may assume both s and t have the same length. 代码1234567891011121314151617public boolean isIsomorphic(String s, String t) &#123; if (s == null || t == null || s.length() != s.length()) &#123; return false; &#125; HashMap&lt;Character,Character&gt; m1 = new HashMap&lt;Character,Character&gt;(); HashMap&lt;Character,Character&gt; m2 = new HashMap&lt;Character,Character&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; if (!m1.containsKey(s.charAt(i))) &#123; if (m2.containsKey(t.charAt(i))) return false; m1.put(s.charAt(i), t.charAt(i)); m2.put(t.charAt(i), s.charAt(i)); &#125; else &#123; if (m1.get(s.charAt(i)) != t.charAt(i)) return false; &#125; &#125; return true; &#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-167. Two Sum II - Input array is sorted]]></title>
    <url>%2Fleetcode-167-two-sum-II.html</url>
    <content type="text"><![CDATA[Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 思路因为数组是有序的，所以通过二分法解决。 代码1234567891011121314151617class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; if(numbers==null || numbers.length &lt; 1) return null; int i=0, j=numbers.length-1; while(i&lt;j) &#123; int x = numbers[i] + numbers[j]; if(x&lt;target) &#123; ++i; &#125; else if(x&gt;target) &#123; --j; &#125; else &#123; return new int[]&#123;i+1, j+1&#125;; &#125; &#125; return null; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《程序员修炼之道》]]></title>
    <url>%2Fthe-pragmatic-programmer.html</url>
    <content type="text"><![CDATA[不能记住过去的人，被判重复过去。 –《程序员修炼之道》 这句引言，一直被我用作座右铭，当在书中读到这句的时候，感触颇深，也是我打算开始写博客记录生活的开始。跟这本书的机缘巧合，来自于之前公司的一个学长，他看完了，我便借来看了。 在序章中看到无数褒奖，我很担心这本书又是一些把技术当做禅宗佛学讲道的废话，看了一些的时候，了解到这本书涵盖程序员成长过程中和软件开发中需要注意的地方，从程序员的个体哲学到编码过程的各个环节，再到团队的项目管理，从程序员如何扩充知识，如何思考问题，如何利用有效工具打造个人环境，到项目启动之前如何建立一些基本准则，如何分析、设计、编写、测试、重构，如何实现自动化，甚至是项目团队中提高实效的原则，编程是一门手艺，这样的工匠精神更是一次一次感化着我幼小的心灵。 注重实效的程序员的两个特点 Care About Your Craft关心你的技艺 编程技术就是程序员的手艺，你的程序就是你的艺术品。时刻关注自己的技艺，保持热情、保持好奇，争取做到富有专长而又多才多艺。 关于程序员这个职业，引用@左耳朵耗子的一段微博：没哪个行业能像计算机行业这么活跃、刺激和有趣了。不仅是新兴工业革命的主力，又渗入到所有的行业中，干一辈子值了。//@_你亲爱的偏执狂: 程序员首先是工程师，Professional，就跟律师，医生一样，给大家解决问题；但是另一面呢，又是艺术家，创造新奇好玩的东西。这样的职业做一辈子有什么问题？ Think! About Your Work思考！你的工作 虽然软件开发是工程学，但每个程序员并不是螺丝钉，而是活跃的造血细胞。我们要思考需求，推敲设计，展望愿景，打磨细节；我们要思考如果提高工作效率，如何成长；在对权威产生疑惑时，我们又要批判的思考而不茫然接受。除去工程技术以外，逻辑思维能力才是程序员的核心竞争力，保持活跃、勤奋的思维。 我的源码让猫给吃了 依据你的职业发展、你的项目和你每天的工作，为你自己和你的行为负责这样一种观念，是注重实效的哲学的一块基石。注重实效的程序员对他或她自己的职业生涯负责，并且不害怕承认无知或错误。这肯定并非是编程最令人愉悦的方面，但它肯定会发生——即使是在最好的项目中。尽管有彻底的测试、良好的文档以及足够的自动化，事情还是会出错。交付晚了，出现了未曾预见到的技术问题。 发生这样的事情，我们要设法尽可能职业地处理它们。这意味着诚实和坦率。我们可以为我们的能力自豪，但对于我们的缺点——还有我们的无知和我们的错误——我们必须诚实。 Provide Options, Don’t Make Lame Excuses提供各种选择，不要找蹩脚的借口 这段对责任的描述并不只适用于程序员，但程序员可能会有自己的理解。面对历史遗留问题，是主动解决还是视而不见？问题发生时，是坦然担当还是去blame是猫吃了你的代码？ Sign Your Work在你的作品上签名 过去时代的手艺人为能在他们的作品上签名而自豪。你也应该如此。“这是我编写的，我对自己的工作负责。”你的签名应该被视为质量的保证。当人们在一段代码上看到你的名字时，应该期望它是可靠的、用心编写的、测试过的和有文档的，一个真正的专业作品，由真正的专业人员编写。 关于签名我们曾经在代码规范中推行过，在类的头文件中加入类似下面的注释。有签名在对自己是鞭策，其它工友也容易找到你咨询问题123456789//------------------------------------------------------------------------------//// 版权所有(C)被猫吃了技术有限公司保留所有权利//// 创建者: 被猫吃了// 创建日期: 2013-9-11// 功能描述: 被猫吃了////------------------------------------------------------------------------------ 软件的熵 熵是一个来自物理学的概念，指的是某个系统中的“无序”的总量。当软件中的无序增长时，程序员们称之为“软件腐烂”（software rot）。有许多因素可以促生软件腐烂。其中最重要的一个似乎是开发项目时的心理（或文化）。 Don’t Live with Broken Windows不要容忍破窗户 不要留着程序中的“破窗户”不修，低劣的设计，临时的糟糕的方案等等。而往往我们又面对着诸多的“现实”，没时间重构，重构风险大没资源测试。可是我们会永远生活在“现实”里面，不可能有某一天万事具备、良辰吉日等着让你开始着手去修理这些“破窗户”。我们可以借助自动测试等手段来帮助我们降低风险。如果真的没办法立即修复，请一定要做到：把发现的“破窗户”记入TODO List，并且定期Review它。灭火的故事： 作为对照，让我们讲述Andy的一个熟人的故事。他是一个富得让人讨厌的富翁，拥有一所完美、漂亮的房子，里面满是无价的古董、艺术品，以及诸如此类的东西。有一天，一幅挂毯挂得离他的卧室壁炉太近了一点，着了火。消防人员冲进来救火——和他的房子。但他们拖着粗大、肮脏的消防水管冲到房间门口却停住了——火在咆哮——他们要在前门和着火处之间铺上垫子。他们不想弄脏地毯。 这的确是一个极端的事例，但我们必须以这样的方式对待软件。如果你发现你所在团队和项目的代码十分漂亮——编写整洁、设计良好，并且很优雅——你就很可能会格外注意不去把它弄脏，就和那些消防员一样。即使有火在咆哮（最后期限、发布日期、会展演示，等等），你也不会想成为第一个弄脏东西的人。 重复的危害 给予计算机两项自相矛盾的知识，是James T. Kirk舰长（出自Star Trek，“星际迷航”——译注）喜欢用来使四处劫掠的人工智能生命失效的方法。遗憾的是，同样的原则也能有效地使你的代码失效。 我们觉得，可靠地开发软件、并让我们的开发更易于理解和维护的惟一途径，是遵循我们称之为DRY的原则：系统中的每一项知识都必须具有单一、无歧义、权威的表示。 DRY – Don’t Repeat Yourself不要重复你自己 重复是代码中最坏的味道，大家可以回想一下，有多少Bug是因为重复代码漏改引起的，修改重复代码又浪费了多少时间。这么坏的东西一定要深恶痛绝！书中归纳了几种常见的重复类型：强加的重复（imposed duplication）。开发者觉得他们无可选择——环境似乎要求重复。强加的重复细分为四类： 信息的多种表示。举个例子，QT的语言源文件是(.ts文件)，会由QT工具编译为.qm文件提供给应用程序使用。现在PC千牛把这两个文件都提交到了SVN，而不是只提交.ts文件然后动态生成.qm文件。因为漏提交.qm文件已经出过几次文案显示异常的Bug。解决这类重复很简单，保证单一数据源，其它的表示方式都通过根据这个数据源自动生成。办法是有了，但真能保证做到吗？ Write Code That WritesCode编写能编写代码的代码 代码中的文档。DRY法则告诉我们，要把低级的知识放在代码中，它属于那里；把注释保留给其他的高级说明。否则，我们就是在重复知识，而每一次改变都意味着既要改变代码，也要改变注释。注释将不可避免地变得过时，而不可信任的注释比完全没有注释更糟。逻辑清楚的代码自身就是最好的注释，除非是诡异的商业需求、不得已的临时解决方案抑或是在困难问题前屈服后使用的非常规方案。所以只有糟糕的代码才需要许多注释。 文档与代码。程序员们通常都有乖乖写文档的经历，但往往很难坚持，总有一天代码更新了，因为各种各样的理由，文档没有同步。所以在准备提供文档时请下定决心与做出承诺：保证要与代码进行同步的更新。 语言问题。就像C++的.h和.cpp文件，声明与实现就在重复着相同的内容。为了达到模块实现与接口分离的目的，就会出现这类重复。没有简单的技术手段避免，好在信息不一致编译期间会有错误。理想的做法是接口文件能通过实现文件自动生成。 无意的重复（inadvertent duplication）。开发者没有意识到他们在重复信息。有时，重复来自设计中的错误。123456struct Line&#123; Point start; Point end; double length;&#125;; 第一眼看上去，这个类似乎是合理的。线段显然有起点和终点，并总是有长度（即使长度为零）。但这里有重复。长度是由起点和终点决定的：改变其中一个，长度就会变化。最好是让长度成为计算字段。在以后的开发过程中，你可以因为性能原因而选择违反DRY原则。这经常会发生在你需要缓存数据，以避免重复昂贵的操作时。其诀窍是使影响局部化。对DRY原则的违反没有暴露给外界：只有类中的方法需要注意“保持行为良好”。 把DRY原则真正的消化，在设计时就会对这类无意的重复敏感，从源头上减少重复发生的可能。无耐性的重复（impatient duplication）。开发者偷懒，他们重复，因为那样似乎更容易。每个项目都有时间压力，你会受到诱惑去拷贝代码来实现相似的功能，总是没有时间去抽象出组件或者公用函数。如果你觉得受到诱惑，想一想古老的格言：“欲速则不达”，“磨刀不误砍柴功”。“想一想围绕着Y2K惨败的种种问题。其中许多问题是由开发者的懒惰造成的：他们没有参数化日期字段的尺寸，或是实现集中的日期服务库。”开发者之间的重复（interdeveloper duplication）。同一团队（或不同团队）的几个人重复了同样的信息。在高层，可以通过清晰的设计、强有力的技术项目领导（参见288页“注重实效的团队”一节中的内容）、以及在设计中进行得到了充分理解的责任划分，对这个问题加以处理。我们觉得，处理这个问题的最佳方式是鼓励开发者相互进行主动的交流。想想散落在外的，数不清的旺旺版本，这何尝不是团队之间的重复呢？组件化的思考方式能缓解这个问题，在推进业务的同时，沉淀一些基础库与组件服务。之前在B2B积累的各种客户端组件，现在不就帮助PC千牛迅速变得强壮了吗？ Make It Easy to Reuse让复用变得容易 你所要做的是营造一种环境，在其中要找到并复用已有的东西，比自己编写更容易。如果不容易，大家就不会去复用。而如果不进行复用，你们就会有重复知识的风险。 时间耦合 时间是软件架构的一个常常被忽视的方面，吸引我们的时间只是进度表上的时间。作为软件自身的一种设计要素，时间有两个方面对我们很重要：并发和次序。我们在编程时，通常并没有把这两个方面放在心上。当人们最初坐下来开始设计架构、或是编写程序时，事情往往是线性的，那是大多数人的思考方式——总是先做这个，然后再做那个。但这样思考会带来时间耦合：在时间上的耦合，方法A必须总在方法B之前调用，“嘀”必须在“嗒”之前发生。 程序在时序性上的依赖是客观存在的，我们需要做的是： 1. 尽量减少不必要的时序依赖以提高并发能力； 2. 保证真正需要的时序依赖不存在被破坏的可能。人们通常会通过文档说明时序的依赖，就像MSDN中会写明使用COM之前必须调用CoInitialize()一样。但实际开发中时序上依赖通常会成为潜规则，只有当初开发的人自己知道，对后面维护的人来讲这就会是定时炸弹。对不得已的时序依赖一定要写入文档或者标明注释。 正交性 正交性”是从几何学中借来的术语。如果两条直线相交成直角，它们就是正交的。在计算技术中，该术语用于表示某种不相依赖性或是解耦性。如果两个或更多事物中的一个发生变化，不会影响其他事物，这些事物就是正交的。 Eliminate Effects BetweenUnrelated Things消除无关事物之间的影响 如果你编写正交的系统，你得到两个主要好处：提高生产率与降低风险。贯彻正交性原则可以促进组件化与复用；可以有效缩小错误代码影响的范围；更有利于单元测试。你也可以对项目团队的正交性进行衡量：只要看一看，在讨论每个所需改动时需要涉及多少人。人数越多，团队的正交性就越差。显然，正交的团队效率也更高（尽管如此，我们也鼓励子团队不断地相互交流）。 正交性与DRY原则紧密相关。运用DRY原则，你是在寻求使系统中的重复降至最小；运用正交性原则，你可降低系统的各组件间的相互依赖。这样说也许有点笨拙，但如果你紧密结合DRY原则、运用正交性原则，你将会发现你开发的系统会变得更为灵活、更易于理解、并且更易于调试、测试和维护。 这本书花了很大的篇幅讲述DRY原则和正交性（也就是解耦），也提供了很多有实践意义的方法。回想一下设计模式，很多模式也正是为了解决这两个问题。这两个原则大家一定都耳熟能详，这里引用序言书评中的一句话：“能不能让正确的原则指导正确的行为本身，其实就是区分是否是高手的一个显著标志”。知道很容易，尝试在日常开发中去实践从而真正内化，最终达到运用自如。 我们认为违反这两个原则的设计和实现就是“破窗户“。在确保自己不产生的同时，也要留意现有代码，发现问题抛出来，大家一起讨论如何优化何时优化（优化有风险，重构需谨慎）。最终要么消灭，要么确保一定被记录在案（把破窗口先用木板暂时封起来）。千万不要看到糟糕的代码皱皱眉、抱怨两句就结束了，把它放到TODO List里面！ 重构 随着程序的演化，我们有必要重新思考早先的决策，并重写部分代码。这一过程非常自然。代码需要演化；它不是静态的事物。 无论代码具有下面的哪些特征，你都应该考虑重构代码：重复；非正交的设计；过时的知识（最典型的就是需求已经下线、方案已经改变，但过时代码却还残留甚至运行）；性能问题。 人们通常用肿瘤来比喻重构的必要性，在现实的时间压力面前，需要做出正确的选择。追踪需要重构的事物。如果你不能立刻重构某样东西，就一定要把它列入计划。确保受到影响的代码使用者知道该代码计划要重构，以及这可能会怎样影响他们。 Refactor Early, Refactor Often早重构，常重构 书中给出了几点重构实践上的指导： 不要试图在重构的同时增加功能。 在开始重构前，确保你拥有良好的测试。 采取短小，深思熟虑的步骤。把整体重构工作认真的分解为独立、轻量的几个步骤，每个步骤完成都可以进行测试，这将有助于快速定位问题。####无处不在的自动化 让计算机去做重复、庸常的事情——它会做得比我们更好。我们有更重要、更困难的事情要做。 Don’t Use Manual Procedures不要使用手工流程 自动化为我们带来两个显而易见的好处：避免重复劳动提高效率；保持可靠的一致性与可重复性，排除人工作操作可能产生的错误。可以自动化的项目包括但不限于：项目编译，回归测试，构建与发布，通过单一数据源生成数据的其它表示。 “鞋匠的孩子没鞋穿”。我们是程序员，是否在的日常工作中经常制作自动化工具？至少掌握一门高级脚本语言用于快速开发自制工具。 可撤销性 我们让本书的许多话题相互配合，以制作灵活、有适应能力的软件。通过遵循它们的建议——特别是DRY原则（26页）、解耦（138页）以及元数据的使用（144页）——我们不必做出许多关键的、不可逆转的决策。这是一件好事情，因为我们并非总能在一开始就做出最好的决策。我们采用了某种技术，却发现我们雇不到足够的具有必需技能的人。我们刚刚选定某个第三方供应商，他们就被竞争者收购了。与我们开发软件的速度相比，需求、用户以及硬件变得更快。 There Are No FinalDecisions不存在最终决策 没有人知道未来会悄怎样，尤其是我们！所以要让你的代码学会“摇滚”：可以“摇”就“摇”，必须“滚”就“滚”。 需求变更，是永恒的话题。变更往往又总是不可避免、总是迫在眉睫。在设计与编码时尽可能的注意并应用以上几个原则，会让我们面对变化从容不迫，甚至可以达到“中流换马（change horses in midstream）”的灵活性。 元程序设计 细节会弄乱我们整洁的代码——特别是如果它们经常变化。每当我们必须去改动代码，以适应商业逻辑、法律或管理人员个人一时的口味的某种变化时，我们都有破坏系统或引入新bug的危险。所以我们说“把细节赶出去！”把它们赶出代码。当我们在与它作斗争时，我们可以让我们的代码变得高度可配置和“柔软”——就就是，容易适应变化。 要用元数据（metadata）描述应用的配置选项：调谐参数、用户偏好、安装目录等等。元数据是数据的数据，最为常见的例子可能是数据库schema或数据词典。 Configure,Don’t Integrate要配置，不要集成 但我们不只是想把元数据用于简单的偏好。我们想要尽可能多地通过元数据配置和驱动应用：为一般情况编写程序，把具体情况放在别处——在编译的代码库之外。 Put Abstractions in Code,Details in Metadata将抽象放进代码，细节放进元数据 曳(yè)光弹 译著中对曳光弹的描述有点难懂，百科中的解释：曳光弹是一种装有能发光的化学药剂的炮弹或枪弹，用于指示弹道和目标。曳光弹在光源不足或黑暗中可显示出弹道，协助射手进行弹道修正，甚至作为指引以及联络友军攻击方向与位置的方式与工具。 这个类比也许有点暴力，但它适用于新的项目，特别是当你构建从未构建过的东西时。与枪手一样，你也设法在黑暗中击中目标。因为你的用户从未见过这样的系统，他们的需求可能会含糊不清。因为你在使用不熟悉的算法、技术、语言或库，你面对着大量未知的事物。同时，因为完成项目需要时间，在很大程度上你能够确知，你的工作环境将在你完成之前发生变化。 经典的做法是把系统定死。制作大量文档，逐一列出每项需求、确定所有未知因素、并限定环境。根据死的计算射击。预先进行一次大量计算，然后射击并企望击中目标。 然而，注重实效的程序员往往更喜欢使用曳光弹。 Use Tracer Bullets toFind the Target用曳光弹找到目标 曳光代码并非用过就扔的代码：你编写它，是为了保留它。它含有任何一段产品代码都拥有的完整的错误检查、结构、文档、以及自查。它只不过功能不全而已。但是，一旦你在系统的各组件间实现了端到端（end-to-end）的连接，你就可以检查你离目标还有多远，并在必要的情况下进行调整。一旦你完全瞄准，增加功能将是一件容易的事情。 曳光开发与项目永不会结束的理念是一致的：总有改动需要完成，总有功能需要增加。这是一个渐进的过程。 曳光开发其实大家或多或少都在参与。新项目创建时搭建框架代码，逐渐为框架添加功能正是这样一个过程。我们会在框架中让关键流程能够运行，以检验新技术在真实环境中的表现与预研的结果是否一致；检验整体设计是否有明显的性能问题；让用户尽早看到可工作的产品以提供反馈；为整个团队提供可以工作的结构与集成平台，大家只需要关心增加功能代码让框架更丰满。 曳光开发和原型模式有明显区别。原型中的代码是用过就扔的，寻求以最快的速度展示产品，甚至会采用更高级的语言。曳光代码虽然简约，但却是完成的，它拥有完整的错误检查与异常处理，只不过是功能不全而已。 Bug与Debug 自从14世纪以来，bug一词就一直被用于描述“恐怖的东西”。COBOL的发明者，海军少将Grace Hopper博士据信观察到了第一只计算机bug——真的是一只虫子，一只在早期计算机系统的继电器里抓到的蛾子。在被要求解释机器为何未按期望运转时，有一位技术人员报告说，“有一只虫子在系统里”，并且负责地把它——翅膀及其他所有部分——粘在了日志簿里。调试的心理学 发现了他人的bug之后，你可以花费时间和精力去指责让人厌恶的肇事者。但bug是你的过错还是别人的过错，并不是真的很有关系。它仍然是你的问题。 Fix the Problem, Not theBlame要修正问题，而不是发出指责 人很容易恐慌，特别是如果你正面临最后期限的到来、或是正在设法找出bug的原因，有一个神经质的老板或客户在你的脖子后面喘气。但非常重要的事情是，要后退一步，实际思考什么可能造成你认为表征了bug的那些症状。 Don’t Panic不要恐慌 bug有可能存在于OS、编译器、或是第三方产品中——但这不应该是你的第一想法。有大得多的可能性的是，bug存在于正在开发的应用代码中。记住，如果你看到马蹄印，要想到马，而不是斑马（这个比喻太棒了！）。OS很可能没有问题。数据库也很可能情况良好。 我们参加过一个项目的开发，有位高级工程师确信select系统调用在Solaris上有问题。再多的劝说或逻辑也无法改变他的想法（这台机器上的所有其他网络应用都工作良好这一事实也一样无济于事）。他花了数周时间编写绕开这一问题的代码，因为某种奇怪的原因，却好像并没有解决问题。当最后被迫坐下来、阅读关于select的文档时，他在几分钟之内就发现并纠正了问题。现在每当有人开始因为很可能是我们自己的故障而抱怨系统时，我们就会使用“select没有问题”作为温和的提醒。 Select” Isn’t Broken“Select”没有问题 基于越是新添加的代码越可能引起问题的怀疑，书中推荐了二分查找的方法不断缩小范围，最终定位问题。这方法看起来很老土，但实践中往往很有效，在毫无头绪时不妨试一试。 在发现某个bug让你吃惊时（也许你在用我们听不到的声音咕哝说：“那不可能。”），你必须重新评估你确信不疑的“事实”。某样东西出错时，你感到吃惊的程度与你对正在运行的代码的信任及信心成正比。这就是为什么，在面对“让人吃惊”的故障时，你必须意识到你的一个或更多的假设是错的。不要因为你“知道”它能工作而轻易放过与bug有牵连的例程或代码。证明它。用这些数据、这些边界条件、在这个语境中证明它。 说到让人惊讶的bug，最近刚好经历了一次。关于PC千牛插件最大化行为的bug，我和杯酒电话中如何讨论都无法理解对方，最后到现场看了才明白。这个问题只会发作在低分辨率的电脑上，他是便携笔记本分辨率低，而我是高分屏的开发机。如果你目睹bug或见到bug报告时的第一反应是“那不可能”，你就完全错了。一个脑细胞都不要浪费在以“但那不可能发生”起头的思路上，因为很明显，那不仅可能，而且已经发生了。 Don’t Assume it– Prove It不要假定，要证明 断言式编程在自责中有一种满足感。当我们责备自己时，会觉得再没人有权责备我们。 ——奥斯卡·王尔德：《多里安·格雷的画像》 每一个程序员似乎都必须在其职业生涯的早期记住一段曼特罗（mantra）。它是计算技术的基本原则，是我们学着应用于需求、设计、代码、注释——也就是我们所做的每一件事情——的核心信仰。那就是：这决不会发生…… “这些代码不会被用上30年，所以用两位数字表示日期没问题。”“这个应用决不会在国外使用，那么为什么要使其国际化？”“count不可能为负。”“这个printf不可能失败。”我们不要这样自我欺骗，特别是在编码时。 If It Can’t Happen, Use Assertions to Ensure That It Won’t如果它不可能发生，用断言确保它不会发生 断言可能会引起副作用，因为断言可能会在编译时被关闭——决不要把必须执行的代码放在assert中。这个问题就是一种“海森堡虫子”（Heisenbug）——调试改变了被调试系统的行为。 断言的好处不言而喻，可以提高调试的效率，可以尽早的发现问题。调试的时候应该保持对断言敏感，如果自己没有时间去调查断言发生的原因，也应该把问题抛出来及时解决。如果对断言视而不见，也就失去了断言的意义。可以考虑在输出错误日志的方法中直接加入断言，往往需要记录错误的问题也是我们认为不应该发生或者需要引起关注的问题。到现在我还清晰的记得以前的一个Bug就是因为断言副作用引起的，因为我写了这样的代码：ASSERT(SUCCEEDED(Initialize()));，调试时一切正常，当以release编译发布测试包时就出现了问题。 靠巧合编程 你有没有看过老式的黑白战争片？一个疲惫的士兵警觉地从灌木丛里钻出来，前面有一片空旷地：那里有地雷吗？还是可以安全通过？没有任何迹象表明那是雷区——没有标记、没有带刺的铁丝网、也没有弹坑。士兵用他的刺刀戳了戳前方的地面，又赶紧缩回来，以为会发生爆炸。没有，于是他紧张地向前走了一会儿，刺刺这里，戳戳那里。最后，他确信这个地方是安全的，于是直起身来，骄傲地正步向前走去，结果却被炸成了碎片。士兵起初的探测没有发现地雷，但这不过是侥幸。他由此得出了错误的结论——结果是灾难的。 作为开发者，我们也工作在雷区里，每天都有成百的陷阱在等着抓住我们。记住士兵的故事，我们应该警惕，不要得出错误的结论。我们应该避免靠巧合编程——依靠运气和偶然的成功——而要深思熟虑地编程。 Don’t Program by Coincidence不要靠巧合编程 书中提到两种依靠巧合编程的典型：实现的偶然与隐含的假定。实现的偶然就是在使用新技术、三方库或者其它人写的模块时，拼凑的代码碰巧工作了，那么我们就宣告胜利结束编码。当这些代码出问题时，通常会一头雾水，因为当初根本不明白它为什么会工作。隐含的假定是开发者使用自以为的前提，而实际上没有任何文档或者现实数据可以依靠。我曾经遇到过这样让人哭笑不得的经历：代码依赖了某个存在已久的bug的错误表现，当这个bug最终被修复时，原本运行良好的代码反而出现了问题。我们常说“踩坑”，这些坑可能是前人用巧合编程留下的，也可能是因为我们依靠了巧合编程而引起的。 避免实现的偶然，要求我们谨慎对待不熟悉的依赖，仔细阅读文档，代码虽然可以工作，但并不一定正确。避免隐含的假定，要求我们只依靠可靠的事物，针对暂时无法获知的可能，代码要以最坏的假定来对待，不能给自己盲目的乐观的条件。下次有什么东西看起来能工作，而你却不知道为什么，要确定它不是巧合。 书中另一个主题“邪恶的向导”，适合在这里提一下。向导产生的代码往往和我们编写的代码交织在一起，这要求我们去理解它，否则我们怎么敢去依靠它来让代码工作呢？ Don’t Use Wizard Code You Don’t Understand不要使用你不理解的向导代码 需求之坑Don’t Gather Requirements- Dig for Them不要搜集需求——挖掘它们 用户的需求描述可能是：只有员工的上级和人事部门才可以查看员工的档案。经过挖掘的需求：只有指定的人员才能查看员工档案。前者把规则硬性的写入了需求，但规则经常会改变。后者的优点是需求描述为一般性陈述，规则独立描述，这样规则可以成为应用中的元数据。在实现时可以把需求理解为：只有得到授权的用户可以访问员工档案，开发者就可能会实现某种访问控制系统。规则改变时，只有系统的元数据需求更新，以这样的角度去实现需求，得到的自然就是支持元数据、得到了良好分解的系统。但也要注意避免过度设计，需求也许就是那么简单。 Abstractions Live Longerthan Details抽象比细节活得更长久 “投资”于抽象，而不是实现。抽象能在来自不同的实现和新技术的变化的“攻击”之下存活下去。书中反复举了Y2K问题的例子，认为其发生有两个主要原因：没有超出当时的商业实践往前看，以及对DRY原则的违反。即使需求要求把两个数字的年份用于数据输入、报表、以及存储，本来也应该设计一种DATE抽象，“知道”两个数据的年份只是真实日期的一种缩略形式。 极大的期望 如果你和用户紧密协作，分享他们的期望，工同他们交流你正在做的事情，那么当项目交付时，就不会发生多少让人吃惊的事情了。这是一件糟糕的事情。要设法让你的用户惊讶。请注意，不是惊吓他们，而是要让他们产高兴。给他们的东西要比他们期望的多一点。 Gently Exceed Your Users’ Expectations温和地超出用户的期望 做到这一点的前提是要理解用户的期望。可以借助“曳光弹”和“原型”与用户交流。永远不要把我们认为好的东西当成是用户想要的。 足够好的软件 欲求更好，常把好事变糟。 ——李尔王 1.4 有一个老的笑话，说一家美国公司向一家日本制造商订购100 000片集成电路。规格说明中有次品率：10 000片中只能有1片。几周过后订货到了：一个大盒子，里面装有数千片IC，还有一个小盒子，里面只装有10片IC。在小盒子上有一个标签，上面写着：“这些是次品”。要是我们真的能这样控制质量就好了。但现实世界不会让我们制作出十分完美的产品，特别是不会有无错的软件。时间、技术和急躁都在合谋反对我们。 软件何时“足够好”？客户会比开发人员更有发言权。他们可能尽早需要一个还可以的版本，但不想为了一个完美的版本再等上一年。虽然这里倡导我们不要追求极端的完美，但也不意味着我们可以交付充满瑕疵的半成品。引用耗子兄在《Rework》摘录及感想中的一段话：平衡Done和Perfect的方式正好就是这句话——“与其做个半成品，不好做好半个产品”，因为，一个半成品会让人绝望，而半个好产品会让人有所期望，这就是其中的不同。]]></content>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-633. Sum of Square Numbers]]></title>
    <url>%2Fleetcode-633-sum-of-square-numbers.html</url>
    <content type="text"><![CDATA[Given a non-negative integer c, your task is to decide whether there’re two integers a and b such that a2 + b2 = c. Example 1:123Input: 5Output: TrueExplanation: 1 * 1 + 2 * 2 = 5 Example 2:12Input: 3Output: False 題意 给一个数字 c，判断是否满足 a^2 + b^2 = c 思路 从 0 到 sqrt（c）之间进行遍历，检测剩下的数开方后是不是整数。 代码123456789boolean judgeSquareSum(int c) &#123; int limit = (int) Math.sqrt(c); for (int n = 0; n &lt;= limit; n++) &#123; double test = Math.sqrt(c - n * n); if (test - (int)test == 0) return true; &#125; return false; &#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-1. Two Sum]]></title>
    <url>%2Fleetcode-1-two-sum.html</url>
    <content type="text"><![CDATA[Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 思路 利用hashmap，key存放数值，value存放出现的位置。从前到后进行遍历，将target值减去当前的值,看是否存在map中,若存在map中则取出相应的标号，退出。 代码1234567891011121314public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); int result[] = new int[2]; for (int i = 0; i &lt; nums.length; i++)&#123; int num = target - nums[i]; if(map.containsKey(num))&#123; result[0] = map.get(num); result[1] = i; return result; &#125; map.put(nums[i], i); &#125; return result; &#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 初探]]></title>
    <url>%2Fnginx-learn.html</url>
    <content type="text"><![CDATA[分享一篇关于Nginx介绍的好文。 Reference: 徐刘根的专栏 -《Nginx初探》]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-35. Search Insert Position]]></title>
    <url>%2Fleetcode-35-search-insert-position.html</url>
    <content type="text"><![CDATA[Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You may assume no duplicates in the array. Here are few examples.1234[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 思路 二分查找,还需要考虑到边界的问题。 代码123456789101112131415161718192021222324252627282930public static void main(String[] args) throws Exception &#123; int[] arr = &#123;1, 3, 5, 6&#125;; int result = new Test().searchInsert(arr, 6); System.out.println(result); &#125; public static int searchInsert(int[] arr, int target) &#123; if (arr == null || arr.length == 0) &#123; return -1; &#125; int start = 0; int end = arr.length - 1; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (target == arr[mid]) &#123; return mid; &#125; else if (arr[mid] &gt; target) &#123; end = mid; &#125; else if (arr[mid] &lt; target) &#123; start = mid; &#125; &#125; if (arr[start] == target) &#123; return start; &#125; if (arr[end] == target) &#123; return end; &#125; return -1; &#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-7. Reverse Integer]]></title>
    <url>%2Fleetcode-7-reverse-integer.html</url>
    <content type="text"><![CDATA[Reverse digits of an integer. Example1:1x = 123, return 321 Example2:1x = -123, return -321 Note: The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. 代码 12345678910public long reverse(int x)&#123; long y=0; int n; while( x != 0)&#123; n = x%10; y = y*10 + n; x /= 10; &#125; return y;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-50. Pow(x,n)]]></title>
    <url>%2Fleetcode-50-pow-x-n.html</url>
    <content type="text"><![CDATA[Implement pow(x, n). 思路 利用递归求解。 代码 12345678910111213public double myPow(double x, int n)&#123; if(n == 0) return 1D; long N = n; //use long to avoid overflow. return solve(n &lt; 0 ? (1 / x) : x, N &lt; 0 ? (N * -1) : N);&#125;public double solve(double x, long n)&#123; if(n == 1) return x; double val = solve(x, n / 2); return val * val * ((n % 2) == 0 ? 1 : x);&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dict-命令行下中英文翻译工具]]></title>
    <url>%2Fdict.html</url>
    <content type="text"><![CDATA[命令行下中英文翻译工具（Chinese and English translation tools in the command line） 安装(Install)ubuntu 安装 pip12sudo apt-get install python-pip python-dev build-essential sudo pip install --upgrade pip 安装 dict1sudo pip install dict-cli 用法(Usage)英译中(English To Chinese)1234567891011121314151617181920212223242526272829303132333435363738$ dict test#################################### test 测试# (U: tɛst E: test)## n. 试验；检验# vt. 试验；测试# vi. 试验；测试# n. (Test)人名；(英)特斯特## Test : 测试# 测验# 检验# Test Drive : Test Drive# Test Drive# 无限狂飙# Test Engineer : 测试员# 测试工程师# 软件测试工程师###################################$ dict I love you#################################### I love you 我爱你### 我爱你。## I love you : 我爱你# ILOVEYOU蠕虫# 寻找伴郎# I really love you : 真的爱你# 其实很爱你# 我是真的爱你# I Do love you : 我是爱你的# 真的爱你# 爱你我该怎么办################################### 中译英(Chinese To English)1234567891011121314151617181920212223242526272829303132333435$ dict 测试#################################### 测试 test# (Pinyin: cè shì)## [试验] test# measurement## 测试 : Test# test# TST test# 集成测试 : Integration testing# Test d'intégration# 통합 시험# ANOVA测试 : Gage R&amp;amp;R# ANOVA gauge R&amp;amp;R###################################$ dict 我爱你#################################### 我爱你 I love you# (Pinyin: wǒ ài nǐ)## I love you## 我爱你 : I love you# Ich liebe dich# Wuh that I love you# 我也爱你 : I Love You Too# And I Love You So# Ik ook van jou# 我就爱你 : The Arrangement# gou couh gyaez mwngz muengh# I'll just be love you################################### Reference: github.com/wufeifei/dict]]></content>
      <tags>
        <tag>tools</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易云音乐命令行版本]]></title>
    <url>%2Fnetease-musicbox.html</url>
    <content type="text"><![CDATA[感谢为 MusicBox 的开发付出过努力的每一个人！高品质网易云音乐命令行版本，简洁优雅，丝般顺滑，基于Python编写。使用起来不会觉得折腾，感觉很酷。 NetEase-MusicBox 功能特性 功能特性 320kbps的高品质音乐 歌曲，艺术家，专辑检索 网易22个歌曲排行榜 网易新碟推荐 网易精选歌单 网易主播电台 私人歌单，每日推荐 随心打碟 本地收藏，随时加❤ 播放进度及播放模式显示 现在播放及桌面歌词显示 歌曲评论显示 一键进入歌曲专辑 定时退出 Vimer式快捷键让操作丝般顺滑 可使用数字快捷键 可使用自定义全局快捷键 键盘快捷键 J Down 下移 K Up 上移 H Back 后退 L Forword 前进 U Prev page 上一页 D Next page 下一页 F Search 快速搜索 [ Prev song 上一曲 ] Next song 下一曲 = Volume + 音量增加 - Volume - 音量减少 Space Play/Pause 播放/暂停 ? Shuffle 手气不错 M Menu 主菜单 P Present/History 当前/历史播放列表 I Music Info 当前音乐信息 ⇧+P Playing Mode 播放模式切换 A Add 添加曲目到打碟 ⇧+A Enter album 进入专辑 G To the first 跳至首项 ⇧+G To the end 跳至尾项 Z DJ list 打碟列表 S Star 添加到收藏 C Collection 收藏列表 R Remove 删除当前条目 ⇧+J Move Down 向下移动当前项目 ⇧+K Move Up 向上移动当前项目 ⇧+C Cache 缓存歌曲到本地 , Like 喜爱 . Trash FM 删除 FM / Next FM 下一FM Q Quit 退出 T Timing Exit 定时退出 W Quit&amp;Clear 退出并清除用户信息 PyPi安装1$ pip(3) install NetEase-MusicBox Git clone最新版12$ git clone https://github.com/darknessomi/musicbox.git &amp;&amp; cd musicbox$ python(3) setup.py install macOS安装12$ pip(3) install NetEase-MusicBox$ brew install mpg123 Linux安装Fedora首先添加FZUG源，然后1sudo dnf install musicbox Ubuntu/Debian12$ sudo pip install NetEase-MusicBox$ sudo apt-get install mpg123 Arch Linux1$ pacaur -S netease-musicbox-git #or use $ yaourt musicbox 可选功能依赖 aria2 用于缓存歌曲 python-keybinder 用于支持全局快捷键 libnotify-bin 用于支持消息提示 pyqt python-dbus dbus qt 用于支持桌面歌词 (Mac 用户需要 brew install qt --with-dbus 获取支持 DBus 的 Qt) 配置文件配置文件地址: ~/.netease-musicbox/config.json可配置缓存，快捷键，消息，桌面歌词。由于歌曲 API 只接受中国大陆地区访问，港澳台及海外用户请自行设置代理：12345&quot;mpg123_parameters&quot;: &#123; &quot;default&quot;: [], &quot;describe&quot;: &quot;The additional parameters when mpg123 start.&quot;, &quot;value&quot;: [&quot;-p&quot;, &quot;http://ip:port&quot;]&#125; 已测试的系统兼容列表 macOS 10.12 / 10.11 Ubuntu 14.04 Kali 1.1.0 / 2.0 / Rolling CentOS 7 openSUSE 13.2 Fedora 22 Arch Rolling 错误处理 如遇到在特定终端下不能播放问题，首先检查此终端下mpg123能否正常使用，其次检查其他终端下musicbox能否正常使用，报告issue的时候请告知以上使用情况以及出问题终端的报错信息。 已知问题及解决方案 #374 i3wm下播放杂音或快进问题，此问题常见于Arch Linux。尝试更改mpg123配置。 #404 某些环境缺乏lxml。尝试利用包管理器安装lxml或者直接pip install lxml。 #405 32位Python下cookie时间戳超出了32位整数最大值。尝试使用64位版本的Python或者拷贝cookie文件到对应位置。 #347 暂停时间超过一定长度（数分钟）之后mpg123停止输出，导致切换到下一首歌。此问题是mpg123的bug，暂时无解决方案。 使用1$ musicbox Enjoy it ! Reference: github.com/darknessomi/musicbox]]></content>
      <tags>
        <tag>linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-49. Group Anagrams]]></title>
    <url>%2Fleetcode-49-group-anagrams.html</url>
    <content type="text"><![CDATA[Given an array of strings, group anagrams together. For example, given:1[“eat”, “tea”, “tan”, “ate”, “nat”, “bat”], Return:12345[ [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: For the return value, each inner list’s elements must follow the lexicographic order.All inputs will be in lower-case. 思路 将每一个字符串里面的字符进行排序放到HashMap中。 代码123456789101112131415161718192021222324public class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; ll = new ArrayList&lt;&gt;(); if (strs.length &lt;= 0) return ll; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String str : strs) &#123; String sstr = sortStr(str); if (map.containsKey(sstr)) &#123; map.get(sstr).add(str); &#125; else &#123; List&lt;String&gt; l = new ArrayList&lt;&gt;(); l.add(str); map.put(sstr, l); &#125; &#125; return new ArrayList&lt;&gt;(map.values()); &#125; public String sortStr(String str) &#123; char[] cc = str.toCharArray(); Arrays.sort(cc); return String.valueOf(cc); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-46. Permutations]]></title>
    <url>%2Fleetcode-46-permutations.html</url>
    <content type="text"><![CDATA[Given a collection of distinct numbers, return all possible permutations. For example,[1,2,3] have the following permutations:12345678[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 思路 对于nums数组中的每一个数，都依次放入结果集中，如果结果集中已经包含这个数，就继续下一次循环。 以数组[1,2,3]为例，每次循环的结果是：123456[1,2,3][1,3,2][2,1,3][2,3,1][3,1,2][3,2,1] 代码123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网 Oracle 高级教程]]></title>
    <url>%2Fimooc-oracle-course.html</url>
    <content type="text"><![CDATA[高级查询在数据库的开发过程中应用广泛，本教程通过大量的案例和老师的详细讲解，从分组查询、多表查询和子查询三个方面介绍Oracle的高级查询，也介绍了一些查询的应用场景。 分组查询 分组函数的概念：分组函数作用于一组数据，并对一组数据返回一个值。 分组函数的使用：12345678- avg() /**求平均值**/ eg: select avg(sal) from emp;- sum() /**求总和**/ eg: select sum(sal) from emp;- min() /**求最小值**/ eg: select min(sal) from emp;- max() /**求最大值**/ eg: select max(sal) from emp;- count() /**求个数**/ eg: select count(deptno) from emp;- distinct /**剔除重复**/ eg: select count(distinct deptno) from emp;- WM_CONCAT /**行转列**/ eg: select deptno ，wm_concat(ename) from emp group by deptno; /**按照部门号分组，将相同部门号的员工以逗号分隔的形式展示到一行中**/ 注意： 分组函数会自动忽略空值，要用nvl() 函数转换空值才行.NVL（表达式1，表达式2） 如果表达式1为空值，NVL返回值为表达式2的值，否则返回表达式1的值。 该函数的目的是把一个空值（null）转换成一个实际的值。其表达式的值可以是数字型、字符型和日期型。但是表达式1和表达式2的数据类型必须为同一个类型。 group by字句分组：12// 查询不同部门，不同职位的员工工资select deptno ,job,sum(sal) from emp group by deptno, job; 注意： 在select 列表中所有未包含在组函数中的列都应该包含在group by子句中，不然属于非法使用组函数。 使用having 字句过滤分组：having 字句和 where一样，可以进行条件过滤。 注意： having先分组在过滤；where先过滤在分组。where效率更高，where中不能使用分组函数。 两者可以通用的话。我们尽量先过滤再分组，即尽量使用where,优化，提高性能 在分组查询中使用排序：order by 子句可以跟 字段名 别名 表达式（聚合函数）以及 字段的位置序号。 1select deptno avg(sal) from emp group by deptno order by deptno; group by 语句的增强：group by语句的增强，主要用于报表中 123select deptno,job,sum(sal) from emp group by deptno,job;select deptno,sum(sal) from emp group by deptno;select sum(sal) from emp; 上面的三条语句合起来的效果与下面的一条语句相同,下面是 group by 语句的加强123select deptno,job,sum(sal) from emp group by rollup(deptno,job);// 语法select 列名1,列名2,组函数(x) from tablename group by rollup(列名1,列名2); sql*plus的报表功能： 使用ttitle命令设置报表的名称，col表示列的意思，15表示空15列显示“我的报表”这个标题，然后再空35个列，显示sql.pno,sql.pno表示报表的页码。 col也可以用来设置列的别名，比如第二行把deptno标题设置为部门号 break on deptno skip 1，在上一节课程已经介绍过，表示遇见重复的部门号就只显示一次，不同的部门号之间空一行 set pagesize 10 每页显示10行多表查询 什么是多表查询？从多个表中获取数据就称为多表查询 笛卡尔积两张表进行笛卡尔积运算，最终结果的列数等于各表中列数之和，行数等于各个表中行数之积。为了避免使用笛卡尔全集，使用where加入有效的连接条件多表链接条件个数至少为（n-1）n为表的个数。 等值连接等值连接，连接条件用等号相连。 1select e.empno,e,ename,e.sal,d.dname from emp e,deptno d where e.deptno=d.deptno; 不等值连接连接条件中间不是由等号相连 1select e.empno,e.ename,e.sal,s.grade from emp e,salgrade s where e.sal between s.losal and s.hisal; 外连接外连接：通过外连接，把对于连接条件不成立的记录，仍然包含在最后的结果中左外连接：当连接条件不成立的时候，等号左边的表仍然被包含 a = b（+）右外连接：当连接条件不成立的时候，等号右边的表仍然被包含 a（+）= b 12345// 按部门统计员工人数，要求显示：部门号，部门名称，人数select d.deptno 部门号,d.dname 部门名称,count(e.empno) 人数from emp e,dept dwhere e.deptno(+)=d.deptnogroup by d.deptno,d.dname; 自连接通过表的别名，将一张表视为多张表 1234// 查询验工姓名和员工老板的姓名select e.ename 员工姓名，b.ename 老板from emp e,emp bwhere e.mgr=b.empno;//员工的老板号 = 老板的员工号 注意自连接存在的问题:不适合操作大表,会产生笛卡尔积层次查询优点:本质是一个单表查询,不涉及笛卡尔乘积原理,便于查找1234select level,empno,ename,sal,mgr from emp connect by prior empno=mgrstart with mgr is null order by 1; 子查询 子查询概述：使用子查询解决不能一步完成的查询（查询的嵌套） 123// 查询比scott工资高的员工信息select * from emp where sal&gt;(select * from emp where ename = &apos;SCOTT&apos;)； 子查询需要注意的10个问题： 子查询语法中的小括号 子查询的书写风格（方便阅读） 可以使用子查询的位置：where,select,having,from 不可以使用子查询的位置：group by 强调：from 后面的子查询 子查询和主查询可以不是同一张表 一般不在子查询中使用排序；但在Top-N分析问题中必须对子查询排序 一般先执行子查询再执行主查询；但是相关子查询例外 单行子查询只能使用单行操作符；多行使用多行 注意:子查询中是null的问题 可以使用子查询的位置：where 、select、having、from 相关子查询：将主查询中的值作为参数传递给子查询 123// 找出员工薪水大于本部门的平均薪水的员工select empno,ename,sal,(select avg(sal) from emp where deptno=e.deptno) avgsal from emp e where sal &gt; (select avg(sal) from emp where deptno=e.deptno); 不可以使用not in 来判断存在空值的集合。只要有空值，使用not in 永远都是假。 Reference: 慕课网－oracle 高级查询]]></content>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM 的分屏功能]]></title>
    <url>%2Fvim-split-screen.html</url>
    <content type="text"><![CDATA[整理并收集了一些Vim相关使用教程，人类史上最好的文本编辑器Vim，只有用过才知道。 分屏启动 Vim 使用大写的O参数来垂直分屏: 1vim -On file1 file2 ... 使用小写的o参数来水平分屏: 1vim -on file1 file2 ... 注释：n是数字，表示分成几个屏。 关闭分屏 关闭当前窗口: 1Ctrl+W c 关闭当前窗口，如果只剩最后一个了，则退出Vim: 1Ctrl+W q 分屏 上下分割当前打开的文件: 1Ctrl+W s 上下分割，并打开一个新的文件: 1:sp filename 左右分割当前打开的文件: 1Ctrl+W v 左右分割，并打开一个新的文件: 1:vsp filename 移动光标 Vi中的光标键是h, j, k, l，要在各个屏间切换，只需要先按一下Ctrl+W 把光标移到右边的屏: 1Ctrl+W l 把光标移到左边的屏中: 1Ctrl+W h 把光标移到上边的屏中: 1Ctrl+W k 把光标移到下边的屏中: 1Ctrl+W j 把光标移到下一个的屏中: 1Ctrl+W w 移动分屏 这个功能还是使用了Vim的光标键，只不过都是大写。当然了，如果你的分屏很乱很复杂的话，这个功能可能会出现一些非常奇怪的症状。 向右移动: 1Ctrl+W L 向左移动: 1Ctrl+W H 向上移动: 1Ctrl+W K 向下移动: 1Ctrl+W J 屏幕尺寸 下面是改变尺寸的一些操作，主要是高度，对于宽度你可以使用[Ctrl+W &lt;]或是[Ctrl+W &gt;]，但这可能需要最新的版本才支持。 让所有的屏都有一样的高度: 1Ctrl+W = 增加高度: 1Ctrl+W + 减少高度: 1Ctrl+W - 升级教程 以下是一篇比较好的Vim升级教程：简明Vim练级攻略]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志还是调试？]]></title>
    <url>%2Flogs-or-debug.html</url>
    <content type="text"><![CDATA[在这段时间的面试过程中，印象比较深的是一个面试官问到了关于 java 日志的问题，我当时只想了SLF4J 和 log4j，就简单说了一些日志在工作环境中的一些作用和日志的级别设置。面试官也主要提到了一些打日志的规范。这儿我想说一下日志打印的一些看法。 线程名 就像Ringo一样，线程名应该是Java里最被低估的功能之一了。因为其实它的表述性很强。那又怎样？就像我们的名字一样，我们会给它赋予一个含义。 线程名最有用的时候应该就是多线程的情况下了。许多日志框架都会记录当前方法调用所在线程的名字。不幸的是，一般看起来都是这样的：“http-nio-8080-exec-3″，这是线程池或者容器自动分配的线程名。 我经常听到有谣传称线程名是不可变的。当然不是。线程名就是你日志中最优质的不动产，你得确保自己能正确的使用它们。通常给它赋值会带上上下文的详细信息，比如说Servlet或者任务的名字之类的，以及一些动态的上下文信息比如用户ID。 这么做的话，你的代码看起来应该是这样的：1Thread.currentThread().setName(ProcessTask.class.getName() + “: “+ message.getID); 更高级的做法是引入一个ThreadLocal的变量，然后配置一个appender，自动把里面的信息输出到日志中。 当多个线程同时在往文件中写入日志而你需要关注其中某个线程的时候，这个功能尤其有用。如果你在一个分布式或者SOA环境中运行的话，这么做还会有一个额外的好处，下面我们很快就会看到。 分布式标识符 在SOA或者消息驱动的架构中，某个任务的执行可能会涉及到多台机器。这种架构下如果出了错要进行处理的话，要想知道到底发生了什么，这里所牵涉到的相关机器以及它们的状态就显得至关重要。很多日志分析器只是帮你把这些日志收集起来，它们假设你已经有一个唯一的标志符，可以用它来进行过滤。 从设计的角度来看，这意味着系统中每一个入站操作都需要有一个唯一的ID，处理过程中会一直携带着这个ID直到处理结束。这里如果使用持久性标识比如说用户ID之类的可能并不适合，因为在一个日志文件中一个用户可能会有多个请求在同时进行处理，这就很难提取出具体的某个处理流。UUID是个不错的选择，你可以把它存储到线程名或者TLS——ThreadLocal Storage里面。 不要使用循环 你经常会看到有在循环体中进行日志打印，这么做的前提是循环的次数是有限的。 如果不出什么问题的话当然还好。不过如果代码碰到一些异常的输入导致循环无法退出的话，这就不妙了。这可不止是循环无法结束的问题了，你的程序还一直在往磁盘或者网络中写入数据。 如果只是写到自己的设备中，结果可能就只是挂了一台服务器，但如果是一个分布式的环境，就可能就是一整个集群都瘫了。所以最好还是不要在循环里面打印日志，尤其是当涉及到异常处理的时候。 我们来看一个例子，这里是在循环中来打印异常的信息：12345678910void read() &#123; while (hasNext()) &#123; try &#123; readData(); &#125; catch &#123;Exception e) &#123; // this isn’t recommend logger.error(“error reading data“, e); &#125; &#125;&#125; 如果readData()抛出异常并且hasNext()返回true，这段代码就会不停在打印日志。一个解决方法就是不要每次都打印出来：123456789101112131415void read() &#123; int exceptionsThrown = 0; while (hasNext()) &#123; try &#123; readData(); &#125; catch &#123;Exception e) &#123; if (exceptionsThrown &lt; THRESHOLD) &#123; logger.error(“error reading data&quot;, e); exceptionsThrown++; &#125; else &#123; // Now the error won’t choke the system. &#125; &#125; &#125;&#125; 还有一个方法就是把日志操作从循环中去掉，在另外的地方进行打印，只记录第一个或者最后一个异常就好了。 未捕获的异常 维斯特洛有一道最后的防御墙，而你有Thread.uncaughtExceptionHandler。请确认你已经用上它们了。如果没有的话，你的异常可能这么没了，而你只能拿到很少的一些上下文信息，同时这些异常在哪打印，是否打印，你也不好控制。 如果你的代码出现异常却没有记录下来，或者记录下来了却没有相关的状态信息，那真是非常失败。 尽管在uncaughtExceptionHandler里面看似已经访问不了线程里面的任何变量了（它已经挂了），但你至少还有一个当前线程的引用。如果结合刚才提到的第一条建议的话，至少日志中还能打印出一个有意义的thread.getName()的值。 捕获外部调用的异常 只要你调用到了JVM以外的接口，那么发生异常的概率就大大提升了。这包括WEB服务，HTTP,数据库，文件系统，操作系统或者其它的一些JNI调用。你得把每一个调用都当成一个定时炸弹来处理。 大多数情况下，外部调用之所以会失败是因为传入了错误的参数。为了修复这些问题，把这些请求参数记录到日志中是非常有必要的。 你可能不想记录错误信息，而是直接去抛出异常，这样做也没有问题。不过这么做的话，你要尽可能把相关的参数都收集起来，放到异常信息里面去。 你得确保在上一层调用中捕获了异常并且记录到了日志里。123456try &#123; return s3client.generatePresignedUrl(request);&#125; catch (Exception e) &#123; String err = String.format(“Error generating request: %s bucket: %s key: %s. method: %s&quot;, request, bucket, path, method); log.error(err, e); //这里你也可以抛出一个异常，记得把ERR信息带上。&#125; 日志还是调试？ 在合适的时候你可以使用调试。如果你一直都是用调试的话，那就继续吧。我个人倾向于使用日志，尽管有的时候环境允许我进行实时的调试。当我找到我在苦苦追寻的问题的原因后，我会检查一遍记录日志的语句，然后删掉它们。它们已经完成了自己调试的使命，现在已经不再需要它们了。不过后来我发现，我自己在写一些以前删掉过的日志记录的语句，至少我自己是有这样的经历。为什么呢？这是因为修复一个BUG并不意味着所有的BUG都修复了。BUG是永远也改不完的。但是散落在文件各处的日志记录给查找下一个BUG的相关信息增加了难度。换句话说，日志文件中的干扰信息太多了，这就是为什么我删掉它们的原因。那同样的，我们是不是可以把已经通过的单元测试也给删掉呢？这会节省掉很多编译的时间，不是吗？当然，我们不会这么做。 用一句话来总结下？选择日志还是调试，随你个人的喜好吧，也得看你在查找什么类型的问题。 Reference: 日志打印的5点建议]]></content>
      <tags>
        <tag>沉淀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 MySQL 分页]]></title>
    <url>%2Fanalysis-mysql-limit.html</url>
    <content type="text"><![CDATA[为什么想去说一下这个问题，一言以蔽之，就是越往后分页，LIMIT语句的偏移量就会越大，速度也会明显变慢。 因为 MySQL 提供了Limit语法，相比于Top语法，Limit语法要显得优雅了许多。使用它来分页是再自然不过的事情了。最开始的写法：1SELECT * FROM table ORDER BY id LIMIT offset, rows; 第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目，所以当数据量达到百万级的时候，查询效率会明显很慢。以下是我总结的一些优化方法： 通过子查询的方式1SELECT * FROM table WHERE id &gt;= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10; 子查询的方式要设置id为索引。因为子查询是在索引上完成的，而普通查询是在数据文件上完成的，所以子查询的效率会远高于普通的查询。 通过 between…and 的方式 1SELECT * FROM table WHERE id BETWEEN 1000000 AND 1000010; 如果需要查询 id 不是连续的一段，最佳的方法就是先找出 id ，然后用 in 查询 1SELECT * FROM table WHERE id IN(10000, 100000, 1000000...); 索引对 MySQL 的in语句也是有效的。 所以优化查询搜索的关键还是看检索字段有没有走索引，我们可以通过查看 sql 语句的执行计划对 sql性能进行调优。]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机IMEI失效或者显示null的处理方式]]></title>
    <url>%2Freset-imei-code.html</url>
    <content type="text"><![CDATA[刷机有风险，发烧友们需谨慎。看我是如何把我的一块即将变砖的手机拯救回来的。 话说刷机带来的危害，我觉得的最大是一些深度定制的机型，你如果强制刷机，有可能会造成IEMI丢失，变为null，IEMI是国际移动设备身份码的缩写，国际移动装备辨识码，是由15位数字组成的”电子串号”，它与每台手机一一对应，而且该码是全世界唯一的。而IEMI的丢失，会导致移动运营商不能够识别手机型号，从而出现手机无法使用移动数据，不能读取SIM卡的现象。 解决方式：重新生成串号，恢复IMEI。 MTK65XX国产机写串号工具 在手机端安装【移动叔叔工具箱】。 将串号工具生成的MPOB-001文件重命名为IMEI.bak并移动到手机SD卡的根目录下，然后配合移动叔叔工具箱来用，运行移动叔叔工具箱，恢复IMEI，重启即可。 注意，使用【移动叔叔工具箱】手机需要有 root 权限。]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我毕业了也离职了]]></title>
    <url>%2Fgraduated-and-quit.html</url>
    <content type="text"><![CDATA[祝贺大家毕业了，你们不一定会因为学校感到自豪，但是学校永远以你们为荣。 – 《哈师大软件学院毕业典礼》 毕业了 其实说到学校的好坏牛逼，我虚荣心最强的时候也就是高考结束后在县城高中张榜的时候，觉得考到好大学的学生前途将会多么多么的无限风光，而我当时只想把贴出来的我的名字撕掉。现在觉得好的大学确实可以得到更好的社会资源分配和更高标准的对学生的要求，我越来越觉得一个人的精神内核才是最根本的，你颓唐就是颓唐，你顽强就是顽强。 写这篇博文的时候，我已经收到了学弟从学校寄过来的毕业证学位证，仪式感还是很强的，毕业了，大学的句号也就此画上了。大学室友的兄弟们，从呼兰的＃506 到江北的＃203，一起创业，一起探讨，我相信历久铭心的兄弟情义，天南海北，愿我们都有为梦想负责的勇气。 小吐槽 当然，我还是想去吐槽一下所谓的软件工程专业，有人把这个领域的本质总结为：“How to program if you cannot？”（如果你不会编程，那么你如何编程？）我觉得这句话说得很好，因为我发现软件工程这整个领域，基本就是吹牛扯淡卖“减肥药”的，所以才会有那么多的人，学了计算机专业，还会再去报个培训班。总有人提出一套套的所谓“方法论”或者“原则，似乎标榜这些就可以写出高质量低成本的软件，这就跟减肥药的广告一样：不用运动，不用节食，一个星期瘦20斤。实习了一年，对这种感觉越来越深，我觉得所有的方法论都应该像程序一样，需要结合上下文，需要特定的应用环境。想起一个笑话：两夫妻睡觉发现床上有跳蚤，身上被咬了好多大包。去买了号称“杀伤率100%”的跳蚤药，撒了好多在床上。第二天早上起来，发现又被咬了好多新的大包。妻子责怪丈夫，说他没看说明书就乱撒。结果丈夫打开说明书一看，内容如下： 本跳蚤药使用方法： 抓住跳蚤 掰开跳蚤的嘴 把药塞进跳蚤嘴里 合上跳蚤的嘴 我发现很多软件工程的所谓方法论失败之后的借口，跟这跳蚤药的说明书很像。 我离职了 很多人都不理解为什么我会刚毕业就离职，天时地利人和我似乎一样没占到。可是就在跟老板提完辞职，并且被允许可以在下个月办理离职手续的时候，我的开心已经溢于言表。我当然承认在这儿的实习一年有多超值，学习了很多技能，交了很多朋友，影响最深的还是做事的态度。我是个默默无闻的人，风吹草动我都会探头张望，又有朋友要离职了，都会让我内心波澜，沉寂好一阵子，和老板 one to one 谈话的时候，也很庆幸老板会以一个朋友的身份跟我讲一些琐碎的杂事和他自己的程序员生涯，我很感激这份缘分。 归根结底我为什么要离开呢？我需要一些自己的时间，并去做一些自己喜欢的事情，我需要一些臭味相投的朋友，这又让我想起我了我的大学，很多个日日夜夜熬夜看视频学编程，我不想辜负那份努力，也喜欢那个方向。 小白说，语言不该是选择工作的决定性因素，语言只是个工具。我倒觉得，语言更像是一种材料，举个例子，一个做木匠的让他去做铁匠，不一定能做好，或者说根本就是完全不同的两种职业。语言有特性，就像每种材料的属性一样，都是不一样的，一些应用广泛的语言，更是被开源社区发展成了一种平台，比如 html5，java 都是一个平台。 感谢小白的挽留，感谢极宇舟天的同学们的信任，感谢学长的指导，很惭愧，只做了一点微小的工作，谢谢大家。 做一个好工程师 工程的本质不是创造，而是去风险化，有时候一个好的解决方案，未必采用了最新的技术和框架，而是看上去朴实无华，功力都包涵在背后的细节里。就像顶尖高手打的斯洛克台球，每一杆都平淡无奇，只是因为上一杆的回球太到位。 有了锤子想找钉子是很正常的原始冲动，但我们必须认识到，创造力对于程序员这个职业来讲，是锦上添花的东西。如果你没有强大的工程能力，那么创造力也不过是无本之木。所以扎扎实实的把工程基础打好，这是最根本的。 在此基础上，我比较推荐程序员采用内外两条线来培养自己。在公司内的项目上采取相对保守的策略，尽力把稳定性做到最好，培养出自己卓越的工程能力；然后在公司外的开源项目和自己的独立项目上，采用一些新的技术、实践一些新的想法、充分发挥自己的创造力，梦想还是要有的，对吧。 这样做最明显的好处是，你可以了解到新技术和激进方案的优缺点，从而在进行方案选型时，有更多的依据；还有一个职业发展上的好处：如果不是主负责人，公司的项目往往不能代表你的能力；但独立项目却可以作为一个非常好的能力证明出现在你的简历里边。 你可以是一个身怀绝技的手艺人，在自己家里你尝试各种手法各种风格的个人作品；但当你参与颐和园这种级别的工程时，好好的把自己负责的石头雕成总设计师要求的样子就好 —— 毕竟这个时代一个人已经很难负责整个项目了。这就是我所理解的程序员的工匠精神。 摘自：《程序员到底是一个什么职业？》 我早就开始了四海为家的程序员生活，不是么？]]></content>
      <tags>
        <tag>Life-Talk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 环境下markdown转pdf]]></title>
    <url>%2Fubuntu-markdown-to-pdf.html</url>
    <content type="text"><![CDATA[方法一：在 chrome 上使用马克飞象编辑器对markdown 文件进行编写预览，完成之后在预览模式一侧右键，选择打印，然后就可以选择纸张大小，margin，打印页数，然后默认保存为PDF格式即可。我是我认为比较方便快捷的一种方式。方法二：安装 retext1sudo apt-get install retext 软件安装成功后，ctrl+L 即可进入实时预览模式，点击菜单栏中的打印，也可以保存为PDF格式的文件。]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 将字段中首字母大写]]></title>
    <url>%2Fmysql-upcase-first-letter.html</url>
    <content type="text"><![CDATA[英文的单纯一般首个字母都是大写的，虽然MySQL中有转换大小写字母的函数，但是那是对整个字段都进行转换，如果需要将字段中首字母大写却没有直接的函数，不过我们可以使用其它的函数将字符串切割，再转换为大写，最后再拼接字符串即可。 一使用到的函数： CONCAT(str1,str2)：字符连接函数 UPPER(str)：将字符串改为大写字母 LOWER(str)：将字符串改为小写字母 LENGTH(str)：判定字符串长度 SUBSTRING(str,a,b)：提取字段中的一段，从字符串str的第a位开始提取，提取b个字符 LEFT(str,n)：提取字符串最左边的n个字符 RIGHT(str,n)：提取字符串最右边的n个字符（该例未用到） 解决思路 用LEFT单独将首字母取出并用UPPER换成大写 确定字段的长度，并用SBUSTRING取出从第二位到最后一位的所有字段备用。 用CONCAT连接上边的两个值 update表中字段的值即可。 解决方法1update table set field = concat(UPPER(left(field,1)),substring(field,2,(length(field)-1)));]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse Maven Spring SpringMVC Mybatis 整合]]></title>
    <url>%2Feclipse-maven-spring-springmvc-mybatis-example.html</url>
    <content type="text"><![CDATA[看慕课网【Java高并发秒杀API】的系列课程时很受益。所以想着仿着来使用：Mavan-Spring-SpringMVC-Mybatis 的架构。本示例是在：Ubuntu15 上实现的；Windows 上安装 Maven 将不太相同。 Maven Install 2016年09月10日 更新：较新版 Eclipse 都有集成 Maven，所以并不需要安装 Run command sudo apt-get install maven, to install the latest Apache Maven. Run command mvn -version to verify your installation. Where is Maven installed?The command apt-get install the Maven in /usr/share/mavenThe Maven configuration files are stored in /etc/maven Eclipse Maven Plugin - m2e 2016年09月10日 更新：较新版 Eclipse 都有集成 Maven，所以并不需要安装 open Eclipse -&gt; Help -&gt; click “Install New Software” -&gt; click “add” Name:m2e Location:http://download.eclipse.org/technology/m2e/releases click “ok” -&gt; click “Maven Integration for Eclipse” -&gt; click “Next” restrat Eclipse config m2e -&gt; Window -&gt; Preferences -&gt; Maven -&gt; Installations -&gt; click “Add…” -&gt; select Maven Create a Maven Project File -&gt; New -&gt; New Maven project select “Use default Workspace location” select “maven-archetype-j2ee-simple” input info -&gt; Finish 选中项目右键菜单中选择Properties -&gt; Project Facets -&gt; select “Dynamic Web Module” Version “3.1” Tips: 如果在 Project Facets 选择版本时“can not change”，可以在项目目录下手动修改 .settings/org.eclipse.wst.common.project.facet.core.xml 文件配置 项目自动生成的 web.xml 版本较低，手动修改 12345&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1" metadata-complete="true"&gt;&lt;/web-app&gt; 项目结构 12345678├── src ├── main | ├── java //java源代码 | ├── resources //配置资源文件 | └── webapp //web文件 | └── test └── java //junit测试 pom.xml ConfigGithub-maven-mybatis-spring-springmvc pom.xml12345678910111213141516&lt;!-- junit4 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 日志 --&gt;&lt;!-- 实现slf4j接口整合 --&gt;&lt;!-- JDBC MySQL Driver --&gt;&lt;!-- DAO框架 mybatis --&gt;&lt;!-- Servlet API --&gt;&lt;!-- 1 Spring 核心依赖 --&gt;&lt;!-- 2 Spring DAO依赖 --&gt;&lt;!-- 3 Spring web相关依赖 --&gt;&lt;!-- 4 Spring Test相关依赖 --&gt; logback.xml Config12345678910111213&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- encoders are assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="info"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt;&lt;/configuration&gt; Mybatis ConfigGithub-maven-mybatis-spring-springmvc mybatis-config.xml12345678910&lt;configuration&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGeneratedKays 获取数据库自增主键 --&gt; &lt;setting name="useGeneratedKeys" value="true" /&gt; &lt;!-- 使用列别名替换列名 --&gt; &lt;setting name="useColumnLabel" value="true" /&gt; &lt;!-- 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;/settings&gt;&lt;/configuration&gt; Spring ConfigGithub-maven-mybatis-spring-springmvc spring Spring-DAO Config1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!-- 1 数据库配置文件位置 --&gt;&lt;context:property-placeholder location="classpath:jdbc.properties" /&gt;&lt;!-- 2 数据库连接池 --&gt;&lt;!-- Employee DB data source. --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClassName&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.dburl&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!-- c3p0连接池 私有属性 --&gt; &lt;property name="maxPoolSize" value="$&#123;jdbc.maxPoolSize&#125;" /&gt; &lt;property name="minPoolSize" value="$&#123;jdbc.minPoolSize&#125;" /&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name="autoCommitOnClose" value="false" /&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name="checkoutTimeout" value="1000" /&gt; &lt;!-- 获取连接失败重试次数 --&gt; &lt;property name="acquireRetryAttempts" value="2" /&gt;&lt;/bean&gt;&lt;!-- 设计原则：约定大于配置 --&gt;&lt;!-- 3 配置 SqlSessionFactory 对象 --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置mybitis 全局配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml" /&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="com.moma.dmv.entity" /&gt; &lt;!-- 扫描sql配置文件 mapper 需要的xml --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml" /&gt;&lt;/bean&gt;&lt;!-- 4 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlsessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="com.moma.dmv.dao" /&gt;&lt;/bean&gt; Spring-Service Config1234567891011121314151617&lt;!-- 扫描service包下 所有使用注解的类型 --&gt;&lt;context:component-scan base-package="com.moma.dmv.service" /&gt;&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt;&lt;!-- 配置基于注解的声明式事务 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;!-- 使用注解控制事务方法的优点1：开发团队达成一致约定，明确标注事务方法的编程风格2：保证事务方法的执行时间尽可能短，不要穿插其他网络操作RPC/HTTP请求或者剥离到事务方法外部3：不是所有的方法都需要事务，比如只有一条修改操作，只读操作不需要事务控制--&gt; Spring-Web Config12345678910111213141516171819202122&lt;!-- 1:开启springMVC 注解模式 --&gt;&lt;mvc:annotation-driven /&gt;&lt;!-- 2 静态资源默认servlet配置 1 加入对静态资源的处理 js gif png 2 允许使用“/”做整体映射 --&gt;&lt;mvc:default-servlet-handler /&gt;&lt;!-- 3:配置jsp 显示ViewResolver --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 决定视图类型，如果添加了jstl支持（即有jstl.jar），那么默认就是解析为jstl视图 --&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt; &lt;!-- 视图前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 视图后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt;&lt;/bean&gt;&lt;mvc:resources location="/resources/" mapping="/resources/**" /&gt;&lt;!-- 4:扫描web相关的bean --&gt;&lt;context:component-scan base-package="com.moma.dmv.web" /&gt; DAO Mapper Example1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.moma.dmv.dao.InfoDao"&gt; &lt;select id="queryById" resultType="Info" parameterType="long"&gt; &lt;![CDATA[ select id,`key`,`value` from info where id = #&#123;id&#125; ]]&gt; &lt;/select&gt; &lt;select id="queryAll" resultType="Info"&gt; &lt;![CDATA[ select id,key,value from info limit #&#123;offset&#125;,#&#123;limit&#125; ]]&gt; &lt;/select&gt;&lt;/mapper&gt; web.xml Config123456789101112131415&lt;servlet&gt; &lt;servlet-name&gt;dmv-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml spring-service.xml spring-web.xml mybatis -&gt; spring -&gt; springMVC --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dmv-dispatcher&lt;/servlet-name&gt; &lt;!-- 默认匹配所有的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; JUnit Example123456789101112131415161718192021222324252627import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.moma.dmv.dao.InfoDao;import com.moma.dmv.entity.Info;RunWith(SpringJUnit4ClassRunner.class)ContextConfiguration(locations = &#123; "classpath:spring/spring-dao.xml" &#125;)public class InfoDaoTest &#123; @Resource private InfoDao infoDao; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Test public void testQueryById() throws Exception &#123; long id = 1; Info info = infoDao.queryById(id); logger.info(info.toString()); &#125;&#125; Reference: zyf.im MKyong-How to install Maven on Ubuntu Java之道-使用Eclipse构建Maven项目 (step-by-step)]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给网站添加保存到移动设备主屏的 icon]]></title>
    <url>%2Fadd-website-icons-to-the-home-screen.html</url>
    <content type="text"><![CDATA[By adding an iOS icon, anyone who decides to save your webpage to the home screen of their iPhone, iPad, or Android will see a nice app-like icon rather than an image of your page. Here is a table of the current iOS icon sizes from Apple: iPhone 6/7, iPhone SE iPad / iPad Mini iPad Pro iPhone 6/7 Plus 120×120 152×152 167×167 180×180 For Android icons you’ll want to follow these specifications: Android Regula Android Hi-Res 1128×128 192×192 123456&lt;link href=&quot;http://www.yoursite.com/apple-touch-icon.png&quot; rel=&quot;apple-touch-icon&quot; /&gt;&lt;link href=&quot;http://www.yoursite.com/apple-touch-icon-152x152.png&quot; rel=&quot;apple-touch-icon&quot; sizes=&quot;152x152&quot; /&gt;&lt;link href=&quot;http://www.yoursite.com/apple-touch-icon-167x167.png&quot; rel=&quot;apple-touch-icon&quot; sizes=&quot;167x167&quot; /&gt;&lt;link href=&quot;http://www.yoursite.com/apple-touch-icon-180x180.png&quot; rel=&quot;apple-touch-icon&quot; sizes=&quot;180x180&quot; /&gt;&lt;link href=&quot;http://www.yoursite.com/icon-hires.png&quot; rel=&quot;icon&quot; sizes=&quot;192x192&quot; /&gt;&lt;link href=&quot;http://www.yoursite.com/icon-normal.png&quot; rel=&quot;icon&quot; sizes=&quot;128x128&quot; /&gt; Make the first apple one the 120 x 120. If you don’t want to create all these images, you should at least create the larger resolution ones. That way they’ll look good on the hi-res devices. Reference: zyf.im How to Add Icons to iPhone, iPad &amp; Android to Your Website]]></content>
      <tags>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 修改提交历史]]></title>
    <url>%2Fgit-modify-commit-history.html</url>
    <content type="text"><![CDATA[在使用 Git 时，我们经常会遇到修改本地提交记录的情况。比如：修改最近一次提交记； 还比如：将多次小的 commit 合并成一个大的 commit。这种做发有利也有弊，利在：review 代码时，可以按功能看，可以省去 review 一些前期写的无效的代码；弊是：一次提交修改过多，如果有问题，不利于调试。 修改最近一次提交记录修改提交说明1git commit --amend 然后就可以进入 vim 编辑提交信息，保存退出即可。 改被提交的快照 如果你完成 commit 后又想修改被提交的快照，增加或者修改其中的文件。先执行 git add 命令，将修改的文件添加到缓存区，然后运行 git commit -amend 命令，该命令会获取你当前的暂存区的内容一并提交到最后一次 commit 例如：新加了一个文件 new_file.cpp ，想要合并到最后一次提交，过程如下：12git add new_file.cppgit commit --amend 也可以直接运行下面的命令，不过要小心，不要提交了多余的文件1git commit -a -- amend 将文件从本次提交中移除、 如果想把已经 commit 的文件从这次 commit 移除的话，运行命令：123git reset [-soft] HEAD~1 # -soft可加可不加，默认就是soft选项git checkout -filename # 要从本次提交移除的文件名git commit -m &quot;new commit&quot; 修改多个提交记录 要修改历史中更早的提交，你必须采用更复杂的工具。Git 没有一个修改历史的工具，但是你可以使用 rebase 工具来衍合一系列的提交到它们原来所在的 HEAD 上。 依靠这个交互式的 rebase 工具，你就可以停留在每一次提交后，如果你想修改或改变说明、增加文件或任何其他事情。你可以通过给 git rebase -i 命令以交互方式进行 rebase。 例如，你想修改最近三次的提交说明，或者其中任意一次，你必须给 “git rebase -i提供一个参数，指明你想要修改的提交的父提交。例如HEAD~3是指从 HEAD 指针到 HEAD+3 的位置，也就是最近第 4 次提交。所以想修改最近 3 次提交，你需要指明第 3 次提交的父提交（第4次提交）即HEAD~3`。运行命令：1git rebase -i HEAD~3 再次提醒这是一个衍合命令，也就是 HEAD~3 到 HEAD 范围内的每一次提交都会被重写，不管你是否修改提交说明 SHA-1 的值都会发生变化。所以千万不要涵盖你已经推送到中心服务器的提交。这么做会使其他开发者产生混乱，因为你提供了同样变更的不同版本。运行该命令后进入交互界面，类似：123456789101112131415161718pick fecb551 Init the view modelpick bb199a0 Update the versionpick bc5cd9d Add new method# Rebase f77f585..fecb551 onto f77f585## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.# If you remove a line here THAT COMMIT WILL BE LOST.# However, if you remove everything, the rebase will be aborted.# Note that empty commits are commented out 根据命令提示，就可以进行历史更改了。很重要的一点是你得注意这些提交的顺序与你通常通过 log 命令看到的是相反的。如果你运行 log，你会看到下面这样的结果：123pick bc5cd9d Add new methodpick bb199a0 Update the versionpick fecb551 Init the view model 修改指定提交 例如：只修改最近第3次提交说明可以进行如下更改：1234reword fecb551 Init the view modelpick bb199a0 Update the versionpick bc5cd9d Add new method... 保存并退出编辑器，rebase 命令在衍合到第 3 次提交时会进入提交说明编辑页面，在此进行编辑新的提交说明，保存并退出即可，rebase 命令继续进行直至完成全部衍合操作。 如果你不仅想要修改提交说明，还要更改提交，可以进行如下更改：1234edit fecb551 Init the view modelpick bb199a0 Update the versionpick bc5cd9d Add new method... 保存并退出编辑器，rebase 命令在衍合到第三次提交时会等待你提交新的更改，并提示你修改完成后运行 git commit –amend 命令，然后运行 git rebase –continue 继续进行 rebase 直至完成全部衍合。 重排提交 你也可以使用 git rebase -i 命令对提交历史彻底重排或删除提交。例如你想删除”Update the version”这个提交，并且修改其他两次提交的顺序，可以将：1234pick fecb551 Init the view modelpick bb199a0 Update the versionpick bc5cd9d Add new method... 改为：12pick bc5cd9d Add new methodpick fecb551 Init the view model 然后保存并退出编辑器，此时 rebase 命令会先应用 bc5cd9d (Add new method)，然后应用 fecb551 (Init the view model) bb199a0 Update the version这次提交。 然后保存并退出编辑器，此时 rebase 命令会先应用 bc5cd9d (Add new method)，然后应用 fecb551 (Init the view model)，接着停止。执行完上诉操作，你已经修改了这些提交的顺序，并且删除了bb199a0 (Update the version) 这次提交。 合并提交 git rebase -i 命令还可以将一系列提交合并成一个提交。从上面的脚本提示中可以看到 s, squash = use commit, but meld into previous commit 提示。如果用 squash 修饰提交就可以进行提交之间的合并，例如可以将脚本修改成这样：123pick fecb551 Init the view modelsquash bb199a0 Update the versionsquash bc5cd9d Add new method 保存并退出编辑器，rebase 命令会应用全部三次变更然后进入编辑器来归并三次提交说明。当你保存之后，你就拥有了一个包含前三次提交的全部变更的单一提交。 拆分提交 拆分提交实际上就是撤销一次提交，然后分多次进行重新提交。例如你想将三次提交中的中间一次拆分。将 ”Update the version” 拆分成两次提交：”Update the version1” 和 ”Update the version2”，可以进行如下修改：123pick fecb551 Init the view modeledit bb199a0 Update the versionpick bc5cd9d Add new method 当 rebase 到 bb199a0 时，会进入等待你提交新 commit 的状态，这时看可以运行 git reset HEAD^ 对当前提交进行重置，然后分别运行 git add 命令添加想要提交的文件，分别进行 git commit，最后运行 git rebase –continue 完成所有衍合。整体过程如下：123456git reset HEAD^git add file1git commit -m &apos;Update the version1&apos;git add file2git commit -m &apos;Update the version2&apos;git rebase --continue 执行完上诉操作，提交历史看起来就像这样了：12341c002dd Add new method9b29157 Update the version235cfb2b Update the version1f3cc40e Init the view model 再次提醒，这会修改你列表中的提交的 SHA 值，所以请确保这个列表里不包含你已经推送到共享仓库的提交。 Reference: GLGJing’s Blog]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人民的名义]]></title>
    <url>%2Fthe-name-of-the-people.html</url>
    <content type="text"><![CDATA[这次回学校毕业答辩，空闲时间追了一个剧《人民的名义》,随着剧情一点一点地推进，突然开始很心疼，心疼的不是别人，也不是剧中的人物，因为那毕竟是虚构的，不是真实的人生，而是我们自己，这才是真真实实的生活与生命。看了剧中的情节，真是大开眼界，不论是祁同伟的一人得道，鸡犬升天，还是赵瑞龙的草菅人命亦或是丁义珍在饭局上左右逢源，逢场作戏，近似人生赢家。甚至一个处级干部赵德汉，都能狂贪几个亿，要知道，除了国家级领导人，下面就是部司厅局处科，小小一个处级干部，都能贪污几个亿？你知道天朝有多少处级干部吗？呵呵，我还真查了下，毛爷爷说，没有调查就没有发言权，参考链接在这里，处级干部约60万，一个人一亿的话，不敢想象，当然了，不能这么悲观，要相信党相信政府，我还是有这觉悟的。现如今大家都说日子难过，现在知道了吧？为什么我们日子难过了，在人民的名义中各种现象也只是社会真实情况的冰山一角吧？假设现实情况比电视剧中所要努力描绘的良好社会略槽糕一点点，那么日子难就很正常了，我想说，不正常才奇怪哩。 现在好多人都说房价高，那么房价为什么会高呢？只有两种情况，一种是你赚钱的速度赶不上房价的上涨速度，另一种是货币贬值了，房价虚高，只不过刚需接盘侠们是货币贬值的最后承受者，没有享受到任何一点点货币贬值带来的收益，要知道货币贬值对所有人来说并不是公平的，有人说，我手里的钱贬值了，那有钱人手里的钱一样也贬值了呀？只能说你too young，too simple，钱就像是流水，就像一条河，同样的一河水，在水的上游和下游能一样吗？同样货币这个贬值链，就像一条河水一样，也分上游下游，货币流到上游的人的手里的时候，并没有贬值，而是和以前价值一样，那么这些占据上游的都是哪些人呢？发大水的是央行，上游的人是各大国有银行、国企、国家各部委、权力掌控者等，中游是商业银行、民营企业、利益既得者等，经过层层盘剥，当这个贬值链流到下游的时候，又是哪些人呢？就是这个底层劳动人民、刚需接盘侠，之所以房价会高涨，是因为没有任何一个产业能够锁住这么海量的贬值货币，唯有将这些海量的货币存之于楼市，才能尽量减少对其他行业的伤害，试想通胀不是流向楼市，而是流向日常生活必须品，那个个吃不上饭可是天大的问题了，但是一部分人住不上房却不是致命的，即使这些住不上房的人闹腾也不用操心，因为那些有房的会代政府来管教他们，你说此话怎讲，君不见，房价略降，全国各地的售楼处都出现了业主打杂情况吗？这不就是有房产者、既得利益者在代国家管教这些无房产者吗？房价想降很难，一是政府不愿意，房价降了，海量的贬值货币往哪藏呢？二是有产者不愿意，买不起房，大家不会联合起来打杂售楼处，但是房价下降，已买房的人则会联合起来上书政府，要求政府救市，更有甚者，直接联合起来打杂售楼处，还有天理吗？法制社会存在这种流氓行径？没有任何理由，就是因为房价下降，就可以任意耍流氓了？呵呵，这些人没有得到严肃的处理，已经代表了政府的态度，睁一只眼闭一只眼，这些人就都没事了。 追剧的过程中，一把手在剧中出现了无数遍，我英文不好，不要欺负我，我想请问一把手英文怎么翻译呢？大英帝国、美帝国家人民的词典中，有一把手这个词吗？有海外待过的人，还望不吝赐教。民选政府与任命制有着本质的区别，民选出来的领导人要对人民负责，同理，任命制选出来的领导人只对任命他的人负责。这种本质的区别，注定了人民有着本质的不同地位，该得到什么样的对待都是自己争取而来，你笑着看资本主义国家人民游行、示威、罢工，那就不要忽视人家赢得的地位。有付出才有收获，老祖宗留下来的话，是有道理的。任命制在我看来只能听天由命了，就像古代皇帝一样，如果是个雄才大略、英明神武的皇帝，那么人民生活相对来说更幸福一点，如果碰到昏庸无能、荒淫无度的主，那人民的生活能不水深火热吗？这不就是靠天吃饭吗？和现在的任命制有啥区别？一把手喜欢你，就提拔你，至于你对人民来说是福是祸，又有几个一把手会关心呢？ 这部剧叫《人民的名义》，恕我愚钝，我不知道这里面哪一点代表了人民的名义，我只看到草根出身的处长在第一集就被干掉了，我只看到同样草根出身的祁同伟和高小琴最后同样被干掉了，而那个利用权势不断打压祁同伟的人呢？梁璐包括他的父亲最后毫发无损，这就是人民的名义吗？人民的孩子总是最先和最后被干掉吗？我分明看到的就是有权有势同样能逍遥法外，我不知道现实中有多少丁义珍，但是我敢保证现实中的丁义珍绝对不会在国外的餐馆刷盘子，处处美化、处处讨喜，编剧们都不觉得恶心吗？像沙瑞金和侯亮平在现实中毕竟是少数，再进一步讲，现实中有多少丁义珍、赵立春（副国级，国家领导人啊、领导人啊、领导人啊）、赵瑞龙、刘新建、陈清泉等等这些人呢？恐怕远不止电视中所表现的那些吧？ 在剧情最后部分，侯亮平劝降祁同伟，莫名的心疼起祁同伟来，那个和天下棋，愿用自己的命去胜天半子的人，也许在祁的心中是这么想的，你侯亮平算什么东西，也敢来劝降我？在祁的身边，虽然不乏师长，以及同一师门的师弟师妹，但是又有几个打心眼里瞧得起看得起他的呢？他想过靠自己的努力来出人头地，在大学里学习努力，成绩优异，并且还是校学生会主席，但是有什么用呢？毫无关系背景的他，眼睁睁的看着那些能力平平甚至低于他的的校友们分配到了大城市，而他却被掌控权力的梁璐的父亲下放到了穷山沟沟里，只因他没接受梁璐的追求，即便他没有放弃，主动请缨去做缉毒工作，因为这个工作更危险，更容易立功，凭借着过人的勇气和努力，他成为了缉毒英雄，但是结果呢？梁璐的父亲，凭借手握大权，借着权力以惜才为名义，阻止让他升迁，硬生生的将他继续困于穷山沟之中。最终，这个内心孤傲的人向现实屈服了，这才有了那在汉东大学的著名一跪，祁同伟啊是个被时代抛弃的人、是个被权力毁掉的人、是个草根出身不断向上爬却死在权力脚下的人，直到最后事发败露，他也没有屈服，用他的话说，这个世界上没有人能够审判他，即便可能被判无期徒刑，苟延残喘，但是并没有，他没有投降，没有屈服，而是选择自杀结束生命。 剧中还有一个现象被大家忽略了，那就是高育良和李达康的女儿都出国了，这就是官二代的命啊。而侯亮平和陈海这种所谓的中产呢？孩子只能挤在国内上些垃圾学校，甚至侯亮平妻子给孩子报的一个补习班，那老师居然是个电工，但是招生工作火热火热的，这和现代的学区房、各种补习班真是不谋而合。幸好这个老师被侯亮平一眼识破，谁又能说现实中存在诸多没有被识破的呢？如果现实中没有侯亮平去戳穿老师的嘴脸呢？岂不是依然可以大摇大摆的顶着补习班的名义继续招摇撞骗。如果现实中的所有官员子女都在国外接受教育，他们对人民又怎么会负责呢？从小接受资本主义国家的理念、文化、习俗、教育等等，怎么比得了土生土长的中国人对人民的了解程度呢？这些人谁又能保证其不在官爸爸富爸爸的扶持下走上统治人民的路子呢？当他们成长为了统治阶级，只要自我舒适，谁管你人民死活，大不了贪了几个亿全家移民罢了。]]></content>
      <tags>
        <tag>Life-Talk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《如何高效学习》]]></title>
    <url>%2Freading-how-to-efficient-learning.html</url>
    <content type="text"><![CDATA[Learn More, Study Less？&lt;!-- more --&gt; 最近两天读了斯科特·扬的《如何高效学习》这本书，至于为什么会去读这本书，因为关于这本书的介绍和这本书自己的引言都让我觉得它能为我创造实际的价值。读过了之后也觉得作者的很多观点我在不同的好书中都见过，让我深深感觉到大牛的学习方式都是很相似的，牛人都是通过把知识联系到实际问题，联系到自己，联系到现实生活，来更好地理解知识或解决问题。 这本书主要介绍 整体学习法，我的理解就是在知识之间建立关联，形成信息网络，有助于更好地理解知识。同时介绍了整体学习的一些方法，比喻法和内在化是作者认为比较好的方法；整体学习的顺序是 获取-&gt; 理解-&gt;扩展-&gt;纠错-&gt;应用。应用和给人讲解（费曼技巧）能更好地帮助我们掌握知识，接下来我以全书的顺序捋一下本书的主要思路和观点。 第一章：整体性学习法 整体性学习法可以归纳为这样的顺序：获取—理解—拓展—纠错—应用—测试。我觉得作者用了大量的语言和配图就是想表达的观点就是学习的时候要善于联想，把相关的知识由点连成线，连成面。当然，上面归纳的这种学习顺序不是死的，是需要学习者把这种精神领悟到，不断内化，形成自己的东西。 要发挥想象力，思考的越多，这部分知识点你理解的越深刻，以后也会实际运用的更好。 第二章：整体性学习技术 这一章主要是很多技巧性的东西，对于技巧这个话题，每个人都有自己的技巧，不用生搬硬套别的方式方法，作者只提供了一些思路，当然你觉得作者的提供的技巧不错也可以学习，包括获取阶段的速度技巧等等。 作者将信息分类，针对不同类别提出了不同的技巧来记忆。介绍了四个部分的方法： 获取知识: 快速阅读 笔记流联系观点 比喻 内在法 图表法随意信息的处理 联想法 挂钩法 信息压缩技术知识拓展 实际应用 模型纠错 以项目为基础学习 第三章：超越整体性学习 这一章主要是强调优秀的学习习惯对学习的重要性，其中有三点给我印象很深：能量管理、绝不拖延和批处理 。还有关于费曼技巧的介绍，下面是费曼技巧的流程： 第一步：选择要学习的概念首先选好你打算深入理解的概念，拿一张空白纸，在最上方写下概念的名称。第二步：设想你是老师，正在试图教会一名新生这个知识点这一步你要假想自己费尽口舌让一名毫无这方面知识的学生听懂，并把你的解释记录下来。这一步至关重要，因为在自我解释那些你理解或不理解的知识过程中，你会理解得更好，而原先不明白的地方也得以理清。第三步：当你感到疑惑时，返回去吧每当你碰到难题感到疑惑时，别急着往下走，学习不是单行道，回过头来，重新阅读参考材料、听讲座或找老师解答，直到你觉得搞懂了为止，然后把解释记到纸上。第四步：简单化和比喻如果你的解释很啰唆或者艰涩，尽量用简单直白的语言重新表述它，或者找到一个恰当的比喻以更好地理解它。 最后想说的话： 现在都流行什么番茄工作法，一次工作25分钟，就好像很厉害了的样子。其实想想高中的时候，一坐一晚上几个小时都能精力高度集中完成任务。只是随着智能手机和互联网的发展，我们经常被一些无关痛痒的消息打断，导致我们难以集中精力，注意力阀值降低。提高自己的注意力阀值，be focus，你最终发现番茄工作法什么的弱爆了。]]></content>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 目录树]]></title>
    <url>%2Flinux-directory-tree.html</url>
    <content type="text"><![CDATA[linux有那么多目录，总是让新手摸不清头脑，其实，等你用了一段linux后，再去看一下它的文件组织方式，也没有第一眼看到的那么复杂。而且，各个linux发行版本都遵循相同的标准，所以，就算了解它的各个文件如何组织是一次痛苦的重生，那也是只需要痛苦一次的，这是值得的。 由于linux发行版本众多，如果每个人都按自己的想法来组织文件，那么，必然造成管理上的混乱，而且没有人希望自己接触到一个新的linux发行版本，发现目录配置方法居然跟以前自己学的完全不一样。所以，关于linux下文件组织方式的标准就在大家翘足企首，忘眼欲穿中出炉了——即FHS(Filesystem Hierarchy Standard)。 FHS 定义了三层目录下面应该放什么： / (root，根目录) 与开机系统有关 /usr (UNIX software resource) 与软件安装/执行有关 /var (variable) 与系统运作过程有关 FHS定义文件的组织方式如图所示： 根目录(/) 根目录是整个系统最重要的目录，主要与开机，还原，系统修复等操作相关。 /usr /usr 是UNIX Software Resource 的缩写，而不是user 的缩写！FHS建议所有软件开发者应该将他们的数据合理地放置在该目录的子目录下，而不要自行新建该软件自己独立的目录。这个目录有点类似与Windows 系统的C:\Windows\和C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘空间。 /var /usr是安装时会占用较多的硬盘空间，而/var则是在系统运行以后，逐渐占用硬盘空间。因为/var目录主要针对常态性变动的文件，包括缓存(cache)，登陆文件(logfile)以及某些软件运行所产生的文件，包括程序文件(lockfile，runfile)，或者MySql的数据库文件等。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 日常应用安装总结]]></title>
    <url>%2Fubuntu-install-daily-application.html</url>
    <content type="text"><![CDATA[ubuntu 日常应用安装总结 壹. 中文输入法 搜狗输入法下载地址： http://pinyin.sogou.com/linux/?r=pinyin 进入到搜狗输入法下载位置 1sudo dpkg -i sogoupinyin_*.deb 如果报错，需要联网，通过下面这条命令修复缺失的组件 1sudo apt-get -f install 重新执行安装命令 1sudo dpkg -i sogoupinyin_*.deb 需要修改系统默认输入法，点击桌面右上角的开关按钮，系统设置（System Config）-&gt;语言支持（Language Support）-&gt; 键盘输入法系统从ibus改成fcitx(fcitx是支持搜狗输入法的中国人自制的输入法系统) ，找到“添加或删除语言…”打开后找到Chinese(Simple)（简体中文是也），打钩。应用到整个系统，桌面右上角，找到并点击注销（log out），即可。 二. Google chrome 将下载源加入到系统的源列表 1sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/ 导入谷歌软件的公钥，用于下面步骤中对下载软件进行验证 1wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add - 对当前系统的可用更新列表进行更新 1sudo apt-get update 执行对谷歌 Chrome 浏览器（稳定版）的安装 1sudo apt-get install google-chrome-stable 三. netease-cloud-music 下载地址：http://s1.music.126.net/download/pc/netease-cloud-music_0.9.0-2_amd64.deb 依次执行以下命令：123sudo dpkg -i netease-cloud-music*sudo apt-get -f installnetease-cloud-music 四. aptitude1sudo apt install aptitude 五. vim1sudo aptitude install vim 六. git1sudo aptitude install git 七. mysql1sudo aptitude install mysql-server 八. javajdk download 123sudo add-apt-repository ppa:webupd8team/java sudo apt-get update sudo apt-get install oracle-java8-installer 九. unrar1sudo apt-get install unrar 十. Unity启动器可以移到屏幕底部123gsettings set com.canonical.Unity.Launcher launcher-position Bottom 恢复到左侧gsettings set com.canonical.Unity.Launcher launcher-position Left 十一. 安装atom123sudo add-apt-repository ppa:webupd8team/atom sudo apt-get update sudo apt-get install atom 安装 IDEA 下载地址 这里我选择 Ultimate without jdk 版下载 下载完成，解压到 /opt/ 1sudo tar -zxvf ideaIU-20* -C /opt 然后进入它的 bin 目录，执行 ./idea.sh 启动]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何阅读书籍]]></title>
    <url>%2Fhow-to-reading.html</url>
    <content type="text"><![CDATA[摘要这篇文章从如何阅读书籍出发，简单讨论了如何选择书籍、是否阅读原版和阅读数量这几个常见问题，然后自己的阅读问题进行了分析和总结。 注意 “如何阅读” 指 “What to read” 而非 “How to read”，Mortimer J. Adle r的 怎样阅读一本书 对How to read有着精彩的描述。 “书籍”指非小说（Non-fiction）类书籍。目标我是一个功利主义者（Utilitarianism），因此我认为阅读的目标在于为自己创造实际价值，所以： 我不会因为某本书看起来很有趣就去阅读（机会成本）。 也不会因为很多人推荐某本书就去阅读（从众）。 更不会因为某本书难就去阅读（追求智商优越感）。 一本书值得阅读，当且仅当： 它可以直接为我创造价值。 它可以间接为我创造价值。 我的阅读目标：形成T型知识结构：专业知识尽可能深入，专业周边知识尽可能精炼。 专业书籍专业知识尽可能深入。 我是一个软件开发者（Software Developer），因此这里的专业书籍均和软件开发有关。 从一本经典书籍出发，深度优先遍历它的引用列表，通过书评和摘要了解这些引用书籍，再根据自己的实际情况决定自己的阅读次序。 这里以 代码大全 为例（为了方便和一致性，这里使用英文书名）：123456789101112131415161718192021222324252627Code Complete：软件构建全程最佳实践指南。||----How to Solve it：系统解决问题。||----Conceptual Blockbusting：跳出思维的壁垒。||----Mythical Man Month：软件工程不能做什么。||----Programming Pearls：极简算法手册。 | |----The Science of Programming：编写正确的程序。 | |----Writing Efficient Programs：编写高效的程序。||----Pragmatic Programmer：高效程序员的实践。||----Refactoring：如何改进自己的代码。||----Programming on Purposes：用正确的编程模式处理问题。||----Software Tools：用合适的抽象封装复杂度。 | |----The Practice of Programming：极简编程风格指南。 | |---- Writing Solid Code：减少调试的时间。 | |---- Elements of Programming Style：极简编程风格指南。 可以发现，通过 代码大全 一本书，经过短短两层引用联系，几乎可以找到2004年以前所有软件开发的经典书籍。事实上，我阅读的80%以上的软件开发经典书籍，都源自于 代码大全 的引用列表。 这种方法的好处： 简单直接：相对于从茫茫书海里找出10本经典书籍，找1本经典书籍再从它的引用列表里面找到20本经典书籍要容易的多； 质量保证：靠谱书籍的引用书籍的质量一般都很高； 发现一些被忽视的经典：相当一部分的书籍随着时间的流逝而淡出人们的视野，但这并不代表它们本身没有价值，例如：Programming on PurposesSoftware ToolsThe Science of ProgrammingWriting Solid CodeWriting Efficient Programs等等… 这些书或者绝版，但它们都对我的软件开发理念产生了巨大影响。 形成知识体系：引用书籍彼此具有天然的联系，这使得创建知识体系更加容易。我认为这种方法适用于任何需要严肃阅读的领域： 锚点：找到一本经典书籍。 撒网：了解该书引用列表中的书籍。 收网：根据自己实际需要，精读相关书籍。 非本专业书籍专业周边知识尽可能精炼。 对于专业周边知识，了解关键概念及指导思想即可。 不需要，也没有必要对专业周边知识进行深入了解。 “Know what” is enough, “Know how” is expensive. 以我2年前编写手机应用，学习用户体验为例： 分别在现实中（身边有几个很不错的交互设计师）和线上（Quora和知乎）进行提问和搜索，得到一个书单。 按照下面的原则过滤书单： 去掉教科书和大部头。 去掉包含大量原理或论证的书籍。 保留结论型书籍。 保留指南型书籍。 总结出书单，迅速的阅读并找到关键点。 给大家看的设计书：CRAP原则，字体与配色。 设计心理学：心智模型，心智摩擦，最小惊讶。 交互设计之路：为什么需要交互，交互有哪些坑。 Tapworthy：具有实际操作性的移动平台交互设计指南。’ 了解设计的人可能认为上面的书单过于初级——没错，它们都是结论型或指南型书籍，没有原理，也没有论证——但这正是对于我这样的非专业者所需要的书籍：我不需要知道这些知识是怎么来的，知道怎么用足矣。 此外，受价值驱动，而非兴趣——大多数情况下兴趣只是把自己脱离当前困境的接口。 学习型书籍学习型书籍是一种元（Meta）方法书籍：这类书籍用于提升学习能力，换句话说，就是缩短吸收知识所需要的时间。 这类书籍我只读过下面的几本，效果有但不明显： 学习之道：冥想，体会。 如何阅读一本书：检视阅读，主题阅读。 Learn more, study less：建立知识体系及联系。 需要注意的是，不要陷入到寻求最优学习方法的误区——Best is the worthest enemy of better。 如何在翻译版和原版做选择？ 优先选择翻译版。计算机书籍这种描述精确知识的书籍更是如此。 此外，如果阅读中出现难以理解的问题，不要下意识的把其归咎于翻译问题——多数情况是理解问题。 为什么还有那么多人阅读原版？ 因为翻译版还没出版。 知识的价值有其时效性。 逼格。越多越好？我经常逛豆瓣，豆瓣有一个很有意思的现象就是人们喜欢去比较自己每年读书的数量，或者是截图炫耀自己读过几千本书云云。 我在这里酸一下：书的数量并没有什么参考价值，就好比无法用盖一栋大楼的砖数评价这栋大楼的质量；换个说法，Effort 不等于 Progress。 关键在于读过书的质量，吸收的程度，以及创造的价值。 此外，盲目追求读书的数量会带来另一个问题——浅尝辄止。本应花在专业书籍上的时间被分配到其它无关紧要的事情上，导致该学好的没学好，没必要的学了一滩但用不上。 总结 形成 T 型知识结构：专业知识尽可能深入，专业周边知识尽可能精炼。 按照引用列表和作者深入阅读专业书籍。 利用结论型/指南型书籍精炼阅读专业周边书籍。 不断强化自己的按需学习能力。 不一定非要阅读原版。 读书并非多多益善。 读书之前回答下面几个问题： 这本书能给自己带来什么改变？ 自己是否需要这种改变？ 如果均为 Yes，继续；如果有一个 No，砍掉。 转载出处: http://lucida.me/blog/on-reading-books/]]></content>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站图片轮播淡入淡出]]></title>
    <url>%2Fwebsite-picture-carousel-fade.html</url>
    <content type="text"><![CDATA[基于bootstrap 的图片轮播，也可以用div 替换图片，灵活性很好。 html12345678910111213141516&lt;div id=&quot;carousel&quot; class=&quot;carousel slide carousel-fade&quot; data-ride=&quot;carousel&quot;&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#carousel&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Carousel items --&gt; &lt;div class=&quot;carousel-inner&quot;&gt; &lt;div class=&quot;active item&quot;&gt;&lt;a rel=&quot;nofollow&quot; href=&quot;/special/black-friday&quot;&gt;&lt;img src=&quot;static/new_index/image/black-friday.jpg&quot;&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;a rel=&quot;nofollow&quot; href=&quot;/out/1356720817746&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;static/new_index/image/Bloomingdales.jpg&quot;&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;a rel=&quot;nofollow&quot; href=&quot;/out/1356722837948&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;static/new_index/image/asos.jpg&quot;&gt;&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- Carousel nav --&gt; &lt;a class=&quot;carousel-control left&quot; href=&quot;#carousel&quot; data-slide=&quot;prev&quot;&gt;&lt;img src=&quot;static/new_index/image/left.png&quot;&gt;&lt;/a&gt; &lt;a class=&quot;carousel-control right&quot; href=&quot;#carousel&quot; data-slide=&quot;next&quot;&gt;&lt;img src=&quot;static/new_index/image/right.png&quot;&gt;&lt;/a&gt;&lt;/div&gt; css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.carousel-fade .carousel-inner .item &#123; -webkit-transition-property: opacity; transition-property: opacity;&#125;.carousel-fade .carousel-inner .item,.carousel-fade .carousel-inner .active.left,.carousel-fade .carousel-inner .active.right &#123; opacity: 0;&#125;.carousel-fade .carousel-inner .active,.carousel-fade .carousel-inner .next.left,.carousel-fade .carousel-inner .prev.right &#123; opacity: 1;&#125;.carousel-fade .carousel-inner .next,.carousel-fade .carousel-inner .prev,.carousel-fade .carousel-inner .active.left,.carousel-fade .carousel-inner .active.right &#123; left: 0; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);&#125; .item:hover&#123; cursor: pointer;&#125;.carousel-control &#123; display: none; height: 96px; width: 72px; opacity: 0.3; color: #fff; margin: 7%; background-color: #000000; border: #000000; padding-top: 20px; z-index: 2;&#125;.carousel-control:hover &#123; color: #fff; outline: 0; opacity: 0.6;&#125;.carousel-indicators li&#123; height: 16px; width: 16px; margin:0 8px; background-color: #fff !important; opacity:0.8 !important;&#125;.carousel-indicators .active &#123; width: 16px; height: 16px; margin:0 8px; background-color: #68c4cb !important; border-color: #68c4cb;&#125; js12345678910111213&lt;script&gt;$(function()&#123; $(&apos;.carousel&apos;).carousel(&#123; interval: 5000 &#125;); $(&apos;.carousel-fade&apos;).hover(function()&#123; $(&apos;.carousel-control&apos;).css(&quot;display&quot;,&quot;block&quot;); &#125;); $(&apos;.carousel-fade&apos;).mouseleave(function()&#123; $(&apos;.carousel-control&apos;).css(&quot;display&quot;,&quot;none&quot;); &#125;);&#125;);&lt;/script&gt;]]></content>
      <tags>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php mail 函数发送邮件]]></title>
    <url>%2Fphp-mail-function.html</url>
    <content type="text"><![CDATA[当然你可以通过php ,在自己的站点制作一个反馈表单. 1234567891011121314151617// 收件人地址(此处只可以写一个地址,写多个地址,只有最后一个地址生效) $to = &apos;xxxx@qq.com&apos;; // 邮件标题 $subject = &apos;botao email&apos;; // 邮件正文 $message = &quot;some message...&quot;; // 当发送 HTML 电子邮件时，请始终设置 content-type $headers = &apos;MIME-Version: 1.0&apos;.&quot;\r\n&quot;; $headers .= &apos;Content-type:text/html;charset=iso-8859-1&apos;.&quot;\r\n&quot;; // 更多报头 //from 这个地址 是对方可以看到邮件是谁发出的,填写正确邮件地址的话,这个邮件可以回复 $headers .= &apos;From: &lt;xxxx@qq.com&gt;&apos;.&quot;\r\n&quot;; // 所以,如果要想给多人群发邮件,可以 cc 如下 $headers .= &apos;Cc: xxx@qq.com&apos;.&quot;\r\n&quot;; $headers .= &apos;Cc: xxx@qq.com&apos;.&quot;\r\n&quot;; //调用 mail函数,执行发送 mail($to, $subject, $message, $headers); Tips: 邮件正文部分是可以拼接 html 元素的, 这样就可以发送数据报表了,而不是采用附件的形式发送报表,既然可以拼接html ,当然也可以去写一些行内样式了。1234567$message = &quot; &lt;table style=&apos;这儿可以写一些样式&apos;&gt; &lt;tr&gt; &lt;td&gt; some data.. &lt;td&gt; &lt;tr&gt; &lt;/table&gt;&quot;; 参考： http://www.w3school.com.cn/php/php_mail.asp]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装navicat及常见问题解决]]></title>
    <url>%2Fubuntu-install-navicat.html</url>
    <content type="text"><![CDATA[如果系统中没有安装wine组件则执行./start_navicat命令则系统毫无反应，没有错误日志等，因此需要安装wine和修改脚本… 安装navicat 下载Navicat，网址：http://www.navicat.com/en/download/download.html 进入下载目录，解压压缩包：tar -zxvf navicat11_mysql_en.tar.gz 打开解压后的目录，会看到 start_navicat文件 运行他就可以了 执行命令： ./start_navicat 。执行命令后便启动navicat 常见问题解决：如果系统中没有安装wine组件则执行./start_navicat命令则系统毫无反应，没有错误日志等，因此需要安装wine和修改脚本： 安装wine：sudo apt-get install wine 修改start_navicat文件：找到winboot，改成wineboot后保存，然后重新执行./start_navicat命令]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL 语句优化方法]]></title>
    <url>%2Fmysql-optimization-method.html</url>
    <content type="text"><![CDATA[以下是对sql语句优化方法的一些总结。 尽量避免非操作符的使用，在索引上使用 NOT，&lt;&gt; 等操作符，数据库管理系统是不会使用索引的，可以将查询语句转化为可以使用索引的查询。 避免对查询的列的操作，任何对列的操作都可能导致全表扫描，这里所谓的操作包括数据库函数，计算表达式，查询时要尽可能将操作移至等式的右边，甚至去掉函数。 避免不必要的类型转化，需要注意的是，尽量避免潜在的数据类型转换。如将字符型数据与数值型数据比较，会自动将字符进行转换，从而导致全表扫描。 增加查询的范畴限制。避免全范围的搜索。 合理使用IN 与EXISTS。例如：有A，B两个表，他们分别使用如下的情况： 当只显示一个表的数据如 A，关系条件只加一个ID时，使用IN更合适，SQL语句如下： 1select * from A where id in (select id from B) 当只显示一个表的数据如 A，关系条件不只一个列，例如关系条件涉及到的列为ID，col1 时，使用IN 就不方便了，可以使用EXISTS，SQL语句如下： 1select * from A where EXISTS (select 1 from B where id = A.id and col1 = A.col1) in 与 exists 的区别：in 是把外表和内表作hash连接，而exists 是对外表作loop 循环，每次loop循环再对内表进行查询。一直来认为exists 比in 效率高的说法是不准确的。如果查询的两个表大小相当，那么用in 和exists 差别不大。如果两个表中一个较小，一个是大表，则子查询大表用exists，子查询小表用in。 尽量去掉&lt;&gt;。尽量去掉&lt;&gt;，避免全表扫描，如果数据是枚举值，且取值范围固定，则修改OR 或者 IN a&lt;&gt;0 改为a&gt;0 or a]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说 Java 集合类:HashMap 是如何设计的? 是如何解决什么冲突的?]]></title>
    <url>%2Fjava-hashmap.html</url>
    <content type="text"><![CDATA[说说 Java 集合类:HashMap 是如何设计的? 是如何解决什么冲突的? HashMap 是基于哈希表的Map接口的非同步实现,在Java 编程语言中,最基本的结构就是两种，一个是数组，另一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造,HashMap 也不例外,HashMap 实际上是一个链表的数组的数据结构，每个元素存放链表头节点的数组,即数组和链表的结合体.HashMap 底层就是一个数组结构,数组中的每一项又是一个链表。 当新建一个 HashMap 的时候，就会初始化一个数组，Entry 就是数组中的元素，每个Map.Entry 其实是一个 key-value 对，它持有一个指向下一个元素的引用，这就构成了链表。 HashMap 的存储。当我们往HashMap 中put 元素的时候，先根据key的hashCode 重新计算hash 值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置已经存放其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果该数组位置上没有元素，就直接将元素放到数组中的位置上。 HashMap 的读取。从HashMap 中 get 元素时，首先计算key 的hashCode，找到数组中对应位置的某一元素，然后通过key 的equals 方法在对应位置的链表中找到需要的元素。 HashMap 的 resize（rehash）。当HashMap 中的元素越来越多的时候，hash 冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap 的数组进行扩容，数组扩容这个操作也会出现在ArrayList 中，这是一个常用的操作，而在HashMap 数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。那么HashMap什么时候进行扩容呢？当 HashMap中的元素的个数超过数组大小loadFactor 时，就会进行扩容，loadFactor 的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过160.75 = 12 的时候，就把数组大小扩展为2*16 = 32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 HashMap 中元素的个数，那么预设元素的个数能够有效提高 HashMap 的性能。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种排序算法]]></title>
    <url>%2Fsome-sort-algorithm.html</url>
    <content type="text"><![CDATA[排序方法有： 插入排序（直接插入排序，希尔排序），交换排序（冒泡排序，快速排序），选择排序（直接选择排序，堆排序），归并排序，分配排序（箱排序，基数排序）。 选择排序算法实现10个1~100 随机数字的排序，代码如下： 123456789101112131415161718192021222324252627282930313233public class SelectSort&#123; // 选择排序方法 public static void SelectionSort(int[] num) &#123; for (int i =0;i&lt;num.length -1;i++) &#123; int m = i; for (int j = i+1;j&lt;num.length;j++) &#123; if (num[j] &lt; num[m]) m = j; &#125; if (i != m) swap(num,i,m); &#125; &#125; // 用于交换数组中索引为 i,j 的元素 private static void swap(int[] num,int i,int j) &#123; int t; t = num[i]; num[i] = num[j]; num[j] = t; &#125; public static void main(String[] args) &#123; // 定义一个数组 int[] num = new int[100]; for (int i = 0;i &lt; num.length; i++) &#123; num[i] = (int) (Math.random() * 100) + 1; &#125; // 排序 SelectionSort(num); for (int i = 0;i &lt; num.length; i++) &#123; System.out.println(i); &#125; &#125;&#125; 冒泡排序算法代码如下 1234567891011121314151617181920212223242526import java.util.Random;import java.util.Array;public class BubbleSort &#123; public static void main(String[] args) &#123; int[] arr = new int[100]; for (int i = 0; i &lt; arr.length; i++) &#123; Random ran = new Random(); arr[i] = ran.nextInt(100); &#125; System.out.println(Arrays.toString(arr)); // 冒泡排序 for (int i = 0;i &lt; arr.length -1;i++) &#123; for (j = 0; j &lt; arr.length -i-1;j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; int t = arr[j]; arr[j] = arr[j+1]; arr[j+1] = t; &#125; &#125; &#125; // 冒泡排序结束 System.out.println(Arrays.toString(arr)); &#125;&#125; 快速排序算法代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class QuickSort &#123; public static void sort(int[] num) &#123; quickSort(num,0,num.length -1); &#125; // 快速排序方法 private static void quickSort(int[] num,int left,int right) &#123; if (left &lt; right) &#123; int s = num[left]; int i = left; int j = right +1; while (true) &#123; // 向右找大于s的数的索引 while (i +1 &lt; num.length &amp;&amp; num[++i] &lt; s) ; while (j-1 &gt; -1 &amp;&amp; num[--j] &gt; s) ; // 如果 i &gt;= j, 退出循环 if (i &gt;= j) &#123; break; &#125; // 否则交换索引 i和j 的元素 swap(num,i,j); &#125; num[left] = num[j]; num[j] = s; // 对左边进行递归 quickSort(num,left,j-1); // 对右边进行递归 quickSort(num,j+1,right); &#125; &#125; // 交换 数组中索引为i,j 的元素 private static void swap(int[] num,int i,int j) &#123; int t; t = num[j]; num[i] = num[j]; num[j] = t; &#125; public static void main(String[] args) &#123; int[] arr = new int[100]; for (int i = 0; i &lt; arr.length; i++) &#123; Random ran = new Random(); arr[i] = ran.nextInt(100); &#125; sort(arr); for (int i =0;i&lt;arr.length;i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单了解递归函数]]></title>
    <url>%2Funderstanding-recursive-functions.html</url>
    <content type="text"><![CDATA[什么是递归？什么情况下会使用递归? 递归作为一种算法在程序设计语言中广泛使用，是指函数/过程/子程序在运行过程中直接或间接调用自身而产生的重入现象。 递归算法一般用于解决三类问题 数据的定义是按递归定义的。（Fibonacci 函数） 问题解决按递归算法实现。（回溯） 数据的结构形式是按递归定义的。（树的遍历，图的搜索） 下面两个程序是使用递归实现的小栗子 1234567891011121314151617181920/*** 计算二进制中1的个数* N为奇数，二进制中的1的个数等于N/2的个数* 例子* num =13* 1. getBinary(13/2=6)+1;* 2. getBinary(6/2=3)+1;* 3. getBinary(3/2=1)+1+1;* 4. getBinary(1)+1+1; getBinary(1) 返回1，所以与后面两个1相加是3**/public static int getBinary(int num)&#123; if (num == 1) return 1; if (0 == num%2)&#123; // 为偶数 return getBinary(num/2); &#125; else &#123; return getBinary(num/2)+1; &#125;&#125; 1234567891011121314151617181920/*** 求 n!***/public class Factorial &#123; public static void main(String[] args) &#123; long n = 7; System.out.println(); &#125; public static long doFactorial(long n) &#123; if (n &lt; 1) &#123; System.out.println(&quot;error&quot;); return 0; &#125; else if (n == 1 || n ==2 ) &#123; return n; &#125; else &#123; return n * doFactorial(n-1); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安利一些好用的在线工具]]></title>
    <url>%2Fshare-some-good-tools.html</url>
    <content type="text"><![CDATA[这里收集一些开发中很好用的在线工具，会不断补充，欢迎大家补充。 markdown 转 微信公众号格式 程序员DD - 在线工具 Linux 学习手册 支持搜索，特别好用 Linux shell 脚本攻略 前端调试 Analyze robots.txt 分析 robots.txt 文件 Google PageSpeed Insights 谷歌 页面速度分析 Google Strctured Data Test 谷歌 结构化数据检测 gtmetrix.com - Analyze your site’s speed and make it faster. 协作 百度脑图 Codelf 变量命名神器 云服务器 Digitalocean （有推荐码）数据海洋 BandwagonHost （有推荐码）班瓦工 UFOVPS 有 HK 地区，自己在用 格式校验 正则表达式测试和调试工具 json 校验工具 cron 表达式生成器和反解析工具 服务器监控 Uptime Robot 宕机监控 fake data 随机生成美国人 identity 虫部落 一个纯粹的搜索知识、技术和经验分享平台 bazier 贝塞尔曲线 在线测试 冷熊简历 MarkDown 简历工具，整合了内容模板，PDF 生成 …]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Safe And Sound]]></title>
    <url>%2Fsafe-and-sound.html</url>
    <content type="text"><![CDATA[寻找和突破心障的方法是寻找一种对美好世界和美好人生的渐进解，首先我们承认对这个世界的终极一无所知，但是我们知道近一点儿比远一点儿更好，我们不知道完美世界的图景是什么，但是我们可以一点儿一点儿努力去接近它。我们不知道目标在哪里，但是从渐进解出发，我们永远可以找到一个方向，一个清晰的方向，它可以告诉我们，我们一直在前进，一直没有停息。 如果要我一句话总结我的实习生活，我想应该是欢喜，毕竟乐在其中。像我这种菜得抠脚的毛头小子怎么会欢喜，16年7份到一家创业的互联网公司实习，接近八个月的时间，公司里人来人往，看多了也觉得不过如此吧，没什么大不了的，是我涉世未深。不大不小的需求也做了好多了，有时候也会觉得身心俱疲。跟老板谈过几次话，也得到了不少做事的心得，可以说，在北京实习我最大的收获就是做事的态度。 去年365天，在家５天，大三结束就来北京，我确实是幸运的，遇到了一个好的平台，遇到一个优秀的师兄Yifan，也遇到老友Jaden，这让我的工作生涯很平顺，也很愉快，优秀的人都有看书的习惯，跟这些优秀的人在一起，也会去模仿，去接近，去学会思考。看书不仅是一个追求数据增长的过程，最重要的是追求模型增长。这个世界没有绝对真理，所有的信息都散落在世界的各个角落。我们慢慢地读书学习成长的过程，就是一个不断汲取这些东西的一个过程，随着你越来越逼近这个世界的真相，你就会越来越有能力，所以核心还是怎么看待这个世界的问题。当然我也有一群关系很好的实习的小伙伴，后来，他们都离开了，让我沮丧了好一阵子，现在他们大都在新的公司入职，朝九晚六，替他们感到开心。 在这个碎片化的时代，我们花大量时间刷微信，微博，知乎，今日头条，把属于自己的时间财富交给各种各样的timeline，成为了在信息世界中等着被feed 的人，像被圈养…慢慢的，当我们习以为常，而信息渠道质量下降，则会让我们开始散失获取价值信息的能力，直至散失学习和思考能力，最根本的原因不是因为沉迷，所有沉迷于一种坏习惯的人都是因为没有真正值得做事情，如果真正有这样一种事情让他全情投入，那么根本不会沉迷于这么多无聊的事情之中而无法自拔。所以我已经开始有耐心去泡在博客园里，或者去读一些书，至少，开始行动是个好事。 公司里谁工作做的怎么样，别的人心里都清楚，甚至连和你技术毫不相关的运营的心里也清楚。所以就会有各种俯视和仰视，无论什么时候，首先自己要平视自己，要清楚你所做的一切哪些是你真正学习到的知识，哪些是在重复纠缠，哪些又是在做给别人看的。看了一些《重构》的时候，再回过头看看自己的写的代码，有一百个心思想去重写一下，为了让项目不繁琐可维护，为了以后不让项目组的同事在背后骂，为了自己做事的态度。但是能做的也是在一定的范围内努力做出一些改变，对于更大范围的事，挣扎也没用，还是要明白妥协和明哲保身，当然是指保证项目正常运行。 我一直自诩是一个理想主义者，和Cloud争执过很多次，想说服他来北京，他想让我去上海，我觉得必须知道每天工作的意义，究竟做的是什么，他的回应却是，在哪不都是写代码嘛，没什么不一样的，似乎觉得他说的没有什么不对，我们都建设互联网中的某一个节点。 再过一个月我就要回学校准备毕业答辩了，踏踏实实实习了这么久，进步很慢，但总是在持续进步，但愿自己刚刚开始的程序生涯能够无关风月，寂静欢喜，顺便说一句，这段在北京的日子简直过得太糟了，这应该不是生活本来的样子，至少不是我想要的生活的样子。]]></content>
      <tags>
        <tag>Life-Talk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 二维数组按照其中某个字段进行排序]]></title>
    <url>%2Fphp-array-sort-by-key.html</url>
    <content type="text"><![CDATA[根据指定字段排序二位数组，保留原有键值，降序12345678910111213141516171819/** * @param $arr @输入二维数组 * @param $var @要排序的字段名 * return array */ private function myArrsort($arr, $var)&#123; $tmp=array(); $rst=array(); foreach($arr as $key=&gt;$trim)&#123; $tmp[$key] = $trim[$var]; &#125; arsort($tmp); $i=0; foreach($tmp as $key1=&gt;$trim1)&#123; $rst[$i] = $arr[$key1]; $i++; &#125; return $rst; &#125;]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 使用过程中的相关总结]]></title>
    <url>%2Fgit-about-use.html</url>
    <content type="text"><![CDATA[Git是目前世界上最先进的分布式版本控制系统，尤其是它极其强大的分支管理，以下是我在开发中的一些总结，会不断补充。 git 忽略文件权限 1git config core.filemode false 回退到上一个版本 1git reset --hard HEAD^ 回退之后，想回到原来的版本，只要记得commit_id 就可以，commit_id 可以通过 git reflog 命令来找到。 1git reset --hard commit_id]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些常用的css相关总结]]></title>
    <url>%2Fsome-css-summary.html</url>
    <content type="text"><![CDATA[在日常开发中，常用到的一些css 技巧总结，会不断补充。 单行文本溢出显示省略号 123overflow: hidden;text-overflow:ellipsis;white-space: nowrap; 多行文本溢出显示省略号 1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden; 字体声明 1234font-face &#123; font-family: &apos;raleway-regular&apos;; src:url(&quot;./fonts/Raleway-Regular.ttf&quot;);&#125; 图片在容器中居中 123456789101112.index-pic-div &#123; display: table-cell; vertical-align: middle; height: 150px; width: 250px; text-align: center;&#125;.index-pic-div&gt;img &#123; max-width: 120px; max-height: 100px; margin: 0 auto;&#125; 背景图 123background-image: url(/static/image/indexbrand/lanebryant.png);background-repeat: no-repeat;background-position: center; 计算 1min-height: calc(100% - 152px);]]></content>
      <tags>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义滚动条样式]]></title>
    <url>%2Fcustom-scroll-bar-styles.html</url>
    <content type="text"><![CDATA[如果觉得浏览器自动渲染的滚动条难看的话，你当然可以自定义滚动条样式。 自定义滚动条demo http://www.xuanfengge.com/demo/201311/scroll/css3-scroll.html 123456789101112131415161718192021/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/::-webkit-scrollbar&#123; width: 16px; height: 16px; background-color: #F5F5F5;&#125;/*定义滚动条轨道 内阴影+圆角*/::-webkit-scrollbar-track&#123; -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3); border-radius: 10px; background-color: #F5F5F5;&#125;/*定义滑块 内阴影+圆角*/::-webkit-scrollbar-thumb&#123; border-radius: 10px; -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3); background-color: #555;&#125;]]></content>
      <tags>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测url是否含参数]]></title>
    <url>%2Fcheck-url-has-parameters.html</url>
    <content type="text"><![CDATA[检测url是否带参，并且补加参数的解决办法 1((strpos($url, &apos;?&apos;) !== false) ? &apos;&amp;&apos; : &apos;?&apos;); 以下是一个较为全面的检查方法12345678910111213141516171819202122232425&lt;?php//原始url$old_url = $_SERVER[&quot;REQUEST_URI&quot;];//检查链接中是否存在 ?$check = strpos($old_url, &apos;?&apos;);//如果存在 ?if($check !== false)&#123; //如果 ? 后面没有参数，如 http://YITU.org/index.php? if(substr($old_url, $check+1) == &apos;&apos;) &#123; //可以直接加上附加参数 $new_url = $old_url; &#125; else //如果有参数，如：http://YITU.org/index.php?ID=12 &#123; $new_url = $old_url.&apos;&amp;&apos;; &#125;&#125;else //如果不存在 ?&#123; $new_url = $old_url.&apos;?&apos;;&#125;echo $new_url;?&gt;]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 相关总结]]></title>
    <url>%2Flinux-summary.html</url>
    <content type="text"><![CDATA[一些Linux常用命令相关总结，会不断补充。 修改文件夹权限（递归设置） 1sudo chmod 765 filename -R 查找相关端口进程 1lsof -i:8080 通过游览器共享文件 1python -m SimpleHTTPServer 9999 .gz.tar 解压/压缩 1234# 解压tar zxvf FileName.tar.gz# 压缩tar zcvf FileName.tar.gz DirName 查看内存情况 1free -m 查看系统情况 12lsb_release -auname -a 上一次ssh 连接 1!ssh]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 开发技巧]]></title>
    <url>%2Fmysql-dev-skill.html</url>
    <content type="text"><![CDATA[主要涉及：JOIN 、JOIN 更新、GROUP BY HAVING 数据查重/去重 INNER JOIN、LEFT JOIN、RIGHT JOIN、FULL JOIN(MySQL 不支持)、CROSS JOIN- 这是在网上找到的非常好的一篇博文，图解 jion 语句 [CODING HORROR-A Visual Explanation of SQL Joins](https://blog.codinghorror.com/a-visual-explanation-of-sql-joins/) - join 的数据选取范围 更新使用过滤条件中包括本身的表- 更新 t1 t2 表中 col_a 重复的字段 1234567UPDATE t1 aa JOIN(SELECT b.col_aFROM t1 a INNER JOIN t2 b ona.col_a = b.col_a)bb on aa.col_a = bb.col_aSET col_a = &apos;hi&apos;; 查询重复数据、删除重复数据- 利用 GROUP BY 和 HAVING 查询重复数据 123SELECT col_a, COUNT(*)FROM t1GROUP BY col_a HAVING COUNT(*) &gt; 1 - 删除重复数据，对于相同数据保留 ID 最大的 12345678DELETE aFROM t1 a JOIN (SELECT col_a,COUNT(*),MAX(id) AS idFROM t1GROUP BY col_a HAVING COUNT(*) &gt; 1)b ON a.col_a = b.col_aWHERE a.id &lt; b.id;]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 相关总结]]></title>
    <url>%2Fmysql-summary.html</url>
    <content type="text"><![CDATA[一些MySQL常用命令相关总结，会不断补充。 常用命令 导出数据库全部表1mysqldump -uroot -p 数据库名 &gt; xxx.sql 导出数据库某张表 1mysqldump -uroot -p 数据库名 表名 &gt; xxx.sql 导出数据库某表的结构 1mysqldump -uroot -p -d 数据库名 表名 &gt; xxx.sql; 自动压缩 1mysqldump -uroot -p 数据库名 | gzip &gt; xxx.sql.gz 向数据库导入表 12cat aaa.sql | mysql -h192.168.8.1 -uroot -p 数据库名mysql -uroot -p dbname &lt; aaa.sql 压缩的 1gunzip &lt; xxx.sql.gz | mysql -uroot -p 数据库名 source 方式导入表 1234mysql -uroot -pshow databases;use dbname;source ~/Documents/xxx.sql 复制表 1CREATE TABLE 新表 SELECT * FROM 旧表 复制表结构 12CREATE TABLE 新表 SELECT * FROM 旧表 WHERE 1=2CREATE TABLE 新表 LIKE 旧表 查看表结构 1desc tablename 查看mysql的事务 12SELECT * FROM information_schema.INNODB_TRX\G;kill XXX 开启远程 允许所有ip访问 12GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;moma&apos; WITH GRANT OPTION;flush privileges; Ubuntu下还要修改 Mysql 配置文件 my.ini 1sudo vim /etc/mysql/my.cnf 将 bind-address = 127.0.0.1 这一行注释掉, 即修改为: 1#bind-address = 127.0.0.1 重启 MySQL 1sudo /etc/init.d/mysql restart 修改密码 方法一： 1SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;root&apos;); 方法二： 1UPDATE user SET Password = PASSWORD(&apos;roothicc409&apos;) WHERE user = &apos;root&apos;; 长期使用Navicat 的方法 删除 ～/.navicat 文件夹，试用时间将重新计算，本地查询语句将丢失可以使用 Navicat Cloud 服务（FREE），这样将永久保存查询语句]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除JSP页面中的空白行]]></title>
    <url>%2Fremove-jsp-page-blank.html</url>
    <content type="text"><![CDATA[由于JSP 页面里面往往会嵌套一些标签控制语句进行判断或者迭代，用Ctrl+u 查看源码时会看到代码很凌乱，会出现很多空白，所以下面是我遇到这种情况用到的方法 方法一：在Jsp页面head位置添加 1&lt;%@ page trimDirectiveWhitespaces=&quot;true&quot; %&gt; 方法二：在项目web.xml中添加 12345678&lt;servlet&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;trimSpaces&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;]]></content>
      <tags>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat 80端口被占用的解决办法]]></title>
    <url>%2Ftomcat-80-port-occupy.html</url>
    <content type="text"><![CDATA[在企业版Eclipse中，在已经启动了Tomcat服务器后，准备运行页面或Servlet时，有时会出现这样的关于Tomcat服务器端口占用的问题：“Several ports (8005, 8080, 8009) required by Tomcat v6.0 Server at localhost are already in use. The server may already be running in another process, or a system process may be using the port. To start this server you will need to stop the other process or change the port number(s).” 首先查看端口占用情况 ，使用以下命令 1sudo lsof -i:8080 查看结果 1java 1564 tomcat8 50u IPv6 19336 0t0 TCP *:http-alt (LISTEN) kill 该进程 (pid) 即可，使用以下命令 1sudo kill -9 1564]]></content>
      <tags>
        <tag>沉淀</tag>
      </tags>
  </entry>
</search>
