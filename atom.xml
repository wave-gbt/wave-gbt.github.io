<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wave&#39;s blog</title>
  
  <subtitle>Less is More</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://imbotao.top/"/>
  <updated>2020-09-14T07:31:13.830Z</updated>
  <id>http://imbotao.top/</id>
  
  <author>
    <name>wave</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用泛型封装redis缓存读写数据工具类</title>
    <link href="http://imbotao.top/redis-read-write-util.html"/>
    <id>http://imbotao.top/redis-read-write-util.html</id>
    <published>2020-09-14T06:22:22.000Z</published>
    <updated>2020-09-14T07:31:13.830Z</updated>
    
    <content type="html"><![CDATA[<p>　　功能描述：先从缓存中获取数据，如果缓存中获取不到，再通过业务接口或者查数据库获取数据，并记录到缓存中，如果数据没查到，针对集合类型的数据类型，缓存一个空集合，防止缓存穿透。<br><a id="more"></a>　　<br>　　封装目的：把从缓存中读写和json序列化，反序列化的代码进行封装，不用在业务代码中写的到处都是。</p><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getDataFromRedisOrDataGeter</span><span class="params">(String cacheKey, Class&lt;T&gt; clazz, Supplier&lt;T&gt; supplier, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    String cacheValue = (String)redisUtil.get(cacheKey);</span><br><span class="line">    T dto = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(cacheValue)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dto = objectMapper.readValue(cacheValue, clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            log.error(<span class="string">"JsonProcessingException:&#123;&#125;"</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(dto)) &#123;</span><br><span class="line">        <span class="keyword">return</span> dto;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果从缓存中没有获取到,通过java8 内置的一个函数式接口获取数据</span></span><br><span class="line">    <span class="comment">// 如果传入的泛型是集合类型，supplier.get() 如果获取不到数据时，会返回空集合。</span></span><br><span class="line">    <span class="comment">// 缓存空集合，避免了缓存穿透，导致频繁查业务接口或数据库的问题。</span></span><br><span class="line">    dto = supplier.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(dto)) &#123;</span><br><span class="line">            String jsonString = objectMapper.writeValueAsString(dto);</span><br><span class="line">            <span class="comment">// 写缓存</span></span><br><span class="line">            redisUtil.set(cacheKey, jsonString, time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dto;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        log.error(<span class="string">"JsonProcessingException:&#123;&#125;"</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户信息，cacheKey 为redis 缓存的key，缓存时间为 5min</span></span><br><span class="line">User user = getDataFromRedisOrDataGeter(cacheKey, User.class, <span class="keyword">new</span> Supplier&lt;User&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只需在此处实现 Supplier 的接口方法即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getUser(params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">5</span>*<span class="number">60</span>);</span><br></pre></td></tr></table></figure><p>这样在业务代码中，就实现了对某个业务方法加缓存的操作，从缓存读写，序列化，反序列化的代码就不会污染到业务接口内部。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　功能描述：先从缓存中获取数据，如果缓存中获取不到，再通过业务接口或者查数据库获取数据，并记录到缓存中，如果数据没查到，针对集合类型的数据类型，缓存一个空集合，防止缓存穿透。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://imbotao.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>jQuery 读取 properties 配置</title>
    <link href="http://imbotao.top/jquery-read-properties.html"/>
    <id>http://imbotao.top/jquery-read-properties.html</id>
    <published>2020-03-27T08:14:21.000Z</published>
    <updated>2020-03-27T08:52:49.392Z</updated>
    
    <content type="html"><![CDATA[<p>在前端页面中, 可以通过使用 <code>jQuery.i18n.properties</code> 这个 jQuery 插件灵活读取配置,从而达到可以通过修改配置文件,就可以变更前端文件的资源引用。</p><a id="more"></a><h3 id="插件下载"><a href="#插件下载" class="headerlink" title="插件下载"></a>插件下载</h3><ol><li><a href="https://www.ibm.com/developerworks/cn/web/1305_hezj_jqueryi18n/" target="_blank" rel="noopener">示例代码中获取</a></li><li><a href="https://github.com/jquery-i18n-properties/jquery-i18n-properties" target="_blank" rel="noopener">github 中获取</a></li></ol><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="资源引入"><a href="#资源引入" class="headerlink" title="资源引入"></a>资源引入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/jquery.i18n.properties.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>配置文件 <code>common.properties</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=http://imbotao.top/</span><br></pre></td></tr></table></figure></p><p>页面 js 使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">var url = &quot;&quot;;  // 该url 需要从配置中获取</span><br><span class="line">jQuery.i18n.properties(&#123;</span><br><span class="line">name : &apos;common&apos;, // 配置文件的名字 (common.properties)</span><br><span class="line">path : &apos;config/&apos;,  // 配置文件所在的目录路径</span><br><span class="line">mode : &apos;map&apos;,  // 资源约束模式 (map/both)</span><br><span class="line">callback : function() &#123;</span><br><span class="line">url = $.i18n.prop(&apos;url&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">$.getJSON(url, function(data)&#123;</span><br><span class="line">// todo</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前端页面中, 可以通过使用 &lt;code&gt;jQuery.i18n.properties&lt;/code&gt; 这个 jQuery 插件灵活读取配置,从而达到可以通过修改配置文件,就可以变更前端文件的资源引用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="http://imbotao.top/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 启动原理</title>
    <link href="http://imbotao.top/springboot-start-principle.html"/>
    <id>http://imbotao.top/springboot-start-principle.html</id>
    <published>2019-08-09T07:02:40.000Z</published>
    <updated>2019-08-16T06:57:55.187Z</updated>
    
    <content type="html"><![CDATA[<p>　　Spring Boot 让我们的 Spring 应用变的更轻量化。使用 SpringBoot 的最大好处就是简化配置，它实现了自动化配置。现在通过 SpringBoot 的入口启动类，了解下其自动配置的原理。<br><a id="more"></a></p><p><img src="/img/11120.png" alt="springboot 启动原理"></p><p>通过运行启动类中的<code>main()</code>方法, SpringBoot 项目就启动起来了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面代码可以看出，Annotation定义（<code>@SpringBootApplication</code>）和类定义（<code>SpringApplication.run</code>）最为耀眼，所以要揭开 SpringBoot 的神秘面纱，我们要从这两位开始就可以了。</p><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="SpringBootApplication"></a>SpringBootApplication</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)            <span class="comment">// 注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)  <span class="comment">// 注解的生命周期，保留到class文件中（三个生命周期）</span></span><br><span class="line"><span class="meta">@Documented</span>                          <span class="comment">// 表明这个注解应该被javadoc记录</span></span><br><span class="line"><span class="meta">@Inherited</span>                           <span class="comment">// 子类可以继承该注解</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span>             <span class="comment">// 继承了Configuration，表示当前是注解类</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>             <span class="comment">// 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;    <span class="comment">// 扫描路径设置（具体使用待确认）</span></span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然定义使用了多个Annotation进行了原信息标注，但实际上重要的只有三个Annotation：</p><ul><li>@Configuration（@SpringBootConfiguration点开查看发现里面还是应用了@Configuration）</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><p>所以，如果我们使用如下的SpringBoot启动类，整个SpringBoot应用依然可以与之前的启动类功能对等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来分别介绍这3个 Annotation。</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>这里的<code>@Configuration</code>对我们来说不陌生，它就是<code>JavaConfig</code>形式的<code>Spring Ioc</code>容器的配置类使用的那个<code>@Configuration</code>，<code>SpringBoot</code>社区推荐使用基于<code>JavaConfig</code>的配置形式，所以，这里的启动类标注了<code>@Configuration</code>之后，本身其实也是一个IoC容器的配置类。<br>举几个简单例子回顾下，<code>XML</code>跟<code>config</code>配置方式的区别：</p><ul><li><p>表达形式层面</p><ul><li><p>基于XML配置的方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-lazy-init</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean定义--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>基于JavaConfig的配置方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockConfiguration</span></span>&#123;</span><br><span class="line">    <span class="comment">//bean定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>任何一个标注了@Configuration的Java类定义都是一个JavaConfig配置类。</strong></p><ul><li><p>注册bean定义层面</p><ul><li><p>基于XML配置的方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mockService"</span> <span class="attr">class</span>=<span class="string">"..MockServiceImpl"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>基于JavaConfig的配置方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MockService <span class="title">mockService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MockServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id。</strong></p><ul><li><p>表达依赖注入关系层面</p><ul><li><p>基于XML配置的方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mockService"</span> <span class="attr">class</span>=<span class="string">"..MockServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span> =<span class="string">"dependencyService"</span> <span class="attr">ref</span>=<span class="string">"dependencyService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dependencyService"</span> <span class="attr">class</span>=<span class="string">"DependencyServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>基于JavaConfig的配置方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MockService <span class="title">mockService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MockServiceImpl(dependencyService());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DependencyService <span class="title">dependencyService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DependencyServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>如果一个bean的定义依赖其他bean,则直接调用对应的JavaConfig类中依赖bean的创建方法就可以了。</strong></p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p><code>@ComponentScan</code>这个注解在Spring中很重要，它对应XML配置中的元素，<code>@ComponentScan</code>的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。</p><p>我们可以通过<code>basePackages</code>等属性来细粒度的定制<code>@ComponentScan</code>自动扫描的范围，如果不指定，则默认<code>Spring</code>框架实现会从声明<code>@ComponentScan</code>所在类的 package 进行扫描。</p><p><strong>所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。</strong></p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>个人感觉<code>@EnableAutoConfiguration</code>这个Annotation最为重要，所以放在最后来解读，大家是否还记得Spring框架提供的各种名字为<code>@Enable</code>开头的Annotation定义？比如<code>@EnableScheduling</code>、<code>@EnableCaching</code>、<code>@EnableMBeanExport</code>等，<code>@EnableAutoConfiguration</code>的理念和做事方式其实一脉相承，简单概括一下就是，借助<code>@Import</code>的支持，收集和注册特定场景相关的bean定义。</p><ul><li><code>@EnableScheduling</code>是通过<code>@Import</code>将<code>Spring</code>调度框架相关的bean定义都加载到IoC容器。</li><li><code>@EnableMBeanExport</code>是通过<code>@Import</code>将<code>JMX</code>相关的bean定义加载到IoC容器。</li></ul><p>而<code>@EnableAutoConfiguration</code>也是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，仅此而已。<br><code>@EnableAutoConfiguration</code>作为一个复合Annotation,其自身定义关键信息如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 两个比较重要的注解：</strong></p><ul><li><code>@AutoConfigurationPackage</code>：自动配置包</li><li><code>@Import</code>: 导入自动配置的组件</li></ul><p>所以, <strong><code>@EnableAutoConfiguration</code> 是从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器</strong>。</p><p><strong>SpringBoot 启动原理图</strong><br><img src="/img/1112095.png" alt=""></p><h2 id="SpringApplication执行流程"><a href="#SpringApplication执行流程" class="headerlink" title="SpringApplication执行流程"></a>SpringApplication执行流程</h2><p>SpringApplication的run方法的实现是我们本次旅程的主要线路，该方法的主要流程大体可以归纳如下：</p><ol><li><p>如果我们使用的是<strong>SpringApplication的静态run方法</strong>，那么，这个方法里面<strong>首先要创建一个SpringApplication对象实例</strong>，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ConfigurableApplicationContext run(Object[] sources, String[] args) &#123;</span><br><span class="line">        return new SpringApplication(sources).run(args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</li><li><p>推断并设置main方法的定义类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="line">    private void initialize(Object[] sources) &#123;</span><br><span class="line">        if (sources != null &amp;&amp; sources.length &gt; 0) &#123;</span><br><span class="line">            this.sources.addAll(Arrays.asList(sources));</span><br><span class="line">        &#125;</span><br><span class="line">        this.webEnvironment = deduceWebEnvironment();</span><br><span class="line">        setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">                ApplicationContextInitializer.class));</span><br><span class="line">        setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">        this.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">        StopWatch stopWatch = new StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        ConfigurableApplicationContext context = null;</span><br><span class="line">        FailureAnalyzers analyzers = null;</span><br><span class="line">        configureHeadlessProperty();</span><br><span class="line">        SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">        listeners.starting();</span><br><span class="line">        try &#123;</span><br><span class="line">            ApplicationArguments applicationArguments = new DefaultApplicationArguments(</span><br><span class="line">                    args);</span><br><span class="line">            ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">                    applicationArguments);</span><br><span class="line">            Banner printedBanner = printBanner(environment);</span><br><span class="line">            context = createApplicationContext();</span><br><span class="line">            analyzers = new FailureAnalyzers(context);</span><br><span class="line">            prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                    printedBanner);</span><br><span class="line">　　　　　　　// 核心点：会打印springboot的启动标志，直到server.port端口启动</span><br><span class="line">            refreshContext(context);</span><br><span class="line">            afterRefresh(context, applicationArguments);</span><br><span class="line">            listeners.finished(context, null);</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            if (this.logStartupInfo) &#123;</span><br><span class="line">                new StartupInfoLogger(this.mainApplicationClass)</span><br><span class="line">                        .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">            &#125;</span><br><span class="line">            return context;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">            throw new IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private ConfigurableEnvironment prepareEnvironment(</span><br><span class="line">            SpringApplicationRunListeners listeners,</span><br><span class="line">            ApplicationArguments applicationArguments) &#123;</span><br><span class="line">        // Create and configure the environment</span><br><span class="line">        ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">        configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">        listeners.environmentPrepared(environment);</span><br><span class="line">        if (!this.webEnvironment) &#123;</span><br><span class="line">            environment = new EnvironmentConverter(getClassLoader())</span><br><span class="line">                    .convertToStandardEnvironmentIfNecessary(environment);</span><br><span class="line">        &#125;</span><br><span class="line">        return environment;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void environmentPrepared(ConfigurableEnvironment environment) &#123;</span><br><span class="line">        for (SpringApplicationRunListener listener : this.listeners) &#123;</span><br><span class="line">            listener.environmentPrepared(environment);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果SpringApplication的showBanner属性被设置为true，则打印banner。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private Banner printBanner(ConfigurableEnvironment environment) &#123;</span><br><span class="line">        if (this.bannerMode == Banner.Mode.OFF) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ResourceLoader resourceLoader = this.resourceLoader != null ? this.resourceLoader</span><br><span class="line">                : new DefaultResourceLoader(getClassLoader());</span><br><span class="line">        SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(</span><br><span class="line">                resourceLoader, this.banner);</span><br><span class="line">        if (this.bannerMode == Mode.LOG) &#123;</span><br><span class="line">            return bannerPrinter.print(environment, this.mainApplicationClass, logger);</span><br><span class="line">        &#125;</span><br><span class="line">        return bannerPrinter.print(environment, this.mainApplicationClass, System.out);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</p></li><li><p>ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span><br><span class="line">    protected void applyInitializers(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        for (ApplicationContextInitializer initializer : getInitializers()) &#123;</span><br><span class="line">            Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(</span><br><span class="line">                    initializer.getClass(), ApplicationContextInitializer.class);</span><br><span class="line">            Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;);</span><br><span class="line">            initializer.initialize(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void prepareContext(ConfigurableApplicationContext context,</span><br><span class="line">                ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span><br><span class="line">                ApplicationArguments applicationArguments, Banner printedBanner) &#123;</span><br><span class="line">            context.setEnvironment(environment);</span><br><span class="line">            postProcessApplicationContext(context);</span><br><span class="line">            applyInitializers(context);</span><br><span class="line">            listeners.contextPrepared(context);</span><br><span class="line">            if (this.logStartupInfo) &#123;</span><br><span class="line">                logStartupInfo(context.getParent() == null);</span><br><span class="line">                logStartupProfileInfo(context);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // Add boot specific singleton beans</span><br><span class="line">            context.getBeanFactory().registerSingleton(&quot;springApplicationArguments&quot;,</span><br><span class="line">                    applicationArguments);</span><br><span class="line">            if (printedBanner != null) &#123;</span><br><span class="line">                context.getBeanFactory().registerSingleton(&quot;springBootBanner&quot;, printedBanner);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // Load the sources</span><br><span class="line">            Set&lt;Object&gt; sources = getSources();</span><br><span class="line">            Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);</span><br><span class="line">            load(context, sources.toArray(new Object[sources.size()]));</span><br><span class="line">            listeners.contextLoaded(context);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void prepareAnalyzer(ConfigurableApplicationContext context,</span><br><span class="line">            FailureAnalyzer analyzer) &#123;</span><br><span class="line">        if (analyzer instanceof BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) analyzer).setBeanFactory(context.getBeanFactory());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void contextLoaded(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        for (SpringApplicationRunListener listener : this.listeners) &#123;</span><br><span class="line">            listener.contextLoaded(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void refreshContext(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        refresh(context);</span><br><span class="line">        if (this.registerShutdownHook) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                context.registerShutdownHook();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (AccessControlException ex) &#123;</span><br><span class="line">                // Not allowed in some environments.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void callRunners(ApplicationContext context, ApplicationArguments args) &#123;</span><br><span class="line">        List&lt;Object&gt; runners = new ArrayList&lt;Object&gt;();</span><br><span class="line">        runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">        runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">        AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">        for (Object runner : new LinkedHashSet&lt;Object&gt;(runners)) &#123;</span><br><span class="line">            if (runner instanceof ApplicationRunner) &#123;</span><br><span class="line">                callRunner((ApplicationRunner) runner, args);</span><br><span class="line">            &#125;</span><br><span class="line">            if (runner instanceof CommandLineRunner) &#123;</span><br><span class="line">                callRunner((CommandLineRunner) runner, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）去除事件通知点后，整个流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void finished(ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">        for (SpringApplicationRunListener listener : this.listeners) &#123;</span><br><span class="line">            callFinishedListener(listener, context, exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="/img/7729577.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此，SpringBoot的核心组件完成了基本的解析，综合来看，大部分都是Spring框架背后的一些概念和实践方式，SpringBoot只是在这些概念和实践上对特定的场景事先进行了固化和升华，而也恰恰是这些固化让我们开发基于Sping框架的应用更加方便高效。</p><blockquote><p>Reference: </p><ul><li><a href="https://www.cnblogs.com/shamo89/p/8184960.html" target="_blank" rel="noopener">springboot之启动原理解析及源码阅读</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Spring Boot 让我们的 Spring 应用变的更轻量化。使用 SpringBoot 的最大好处就是简化配置，它实现了自动化配置。现在通过 SpringBoot 的入口启动类，了解下其自动配置的原理。&lt;br&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://imbotao.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>mac 搭建 ELK 并与 SpringBoot 集成</title>
    <link href="http://imbotao.top/mac-elk-springboot-build.html"/>
    <id>http://imbotao.top/mac-elk-springboot-build.html</id>
    <published>2019-08-01T03:13:34.000Z</published>
    <updated>2019-08-01T08:41:52.742Z</updated>
    
    <content type="html"><![CDATA[<p>　　<code>ELK</code>(Elasticsearch + Logstash + Kibana)是一套开源的日志管理方案, 很多公司利用它来搭建可视化的海量日志分析平台。<br><a id="more"></a></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><code>Elasticsearch</code>: 是一个分布式、可扩展、实时的搜索与数据分析引擎。</li><li><code>Logstash</code>: 是一个具有实时渠道能力的数据收集引擎,它由三个主要部分组成:<ul><li><code>Shipper</code>: 发送日志数据</li><li><code>Broker</code>: 收集数据，缺省内置 Redis</li><li><code>Indexer</code>: 数据写入</li></ul></li><li><code>Kibana</code>: 为 <code>Elasticsearch</code> 提供分析和可视化的 Web 平台。它可以在 <code>Elasticsearch</code> 的索引中查找，交互数据，并生成各种维度的表图。</li></ul><p>　　完整的 ELK 协议栈基本流程是 Shipper 负责从各种数据源里采集数据，然后发送到 Broker，Indexer 将存放在 Broker 中的数据再写入 Elasticsearch，Elasticsearch 对这些数据创建索引，然后由 Kibana 对其进行各种分析并以图表的形式展示。</p><h3 id="搭建-ELK"><a href="#搭建-ELK" class="headerlink" title="搭建 ELK"></a>搭建 ELK</h3><p><strong>注意</strong>: 搭建 elk 需要先安装好 <code>java</code></p><h4 id="Install-ElasticSearch"><a href="#Install-ElasticSearch" class="headerlink" title="Install ElasticSearch"></a>Install ElasticSearch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 安装</span><br><span class="line">brew install elasticsearch</span><br><span class="line">// 查看信息</span><br><span class="line">brew info elasticsearch  </span><br><span class="line">// 启动</span><br><span class="line">brew services start elasticsearch</span><br></pre></td></tr></table></figure><p>安装好启动成功之后，访问<code>localhost:9200</code>, 可以看到如下结果:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"PqnS9Kz"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"elasticsearch_botaogou"</span>,</span><br><span class="line">  <span class="attr">"cluster_uuid"</span> : <span class="string">"r2Vw0MjbQbSbvLa657IzTw"</span>,</span><br><span class="line">  <span class="attr">"version"</span> : &#123;</span><br><span class="line">    <span class="attr">"number"</span> : <span class="string">"6.8.1"</span>,</span><br><span class="line">    <span class="attr">"build_flavor"</span> : <span class="string">"oss"</span>,</span><br><span class="line">    <span class="attr">"build_type"</span> : <span class="string">"tar"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span> : <span class="string">"1fad4e1"</span>,</span><br><span class="line">    <span class="attr">"build_date"</span> : <span class="string">"2019-06-18T13:16:52.517138Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span> : <span class="string">"7.7.0"</span>,</span><br><span class="line">    <span class="attr">"minimum_wire_compatibility_version"</span> : <span class="string">"5.6.0"</span>,</span><br><span class="line">    <span class="attr">"minimum_index_compatibility_version"</span> : <span class="string">"5.0.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Install-Kibana"><a href="#Install-Kibana" class="headerlink" title="Install Kibana"></a>Install Kibana</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install kibana</span><br><span class="line">brew info kibana</span><br><span class="line">brew services start kibana</span><br></pre></td></tr></table></figure><p>修改 <code>Kibana</code> 的配置，指定es的访问url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/etc/kibana</span><br></pre></td></tr></table></figure></p><p>vim kibana.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.port: 5601</span><br><span class="line">elasticsearch.hosts: [&quot;http://localhost:9200&quot;]</span><br></pre></td></tr></table></figure></p><h4 id="Install-Logstash"><a href="#Install-Logstash" class="headerlink" title="Install Logstash"></a>Install Logstash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install logstash</span><br><span class="line">brew info logstash</span><br><span class="line">brew services start logstash</span><br></pre></td></tr></table></figure><p>创建 <code>.conf</code> 文件 vim test.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">   file &#123;</span><br><span class="line">      path =&gt; [&quot;/Users/botaogou/Documents/elk-conf/test.txt&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> output &#123;</span><br><span class="line">   elasticsearch&#123;</span><br><span class="line">      hosts =&gt; [&quot;http://localhost:9200&quot;]</span><br><span class="line">      index =&gt; &quot;test&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logstash -f test.conf</span><br></pre></td></tr></table></figure></p><p>访问<code>localhost:9600</code>, 可以看到如下结果:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"host"</span>:<span class="string">"wave-MacBook-Pro.local"</span>,<span class="attr">"version"</span>:<span class="string">"7.2.0"</span>,<span class="attr">"http_address"</span>:<span class="string">"127.0.0.1:9600"</span>,<span class="attr">"id"</span>:<span class="string">"f3c20331-8f84-45e1-aa4d-5ea45ff18293"</span>,<span class="attr">"name"</span>:<span class="string">"wave-MacBook-Pro.local"</span>,<span class="attr">"ephemeral_id"</span>:<span class="string">"6f033156-e0ee-4346-91a4-ac08201ccdab"</span>,<span class="attr">"status"</span>:<span class="string">"green"</span>,<span class="attr">"snapshot"</span>:<span class="literal">false</span>,<span class="attr">"build_date"</span>:<span class="string">"2019-06-20T17:29:17+00:00"</span>,<span class="attr">"build_sha"</span>:<span class="string">"a2b1dbb747289ac122b146f971193cfc9f7a2f97"</span>,<span class="attr">"build_snapshot"</span>:<span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure></p><p>然后 <code>test.txt</code> 文件内容有追加的时候，通过访问<code>localhost：5601</code>，kibana 上已经看到 <code>test</code> index 已经被创建。</p><h3 id="SpringBoot-集成"><a href="#SpringBoot-集成" class="headerlink" title="SpringBoot 集成"></a>SpringBoot 集成</h3><h4 id="加入依赖"><a href="#加入依赖" class="headerlink" title="加入依赖"></a>加入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- logback --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- logstash --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="logback-spring-xml"><a href="#logback-spring-xml" class="headerlink" title="logback-spring.xml"></a>logback-spring.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"logstash"</span><span class="attr">class</span>=<span class="string">"net.logstash.logback.appender.LogstashTcpSocketAppender"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- logstash 所在的服务ip，监听端口，这里是我本地ip --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">destination</span>&gt;</span>192.168.111.54:8082<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!--&lt;filterclass="ch.qos.logback.classic.filter.ThresholdFilter"&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--&lt;level&gt;info&lt;/level&gt;&lt;!–写入logstash的日志级别–&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!--&lt;/filter&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span><span class="attr">class</span>=<span class="string">"net.logstash.logback.encoder.LogstashEncoder"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--"appname":"springboot21-log-elk" 的作用是指定创建索引的名字时用，并且在生成的文档中会多了这个字段</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             在logstashindex中引入    index =&gt; "%&#123;[appname]&#125;-%&#123;+YYYY.MM.dd&#125;"--&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;<span class="name">customFields</span>&gt;</span>&#123;"appname":"springboot2-log-elk"&#125;<span class="tag">&lt;/<span class="name">customFields</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- 日志输出级别 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"logstash"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="logstash-的-conf-文件"><a href="#logstash-的-conf-文件" class="headerlink" title="logstash 的 .conf 文件"></a>logstash 的 <code>.conf</code> 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line"> tcp &#123;</span><br><span class="line">        host =&gt; &quot;92.168.111.54&quot;</span><br><span class="line">        port =&gt; 8082</span><br><span class="line">        mode =&gt; &quot;server&quot;</span><br><span class="line">        ssl_enable =&gt; false</span><br><span class="line">        codec =&gt; json &#123;</span><br><span class="line">            charset =&gt; &quot;UTF-8&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;http://localhost:9200&quot;]</span><br><span class="line">        index =&gt; &quot;%&#123;[appname]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  stdout &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后启动工程，就可以通过访问(<a href="http://localhost：5601" target="_blank" rel="noopener">http://localhost：5601</a>) <code>kibana</code> 看到新的索引了，<code>create index pattern</code> –&gt; <code>@timestamp</code>, 然后就可以看到以时间顺序排序的项目日志了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;code&gt;ELK&lt;/code&gt;(Elasticsearch + Logstash + Kibana)是一套开源的日志管理方案, 很多公司利用它来搭建可视化的海量日志分析平台。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://imbotao.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 死信队列</title>
    <link href="http://imbotao.top/RabbitMQ-dead-letter-queue.html"/>
    <id>http://imbotao.top/RabbitMQ-dead-letter-queue.html</id>
    <published>2019-07-30T06:29:16.000Z</published>
    <updated>2019-07-30T08:03:05.323Z</updated>
    
    <content type="html"><![CDATA[<p>　　死信消息会被<code>RabbitMQ</code>进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。<br><a id="more"></a></p><h3 id="什么是死信"><a href="#什么是死信" class="headerlink" title="什么是死信"></a>什么是死信</h3><p>　　队列中的消息在以下三种情况下会变成死信:</p><ul><li>消息被拒绝 (basic.reject/ basic.nack)并且不再重新投递 requeue=false</li><li>消息超期 (rabbitmq  Time-To-Live -&gt; messageProperties.setExpiration())</li><li>队列超载 (长度限制超过了)</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>　　一般是应用在较为重要的业务中，确保消息不会丢失。通过配置死信队列，可以让未正常消费的消息暂存到另一个队列里，通过相应的业务代码来处理死信消息。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>　　生产者 –&gt; 消息 –&gt; 交换机 –&gt; 队列 –&gt; 变成死信 –&gt; DLX交换机 –&gt;队列 –&gt; 消费者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">lindQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> QueueBuilder.durable(LIND_QUEUE)</span><br><span class="line">      .withArgument(<span class="string">"x-dead-letter-exchange"</span>, LIND_DL_EXCHANGE)<span class="comment">//设置死信交换机</span></span><br><span class="line">      .withArgument(<span class="string">"x-message-ttl"</span>, makeCallExpire)</span><br><span class="line">      .withArgument(<span class="string">"x-dead-letter-routing-key"</span>, LIND_DEAD_QUEUE)<span class="comment">//设置死信routingKey</span></span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>x-dead-letter-exchange</code>: 用来设置死信后发送的交换机<br><code>x-dead-letter-routing-key</code>: 用来设置死信的 <code>routing-key</code>,如果不设置默认使用消息本身的<code>routing-key</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">z<span class="meta">@Component</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmqpConfig</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 主要测试一个死信队列，功能主要实现延时消费，原理是先把消息发到正常队列，</span></span><br><span class="line"><span class="comment">    * 正常队列有超时时间，当达到时间后自动发到死信队列，然后由消费者去消费死信队列里的消息.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LIND_EXCHANGE = <span class="string">"lind.exchange"</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LIND_DL_EXCHANGE = <span class="string">"lind.dl.exchange"</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LIND_QUEUE = <span class="string">"lind.queue"</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LIND_DEAD_QUEUE = <span class="string">"lind.queue.dead"</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LIND_FANOUT_EXCHANGE = <span class="string">"lindFanoutExchange"</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 单位为微秒.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;tq.makecall.expire:60000&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> makeCallExpire;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建普通交换机.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">lindExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (TopicExchange) ExchangeBuilder.topicExchange(LIND_EXCHANGE).durable(<span class="keyword">true</span>)</span><br><span class="line">         .build();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建死信交换机.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">lindExchangeDl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (TopicExchange) ExchangeBuilder.topicExchange(LIND_DL_EXCHANGE).durable(<span class="keyword">true</span>)</span><br><span class="line">         .build();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建普通队列.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue <span class="title">lindQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> QueueBuilder.durable(LIND_QUEUE)</span><br><span class="line">         .withArgument(<span class="string">"x-dead-letter-exchange"</span>, LIND_DL_EXCHANGE)<span class="comment">//设置死信交换机</span></span><br><span class="line">         .withArgument(<span class="string">"x-message-ttl"</span>, makeCallExpire)</span><br><span class="line">         .withArgument(<span class="string">"x-dead-letter-routing-key"</span>, LIND_DEAD_QUEUE)<span class="comment">//设置死信routingKey</span></span><br><span class="line">         .build();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建死信队列.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue <span class="title">lindDelayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> QueueBuilder.durable(LIND_DEAD_QUEUE).build();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 绑定死信队列.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Binding <span class="title">bindDeadBuilders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> BindingBuilder.bind(lindDelayQueue())</span><br><span class="line">         .to(lindExchangeDl())</span><br><span class="line">         .with(LIND_DEAD_QUEUE);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 绑定普通队列.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Binding <span class="title">bindBuilders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> BindingBuilder.bind(lindQueue())</span><br><span class="line">         .to(lindExchange())</span><br><span class="line">         .with(LIND_QUEUE);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 广播交换机.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(LIND_FANOUT_EXCHANGE);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//-----生产者</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Component</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       rabbitTemplate</span><br><span class="line">           .convertAndSend(AmqpConfig.LIND_EXCHANGE, AmqpConfig.LIND_DELAY_QUEUE,</span><br><span class="line">               message);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//------消费者</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Component</span></span><br><span class="line"> <span class="meta">@Slf</span>4j</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RabbitListener</span>(queues = AmqpConfig.LIND_QUEUE)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customerSign</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">       log.info(<span class="string">"从队列拿到数据 ：&#123;&#125;"</span>, data);</span><br><span class="line"> </span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Reference: </p><ul><li><a href="https://www.cnblogs.com/lori/archive/2018/11/19/9984760.html" target="_blank" rel="noopener">rabbitmq实现死信队列</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　死信消息会被&lt;code&gt;RabbitMQ&lt;/code&gt;进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。&lt;br&gt;
    
    </summary>
    
    
      <category term="MQ" scheme="http://imbotao.top/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>使用 Optional 解决 NPE 问题</title>
    <link href="http://imbotao.top/Solve-NPE-problems-with-Optional.html"/>
    <id>http://imbotao.top/Solve-NPE-problems-with-Optional.html</id>
    <published>2019-07-19T03:01:35.000Z</published>
    <updated>2019-07-19T08:26:12.639Z</updated>
    
    <content type="html"><![CDATA[<p>　　NPE(NullPointerException) 是 Java 程序开发中的最典型的异常，从Java类型系统的角度看，null可以被赋值给任何类型的变量，并且不断被传递，知道最后谁也不知道它是从哪里引入的。<br><a id="more"></a></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>先看一种情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.getAddress().getProvince();</span><br></pre></td></tr></table></figure></p><p>这种写法，在<code>user</code>或者<code>address</code>为<code>null</code>时，是有可能报<code>NullPointerException</code>异常的。为了解决这个问题，于是采用下面的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(user!=null)&#123;</span><br><span class="line">    Address address = user.getAddress();</span><br><span class="line">    if(address!=null)&#123;</span><br><span class="line">        String province = address.getProvince();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种写法是比较丑陋的，为了避免上述丑陋的写法，让丑陋的设计变得优雅。JAVA8 提供了<code>Optional</code>类来优化这种写法，通过类型系统让你的领域模型中隐藏的知识显式地体现在你的代码中，这样我们就不用显式进行空值检测。</p><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>static <t> Optional<t> empty()</t></t></td><td>返回空的 Optional 实例。</td></tr><tr><td>boolean equals(Object obj)</td><td>判断其他对象是否等于 Optional。</td></tr><tr><td>Optional<t> filter(Predicate&lt;? super <t> predicate)</t></t></td><td>如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。</td></tr><tr><td><u> Optional<u> flatMap(Function&lt;? super T,Optional<u>&gt; mapper)</u></u></u></td><td>如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional</td></tr><tr><td>T get()</td><td>如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException</td></tr><tr><td>int hashCode()</td><td>返回存在值的哈希码，如果值不存在 返回 0。</td></tr><tr><td>void ifPresent(Consumer&lt;? super T&gt; consumer)</td><td>如果值存在则使用该值调用 consumer , 否则不做任何事情。</td></tr><tr><td>boolean isPresent()</td><td>如果值存在则方法会返回true，否则返回 false。</td></tr><tr><td><u>Optional<u> map(Function&lt;? super T,? extends U&gt; mapper)</u></u></td><td>如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。</td></tr><tr><td>static <t> Optional<t> of(T value)</t></t></td><td>返回一个指定非null值的Optional。</td></tr><tr><td>static <t> Optional<t> ofNullable(T value)</t></t></td><td>如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。</td></tr><tr><td>T orElse(T other)</td><td>如果存在该值，返回值， 否则返回 other。</td></tr><tr><td>T orElseGet(Supplier&lt;? extends T&gt; other)</td><td>如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。</td></tr><tr><td><x extends="" throwable=""> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</x></td><td>如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常</td></tr><tr><td>String toString()</td><td>返回一个Optional的非空字符串，用来调试</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 判断一个对象的属性是否为空，为空则跑出异常</span><br><span class="line">Optional.ofNullable(user)</span><br><span class="line">                   .flatMap(u-&gt; u.getAddress())</span><br><span class="line">                   .map(a-&gt;a.getCity())</span><br><span class="line">                   .orElseThrow(()-&gt;new Exception(&quot;异常&quot;));</span><br><span class="line">               </span><br><span class="line">// 判断一个对象是否为空，不为空 do something</span><br><span class="line">Optional.ofNullable(user).ifPresent(u-&gt;&#123;</span><br><span class="line">            // do something</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">// 对 Optional 中包含的值进行过滤，如果包含的值满足条件，那么还是返回这个 Optional；否则创建一个新的对象返回</span><br><span class="line">Optional&lt;User&gt; user1 = Optional.ofNullable(user).</span><br><span class="line">                                    filter(u -&gt; &quot;wave&quot;.equals(u.getName)).</span><br><span class="line">                                    orElseGet(()-&gt; &#123;</span><br><span class="line">                                                  User user1 = new User();</span><br><span class="line">                                                  user1.setName(&quot;wave&quot;);</span><br><span class="line">                                                  return user1;</span><br><span class="line">                                             &#125;);;</span><br></pre></td></tr></table></figure><p>使用<code>Optional</code>的思路和<code>Stream</code>相同，都是链式思路，省去了繁琐的判断，在后面的开发中，可以使用Optional设计API，这样可以设计出更安全的接口和方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　NPE(NullPointerException) 是 Java 程序开发中的最典型的异常，从Java类型系统的角度看，null可以被赋值给任何类型的变量，并且不断被传递，知道最后谁也不知道它是从哪里引入的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://imbotao.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一条SQL(select/update)语句是如何执行的?</title>
    <link href="http://imbotao.top/how-is-a-sql-executed.html"/>
    <id>http://imbotao.top/how-is-a-sql-executed.html</id>
    <published>2019-06-03T07:59:04.000Z</published>
    <updated>2019-06-03T09:31:50.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>关键字</strong>：<code>基础架构</code>,<code>日志系统</code></p></blockquote><p>在执行下面这个查询语句时：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br></pre></td></tr></table></figure></p><p>MySQL 内部的执行过程，所以需要拆解一下，看看 SQL 语句在 MySQL 中各个功能模块中的执行过程。</p><a id="more"></a><p><img src="/img/1559550471446.jpg" alt="MySQL 逻辑架构图"><br>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。<br>　　Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。<br>　　而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、 MyISAM、Memory 等多个存储引擎。</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure></p><p>　　如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。<br>　　数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。<br>　　建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。<br>　　但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因 为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断 开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉 (OOM)，从现象看就是 MySQL 异常重启了。</p><p>　　怎么解决这个问题呢?你可以考虑以下两种方案：</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后， 断开连接，之后要查询再重连。</li><li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执 行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权 限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>　　MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前 执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询 的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。所以如果被缓存命中，效率会很高。<br>　　查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。所以查询缓存的命中率会非常低。<br>　　MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻 底没有这个功能了。</p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>　　分析器先会做“词法分析”，识别出具体的SQL语句查询字段和对应的表明，然后做”语法分析”，判断是否满足 MySQL 的语法。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>　　优化器是在表里面有多个索引的时候，决定使用哪个索引;或者在一个语句有多表关联 (join)的时候，决定各个表的连接顺序。　　   </p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>　　开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返 回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结 果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。<br>　　比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的:</p><ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如 果是则将这行存在结果集中;</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 </li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><hr><p><strong>如果是下面的更新语句呢？</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure></p><p>除了上述查询的那一套流程，还涉及到两个重要的日志模块。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>　　具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。<br>　　InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文 件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。<br>　　有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>　　redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog(归档日志)。</p><p>这两种日志有以下三点不同。</p><ol><li>redo log 是 InnoDB 引擎特有的;binlog 是 MySQL 的 Server 层实现的，所有引擎 都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”;binlog 是逻辑日 志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li><li>redo log 是循环写的，空间固定会用完;binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。<br><img src="/img/1559553982651.jpg" alt=""></p><ol><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器;否则，需要先从磁 盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到 新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交(commit)状态，更新完成。</li></ol><p>将 redo log 的写入拆成了两个步骤: prepare 和 commit，这就是”两阶段提交”。<br>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><blockquote><p>Reference:　[极客时间-MySQL实践45讲]　</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：&lt;code&gt;基础架构&lt;/code&gt;,&lt;code&gt;日志系统&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在执行下面这个查询语句时：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; select * from T where ID=10;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;MySQL 内部的执行过程，所以需要拆解一下，看看 SQL 语句在 MySQL 中各个功能模块中的执行过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://imbotao.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>谈谈常用分布式ID的设计方案</title>
    <link href="http://imbotao.top/distributed-id-design.html"/>
    <id>http://imbotao.top/distributed-id-design.html</id>
    <published>2019-05-20T06:53:59.000Z</published>
    <updated>2019-06-01T05:37:55.585Z</updated>
    
    <content type="html"><![CDATA[<p>　　需要明确通常的分布式 ID 的定义，基本包括:</p><ul><li>全局唯一，区别于单点系统的唯一，全局是要求分布式系统内唯一。</li><li>有序性，通常要保证生成的 ID 是有序递增的。</li></ul><p><a id="more"></a>　<br>　　目前业界的的方案主要是：</p><ul><li>基于数据库自增序列的实现。这种方式优点和缺点都非常明显，好处是简单易用，但是在扩展性和可靠性等方面存在局限性。</li><li>基于 Twitter 早期开源的Snowflake的实现，以及相关改动方案。其结构定义可以参考下面的示意图。</li></ul><p><img src="/img/ffd41494a39ef737b3c1151929c3c4ad.png" alt="分布式id结构图"></p><p>其中 10 位的WorkerID，标准定义是 5 位数据中心 + 5 位机器编码，以区分不同的集群节点。<br>最后的 12 位就是单位毫秒内可生成的序列号数目的理论极限。</p><p>　　在明确的业务场景中，我们到底需要一个什么样的分布式ID呢，除了唯一性和有序，通常还希望分布式ID：</p><ul><li>有意义，也就是说包含更多的信息，比如时间和业务信息。</li><li>高可用性，取决于我们业务对扩展性，性能方面的要求。</li><li>紧凑性，ID 的大小可能受实际应用的制约，例如太长的ID会降低 MYSQL 等数据库索引的性能。</li></ul><p>分享一个很好的分布式ID的实现 <a href="https://github.com/bingoohuang/westid" target="_blank" rel="noopener">westid</a>.</p><blockquote><p>Reference:　<a href="https://time.geekbang.org/column/intro/82" target="_blank" rel="noopener">极客时间-Java核心技术36讲</a>　</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　需要明确通常的分布式 ID 的定义，基本包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局唯一，区别于单点系统的唯一，全局是要求分布式系统内唯一。&lt;/li&gt;
&lt;li&gt;有序性，通常要保证生成的 ID 是有序递增的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://imbotao.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程学习 - 概述</title>
    <link href="http://imbotao.top/java-concurrent-programming-outline.html"/>
    <id>http://imbotao.top/java-concurrent-programming-outline.html</id>
    <published>2019-05-14T10:05:56.000Z</published>
    <updated>2019-05-14T11:18:51.086Z</updated>
    
    <content type="html"><![CDATA[<p>　　看薛兆丰的《经济学通识》，他总结到，人类面临着四大基本约束：东西不够，生命有限，互相依赖，需要协调。当我看到这句话的时候，我猛然间意识到：计算机也同样面临着这四大基本约束。<br>　　在计算中，CPU、内存、IO、硬盘、带宽等，这些资源也都有不够的时候，而每个线程的也有着自己的生命周期，并且它们之间又是相互依赖的，也同样需要协调。有了上面的这种想法，我觉得我学习计算机的知识有了章法可循。</p><a id="more"></a><p>并发编程知识全景图<br><img src="/img/11e0c64618c04edba52619f41aaa3565.png" alt="并发编程全景图之思维导图"></p><p>并发编程领域可以抽象成三个核心问题：分工、同步和互斥。</p><h2 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h2><p>类似于现实中一个组织完成一个项目，项目经理要拆分任务，安排合适的成员去完成。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>每个小任务间可能存在相互依赖，同步需要做的是在前置任务完成后，通知后置任务启动。</p><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>互斥主要解决正确性问题。互斥要求同一时间，只允许一个线程访问共享变量。</p><p><strong>学习方法论:</strong> 我认为工程上的解决方案，一定要有理论做基础。「跳出来，看全景」 和 「钻进去，看本质」，这两条方法论，我想是适合很多领域的学习的。</p><blockquote><p>Reference:　<a href="https://time.geekbang.org/column/intro/159" target="_blank" rel="noopener">极客时间-Java并发编程实战</a>　　</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　看薛兆丰的《经济学通识》，他总结到，人类面临着四大基本约束：东西不够，生命有限，互相依赖，需要协调。当我看到这句话的时候，我猛然间意识到：计算机也同样面临着这四大基本约束。&lt;br&gt;　　在计算中，CPU、内存、IO、硬盘、带宽等，这些资源也都有不够的时候，而每个线程的也有着自己的生命周期，并且它们之间又是相互依赖的，也同样需要协调。有了上面的这种想法，我觉得我学习计算机的知识有了章法可循。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="http://imbotao.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>最长公共前缀</title>
    <link href="http://imbotao.top/longest-common-prefix.html"/>
    <id>http://imbotao.top/longest-common-prefix.html</id>
    <published>2019-05-12T08:14:14.000Z</published>
    <updated>2019-05-12T08:24:42.016Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。<br><a id="more"></a></p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong><br>先利用<code>Arrays.sort(strs)</code>为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可。 </p><p><strong>实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果检查值不合法及就返回空串</span></span><br><span class="line"><span class="keyword">if</span> (!checkStrs(strs)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组长度</span></span><br><span class="line"><span class="keyword">int</span> len = strs.length;</span><br><span class="line"><span class="comment">// 用于保存结果</span></span><br><span class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// 给字符串数组的元素按照升序排序(包含数字的话，数字会排在前面)</span></span><br><span class="line">Arrays.sort(strs);</span><br><span class="line"><span class="keyword">int</span> m = strs[<span class="number">0</span>].length();</span><br><span class="line"><span class="keyword">int</span> n = strs[len - <span class="number">1</span>].length();</span><br><span class="line"><span class="keyword">int</span> num = Math.min(m, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (strs[<span class="number">0</span>].charAt(i) == strs[len - <span class="number">1</span>].charAt(i)) &#123;</span><br><span class="line">res.append(strs[<span class="number">0</span>].charAt(i));</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkStrs</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (strs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历strs检查元素值</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (strs[i] == <span class="keyword">null</span> || strs[i].length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String[] strs = &#123; <span class="string">"customer"</span>, <span class="string">"car"</span>, <span class="string">"cat"</span> &#125;;</span><br><span class="line"><span class="comment">// String[] strs = &#123; "customer", "car", null &#125;;//空串</span></span><br><span class="line"><span class="comment">// String[] strs = &#123;&#125;;//空串</span></span><br><span class="line"><span class="comment">// String[] strs = null;//空串</span></span><br><span class="line">System.out.println(Main.replaceSpace(strs));<span class="comment">// c</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://imbotao.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>如何保证幂等机制</title>
    <link href="http://imbotao.top/how-to-guarantee-idempotent-mechanism.html"/>
    <id>http://imbotao.top/how-to-guarantee-idempotent-mechanism.html</id>
    <published>2019-05-12T06:39:49.000Z</published>
    <updated>2019-08-01T03:27:00.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>　　其实这是一个很常见的问题，做后端开发会经常遇到这个问题，如何保证消息消费不被重复消费，或者说如何保证一个接口多次调用只会产生一种结果，不管调多少次，资源都不会发生改变。如果重复消费了或者调用了，如何保证不造成系统异常。所以幂等机制的核心就是保证资源唯一性。<br><a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>　　需要保证幂等性的场景就是需要限定接口只能调用一次；消息重复消费之后，要保证资源不会发生改变。例如：</p><ul><li>支付接口</li><li>退款接口</li><li>新增数据的接口</li><li>…</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>利用数据库的唯一索引，针对我们需要约束的资源字段创建唯一索引，可以防止插入重复的数据。需要注意的是，如果是分库分表的情况，唯一索引的情况就不能限制资源数据的唯一性。</li><li>可以先根据数据库唯一索引查一下，如果存在，就做更新操作。 这块要注意的是如何避免并发场景（分布式锁）。</li><li>如果是直接写 redis，每次都是set，天然就幂等的。</li><li>利用 redis 做一层校验，每次调接口或这消费消息之前先查一下 redis 里有没有全局的ID，如果没有消费过，加redis，再处理消息或接口。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;　　其实这是一个很常见的问题，做后端开发会经常遇到这个问题，如何保证消息消费不被重复消费，或者说如何保证一个接口多次调用只会产生一种结果，不管调多少次，资源都不会发生改变。如果重复消费了或者调用了，如何保证不造成系统异常。所以幂等机制的核心就是保证资源唯一性。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://imbotao.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>All Or Nothing</title>
    <link href="http://imbotao.top/goodbye-2018.html"/>
    <id>http://imbotao.top/goodbye-2018.html</id>
    <published>2019-01-02T12:51:23.000Z</published>
    <updated>2019-05-10T03:32:28.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>关键字</strong>：<code>don&#39;t be nervous</code>, <code>业务or技术</code>, <code>人情味儿</code>, <code>慎独</code><br><a id="more"></a></p></blockquote><p>　　年前和学弟吃了个饭，听他讲了讲毕业这半年有什么变化，进步了多少，因为公司涉及的领域各有不同，所以技术领域或者说业务领域有很大的差别，没有什么反复探讨的东西，不过有一句话倒是令我影响深刻：<code>其他人或者公司不注重的细节，积累起来就是自身的核心价值。</code></p><p>　　<strong>don’t be nervous</strong>，这一年在亚信做了一些小事儿，佣金业务，智能调度，监控预警等，相应的也接触到了一些”新鲜”的技术, 微服务(SpringBoot), 微服务治理框架(SpringCloud, Dubbo), 分布式定时任务调度平台(elastic-job,xxl-job), 消息中间件(rabbitMQ, rocketMQ, kafka), 全文搜索引擎(Elasticsearch)等，能结合业务的发展方向对基础技术有一定的预判和快速上手，在面对方方面面的技术过程中，最重要的就是不要害怕，不要惊慌失措，不要逃避，这就是学习工程化，在技术宽度达到一定阶段后，就能根据不同的业务需求，进行技术选型，避免业务发展受到基础技术的拖累而不知所措。</p><p>　　<strong>业务or技术</strong>，纯粹的业务做的久了，难免心生倦怠，觉得技术得不到成长，工作内容除了<code>CRUD</code>就是<code>if...else</code>,就算接到有挑战的开发任务,有了上面<code>don&#39;t be nervous</code>的心态之后，也能心态平和的迎刃而解。我当然知道这是很多开发者面对的问题。其实这是一种相对割裂的眼光看问题，<code>实际上，所谓的业务代码和技术代码，它们的区别，仅仅是和业务的距离远近不同而已：业务代码离业务更近，技术代码离业务稍远。他们最终都是指向业务实现的</code>。2018年，我没有很好的去阅读他人的代码了解全局的业务形态，也没有在自己的技术栈上下功夫深钻底层实现，其实这两者只要有一个做的出色，就能有很大的成长。每当心生倦怠的时候，不妨多读读<a href="https://mp.weixin.qq.com/s/MiV-_xkWeT-mWMZbmJ8NBA" target="_blank" rel="noopener">《对开发来讲，业务重要还是技术重要？》</a>。</p><p>　　<strong>人情味儿</strong>，其实说到一个公司的人情味儿，当然离不开领导的关怀，组内和睦。我这里主要想说的是关于开发过程中，项目组或者说开发小组所给予的试错空间，容错性，很大程度上每个人写的代码都会被组长review一遍，或者就算是生产出了问题，自然有测试同事和负责发版的同事发现并修复，只要不导致重大生产后果，上线之后还存活的bug也不会被专门针对，逐渐的开发少了对自己代码负责的心态，没有对代码敬畏之心。我曾经问一个实习生毕业之后还来亚信的原因，答案是清闲，安稳。我不觉得清闲松散是一个项目组有人情味的表现，死海效应已经泛滥。其实团队有这么大的试错性，对于提升个人技术是特别好的一件事，任何可以实现业务需求的方式，就都可以去尝试，并且分享出来一起探讨利弊是一个很好的组内技术交流方式。</p><p>　　<strong>慎独</strong>, 马未都的脱口秀节目《观复嘟嘟》曾经有一期以江湖为主题，这其中就有一段关于慎独更加清晰明了的对话。一位女观众问：“像我们这种普通人如果要在江湖上混，应该注意些什么？” 他说：“<code>要很注意的一点，就是古人一再提醒的叫慎独。慎独就是你一个人独处的时候，你自己给自己一个交代，你给自己内心一个交代，我老说，你这事你对谁都不重要，对你自己最重要</code>。你当下所有对工作的敷衍，最后都成了人生对你的敷衍。希望2019以此为戒，对自己负责。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：&lt;code&gt;don&amp;#39;t be nervous&lt;/code&gt;, &lt;code&gt;业务or技术&lt;/code&gt;, &lt;code&gt;人情味儿&lt;/code&gt;, &lt;code&gt;慎独&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Life-Talk" scheme="http://imbotao.top/tags/Life-Talk/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Jest 实践</title>
    <link href="http://imbotao.top/es-jest-practice.html"/>
    <id>http://imbotao.top/es-jest-practice.html</id>
    <published>2018-12-24T12:30:11.000Z</published>
    <updated>2019-05-10T03:32:28.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h2><p><a href="https://github.com/searchbox-io/Jest/tree/master/jest" target="_blank" rel="noopener">GitHub</a><br>Jest是 <code>Elasticsearch</code> 的 Java Http Rest 客户端。ElasticSearch 已经具备应用于 Elasticsearch 内部的 Java API，但是 Jest 弥补了ES自有API缺少Elasticsearch Http Rest接口客户端的不足。<br><a id="more"></a></p><h2 id="springBoot-集成-Jest-依赖"><a href="#springBoot-集成-Jest-依赖" class="headerlink" title="springBoot 集成 Jest 依赖"></a>springBoot 集成 Jest 依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.searchbox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jest&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><p><img src="/img/20170813164101013.png" alt="jest 使用"></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建查询表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> criterias</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SearchSourceBuilder <span class="title">buildSearch</span><span class="params">(List&lt;Criteria&gt; criterias, EqlPage page)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定查询的库表</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分页</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(page)) &#123;</span><br><span class="line">        searchSourceBuilder.from((page.getCurrentPage() - <span class="number">1</span>) * page.getPageRows()).size(page.getPageRows());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(criterias)) &#123;</span><br><span class="line">        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line">        criterias.stream().forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (SHOULD.equals(t.getFieldType())) &#123;</span><br><span class="line">                <span class="comment">// 设置 should 匹配条件</span></span><br><span class="line">                boolQueryBuilder.should(QueryBuilders.termQuery(t.getFieldName(), t.getFieldValue()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (MUST.equals(t.getFieldType())) &#123;</span><br><span class="line">                <span class="comment">// 设置 must 匹配条件</span></span><br><span class="line">                boolQueryBuilder.must(QueryBuilders.termQuery(t.getFieldName(), t.getFieldValue()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (RANGE.equals(t.getFieldType())) &#123;</span><br><span class="line">                <span class="comment">// 设置 range 区间匹配条件</span></span><br><span class="line">                boolQueryBuilder.must(</span><br><span class="line">                        QueryBuilders.rangeQuery(t.getFieldName()).format(DATE_FORMAT).from(t.getFieldValue()).to(t.getFieldValue2()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchSourceBuilder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * es 执行查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> searchSourceBuilder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;OrderBean&gt; <span class="title">search</span><span class="params">(SearchSourceBuilder searchSourceBuilder,EqlPage page)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    List&lt;OrderBean&gt; list = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SearchResult result = client.execute(<span class="keyword">new</span> Search.Builder(searchSourceBuilder.toString())</span><br><span class="line">                <span class="comment">// multiple index or types can be added.</span></span><br><span class="line">                .addIndex(baseConfig.getEsIndex())</span><br><span class="line">                .addType(baseConfig.getEsType())</span><br><span class="line">                <span class="comment">// 设置排序字段与排序方式</span></span><br><span class="line">                .addSort(<span class="keyword">new</span> Sort(StringUtils.isBlank(page.getSortField()) ? <span class="string">"create_time"</span> : page.getSortField(),</span><br><span class="line">                        StringUtils.isEmpty(page.getSort())</span><br><span class="line">                                ? Sort.Sorting.DESC : Sort.Sorting.ASC))</span><br><span class="line">                .build());</span><br><span class="line"></span><br><span class="line">        result.getSourceAsObjectList(OrderBean.class, <span class="keyword">false</span>);</span><br><span class="line">        List&lt;SearchResult.Hit&lt;Object, Void&gt;&gt; hits = result.getHits(Object.class);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(hits)) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"es - list size :&#123;&#125;"</span>, hits.size());</span><br><span class="line">        <span class="comment">// 将查询结果映射到java实体里</span></span><br><span class="line">        hits.stream().forEach(t -&gt; &#123;</span><br><span class="line">            String news = JSON.toJSONString(t.source);</span><br><span class="line">            OrderBean order = JSON.parseObject(news, OrderBean.class);</span><br><span class="line">            list.add(order);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 获取查询总记录数</span></span><br><span class="line">        page.setTotalRows(result.getTotal().intValue());</span><br><span class="line">        <span class="comment">// 设置总页数</span></span><br><span class="line">        page.setPageNum((page.getTotalRows() - <span class="number">1</span>) / page.getPageRows() + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">"es - 查询失败：&#123;&#125;"</span>,JSON.toJSONString(e.getMessage()));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">"9999"</span>,<span class="string">"es 查询失败：&#123;&#125;"</span>,e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Jest&quot;&gt;&lt;a href=&quot;#Jest&quot; class=&quot;headerlink&quot; title=&quot;Jest&quot;&gt;&lt;/a&gt;Jest&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/searchbox-io/Jest/tree/master/jest&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;&lt;br&gt;Jest是 &lt;code&gt;Elasticsearch&lt;/code&gt; 的 Java Http Rest 客户端。ElasticSearch 已经具备应用于 Elasticsearch 内部的 Java API，但是 Jest 弥补了ES自有API缺少Elasticsearch Http Rest接口客户端的不足。&lt;br&gt;
    
    </summary>
    
    
      <category term="ES" scheme="http://imbotao.top/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="http://imbotao.top/achieve-queues-with-two-stack.html"/>
    <id>http://imbotao.top/achieve-queues-with-two-stack.html</id>
    <published>2018-11-15T06:46:34.000Z</published>
    <updated>2019-07-22T09:36:39.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>　　用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。<br><a id="more"></a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>　　首先清楚栈和队列的特点，栈的特点是先进后出，队列的特点是先进先出。也就是说，栈的删除操作在表尾进行，队列的删除操作在表头进行。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。<br><img src="/img/immmstack.png" alt="入栈出栈思路"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; in = new Stack&lt;Integer&gt;();</span><br><span class="line">Stack&lt;Integer&gt; out = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">// 入栈 (in 栈)</span><br><span class="line">public void push(int node) &#123;</span><br><span class="line">    in.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 出栈</span><br><span class="line">public int pop() throws Exception &#123;</span><br><span class="line">    if (out.isEmpty())  // 如果 out 栈为空，in 栈不为空，把元素从 in 栈顶出栈，放到 out 栈底</span><br><span class="line">        while (!in.isEmpty())</span><br><span class="line">            out.push(in.pop());</span><br><span class="line"></span><br><span class="line">    if (out.isEmpty())</span><br><span class="line">        throw new Exception(&quot;queue is empty&quot;);</span><br><span class="line"></span><br><span class="line">    return out.pop();   // 然后从 out 的栈的栈顶出栈，就是当时最先入栈的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目来源：<a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">nowcoder</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;　　用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。&lt;br&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="http://imbotao.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="http://imbotao.top/find-in-two-dimensional-array.html"/>
    <id>http://imbotao.top/find-in-two-dimensional-array.html</id>
    <published>2018-11-14T09:34:53.000Z</published>
    <updated>2019-07-22T09:28:50.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>　　在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><a id="more"></a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从右上角开始查找。矩阵中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间。</p><p>复杂度：O(M + N) + O(1)</p><p>当前元素的查找区间为左下角的所有元素，例如元素 12 的查找区间如下：<br><img src="/img/222array.png" alt="二维数组中的查找"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean Find(int target, int[][] matrix) &#123;</span><br><span class="line">    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)</span><br><span class="line">        return false;</span><br><span class="line">    int rows = matrix.length, cols = matrix[0].length;</span><br><span class="line">    int r = 0, c = cols - 1; // 从右上角开始</span><br><span class="line">    while (r &lt;= rows - 1 &amp;&amp; c &gt;= 0) &#123;</span><br><span class="line">        if (target == matrix[r][c]) </span><br><span class="line">            return true;</span><br><span class="line">        else if (target &gt; matrix[r][c]) // 如果比右上角的数大,就往下找；否则往左找</span><br><span class="line">            r++;</span><br><span class="line">        else </span><br><span class="line">            c--;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目来源：<a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">nowcoder</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;　　在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;br&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="http://imbotao.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>关于缓存</title>
    <link href="http://imbotao.top/about-cache.html"/>
    <id>http://imbotao.top/about-cache.html</id>
    <published>2018-11-12T07:37:54.000Z</published>
    <updated>2019-07-22T09:40:27.135Z</updated>
    
    <content type="html"><![CDATA[<p>对于热点数据，缓存的价值非常大，主要解决热点数据访问的性能问题。提供高性能的数据快速访问。<br><a id="more"></a></p><h2 id="缓存特征"><a href="#缓存特征" class="headerlink" title="缓存特征"></a>缓存特征</h2><h3 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h3><p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p><p>缓存命中率越高，缓存的利用率也就越高。</p><h3 id="最大空间"><a href="#最大空间" class="headerlink" title="最大空间"></a>最大空间</h3><p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p><p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p><h3 id="清空策略"><a href="#清空策略" class="headerlink" title="清空策略"></a>清空策略</h3><ul><li><p>FIFO (First In First Out)：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</p></li><li><p>LRU (Least Recently Used)：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</p></li><li><p>LFU (less frequently used)：最少使用策略，无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。策略算法主要比较元素的hitCount（命中次数）。在保证高频数据有效性场景下，可选择这类策略。</p></li></ul><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。</p><p>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p><h3 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h3><p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p><h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p><p><strong>解决方案：</strong></p><ul><li>对这些不存在的数据缓存一个空数据；</li><li>对这类请求进行过滤。</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p><p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p><p><strong>解决方案：</strong></p><ul><li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li><li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li><li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li></ul><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p><p><strong>解决方案：</strong></p><ul><li>在数据更新的同时立即去更新缓存；</li><li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li></ul><p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p><blockquote><p>Reference: </p><ul><li><a href="https://tech.meituan.com/cache_about.html" target="_blank" rel="noopener">缓存那些事</a></li><li><a href="https://www.aspirationhosting.com/aspiration-cdn/" target="_blank" rel="noopener">How Aspiration CDN helps to improve your website loading speed?</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于热点数据，缓存的价值非常大，主要解决热点数据访问的性能问题。提供高性能的数据快速访问。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://imbotao.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>消息可靠性投递的技术方案</title>
    <link href="http://imbotao.top/message-reliability-delivery-suggestion.html"/>
    <id>http://imbotao.top/message-reliability-delivery-suggestion.html</id>
    <published>2018-11-06T02:26:26.000Z</published>
    <updated>2019-05-10T03:32:28.595Z</updated>
    
    <content type="html"><![CDATA[<p>　　使用 <code>MQ</code> 技术最常见的核心需求，需要保证消息不丢失，100%投递成功。以下是一个可靠性投递的流程图，以说明可靠性投递的概念。<br><a id="more"></a><br><img src="/img/MQkekao.jpg" alt="可靠性投递的流程图"></p><p><strong>step 1：</strong> 首先把消息信息(业务数据）存储到数据库中，紧接着，我们再把这个消息记录也存储到一张消息记录表里(者另外一个同源数据库的消息记录表)<br><strong>step 2：</strong> 发送消息到<code>MQ Broker</code>节点（采用 confirm 方式发送，会有异步的返回结果）<br><strong>step 3：</strong> 生产者端接受<code>MQ Broker</code>节点返回的 confirm 确认消息结果<br><strong>step 4：</strong> 进行更新消息记录表里的消息状态。比如默认 status = 0 当收到消息确认成功后，更新为1即可<br><strong>step 5：</strong> 但是在消息确认这个过程中可能由于网络闪断、MQ Broker端异常等原因导致 回送消息失败或者异常。这个时候就需要发送方（生产者）对消息进行可靠性投递了，保障消息不丢失，100%的投递成功！（有一种极限情况是闪断，Broker返回的成功确认消息，但是生产端由于网络闪断没收到，这个时候重新投递可能会造成消息重复，需要消费端去做幂等处理）所以我们需要有一个定时任务，（比如每5分钟拉取一下处于中间状态的消息，当然这个消息可以设置一个超时时间，比如超过1分钟 Status = 0 ，也就说明了1分钟这个时间窗口内，我们的消息没有被确认，那么会被定时任务拉取出来）<br><strong>step 6：</strong> 接下来我们把中间状态的消息进行重新投递 retry send，继续发送消息到MQ ，当然也可能有多种原因导致发送失败<br><strong>step 7：</strong> 我们可以采用设置最大努力尝试次数，比如投递了3次，还是失败，那么我们可以将最终状态设置为Status = 2 ，最后 交由人工解决处理此类问题（或者把消息转储到失败表中）。</p><p>具体的技术实现细节参考慕课视频《RabbitMQ消息中间件极速入门与实战》</p><blockquote><p>Reference:</p><ul><li><a href="https://www.imooc.com/learn/1042" target="_blank" rel="noopener">RabbitMQ消息中间件极速入门与实战</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　使用 &lt;code&gt;MQ&lt;/code&gt; 技术最常见的核心需求，需要保证消息不丢失，100%投递成功。以下是一个可靠性投递的流程图，以说明可靠性投递的概念。&lt;br&gt;
    
    </summary>
    
    
      <category term="MQ" scheme="http://imbotao.top/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>保证服务可用行性的核心思路</title>
    <link href="http://imbotao.top/improve-service-availability.html"/>
    <id>http://imbotao.top/improve-service-availability.html</id>
    <published>2018-09-09T13:28:04.000Z</published>
    <updated>2019-05-10T03:32:28.593Z</updated>
    
    <content type="html"><![CDATA[<p>　　如何保障稳定性，提高可用性呢？其实，可以分为几个方面：通过技术和流程防止故障产生、并且在发生故障时，减少故障的定位时间，以及提高故障恢复时间。<br><a id="more"></a><br><img src="/img/1532601081166-ca0c87c3-569c-4c68-8679-6d7aaf8972ce.jpeg" alt="保证服务可用行性的核心思路"></p><blockquote><p>Reference:</p><ul><li>梁桂钊的知识星球 –「服务端思维」</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　如何保障稳定性，提高可用性呢？其实，可以分为几个方面：通过技术和流程防止故障产生、并且在发生故障时，减少故障的定位时间，以及提高故障恢复时间。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://imbotao.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>百度地图API-判断坐标点在多边形区域内</title>
    <link href="http://imbotao.top/judge-point-isInPolygon.html"/>
    <id>http://imbotao.top/judge-point-isInPolygon.html</id>
    <published>2018-08-29T08:12:29.000Z</published>
    <updated>2019-05-10T03:32:28.596Z</updated>
    
    <content type="html"><![CDATA[<p>　　在智能派单的业务中,判断一个订单的收货地址在哪个配送员的配送范围之内,就显得极为关键。网上参考了一些解决思路和方法,做了一些实践和归纳。<br><a id="more"></a></p><h3 id="射线法思路"><a href="#射线法思路" class="headerlink" title="射线法思路"></a>射线法思路</h3><ul><li><a href="http://www.html-js.com/article/1517" target="_blank" rel="noopener">判断一个点是否在多边形内部 [1] 射线法思路</a></li><li><a href="http://www.html-js.com/article/1528" target="_blank" rel="noopener">判断一个点是否在多边形内部 [2] 射线法实现</a></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 判断点是否在多边形内，如果点位于多边形的顶点或边上，也算做点在多边形内，直接返回true</span><br><span class="line">     * @param point 检测点</span><br><span class="line">     * @param pts   多边形的顶点</span><br><span class="line">     * @return      点在多边形内返回true,否则返回false</span><br><span class="line">     */</span><br><span class="line">    public static boolean IsPtInPoly(Point2D.Double point, List&lt;Point2D.Double&gt; pts)&#123;</span><br><span class="line"></span><br><span class="line">        int N = pts.size();</span><br><span class="line">        boolean boundOrVertex = true; //如果点位于多边形的顶点或边上，也算做点在多边形内，直接返回true</span><br><span class="line">        int intersectCount = 0;//cross points count of x</span><br><span class="line">        double precision = 2e-10; //浮点类型计算时候与0比较时候的容差</span><br><span class="line">        Point2D.Double p1, p2;//neighbour bound vertices</span><br><span class="line">        Point2D.Double p = point; //当前点</span><br><span class="line"></span><br><span class="line">        p1 = pts.get(0);//left vertex</span><br><span class="line">        for(int i = 1; i &lt;= N; ++i)&#123;//check all rays</span><br><span class="line">            if(p.equals(p1))&#123;</span><br><span class="line">                return boundOrVertex;//p is an vertex</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p2 = pts.get(i % N);//right vertex</span><br><span class="line">            if(p.x &lt; Math.min(p1.x, p2.x) || p.x &gt; Math.max(p1.x, p2.x))&#123;//ray is outside of our interests</span><br><span class="line">                p1 = p2;</span><br><span class="line">                continue;//next ray left point</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(p.x &gt; Math.min(p1.x, p2.x) &amp;&amp; p.x &lt; Math.max(p1.x, p2.x))&#123;//ray is crossing over by the algorithm (common part of)</span><br><span class="line">                if(p.y &lt;= Math.max(p1.y, p2.y))&#123;//x is before of ray</span><br><span class="line">                    if(p1.x == p2.x &amp;&amp; p.y &gt;= Math.min(p1.y, p2.y))&#123;//overlies on a horizontal ray</span><br><span class="line">                        return boundOrVertex;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if(p1.y == p2.y)&#123;//ray is vertical</span><br><span class="line">                        if(p1.y == p.y)&#123;//overlies on a vertical ray</span><br><span class="line">                            return boundOrVertex;</span><br><span class="line">                        &#125;else&#123;//before ray</span><br><span class="line">                            ++intersectCount;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;else&#123;//cross point on the left side</span><br><span class="line">                        double xinters = (p.x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y;//cross point of y</span><br><span class="line">                        if(Math.abs(p.y - xinters) &lt; precision)&#123;//overlies on a ray</span><br><span class="line">                            return boundOrVertex;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if(p.y &lt; xinters)&#123;//before ray</span><br><span class="line">                            ++intersectCount;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;//special case when ray is crossing through the vertex</span><br><span class="line">                if(p.x == p2.x &amp;&amp; p.y &lt;= p2.y)&#123;//p crossing over p2</span><br><span class="line">                    Point2D.Double p3 = pts.get((i+1) % N); //next vertex</span><br><span class="line">                    if(p.x &gt;= Math.min(p1.x, p3.x) &amp;&amp; p.x &lt;= Math.max(p1.x, p3.x))&#123;//p.x lies between p1.x &amp; p3.x</span><br><span class="line">                        ++intersectCount;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        intersectCount += 2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p2;//next ray left point</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(intersectCount % 2 == 0)&#123;//偶数在多边形外</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123; //奇数在多边形内</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="百度地图-API-的使用"><a href="#百度地图-API-的使用" class="headerlink" title="百度地图 API 的使用"></a>百度地图 API 的使用</h3><ul><li>需要申请且认证为开发者。</li><li>需要在<a href="http://lbsyun.baidu.com/apiconsole/key" target="_blank" rel="noopener">控制台</a>创建应用,获取相应的服务密钥(<code>AK</code>)</li><li>在开发文档中选择自己需要的api,根据具体api的服务文档和使用指南发送请求,使用服务即可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　在智能派单的业务中,判断一个订单的收货地址在哪个配送员的配送范围之内,就显得极为关键。网上参考了一些解决思路和方法,做了一些实践和归纳。&lt;br&gt;
    
    </summary>
    
    
      <category term="沉淀" scheme="http://imbotao.top/tags/%E6%B2%89%E6%B7%80/"/>
    
  </entry>
  
  <entry>
    <title>关于开发中单表查和连表查的取舍</title>
    <link href="http://imbotao.top/single-or-join-query.html"/>
    <id>http://imbotao.top/single-or-join-query.html</id>
    <published>2018-06-22T02:09:29.000Z</published>
    <updated>2019-05-10T03:32:28.593Z</updated>
    
    <content type="html"><![CDATA[<p>　　关于开发中单表查询和连接查询怎么取舍？连表配合索引一次查询就可以出来，单表的话可能需要 n 次读取数据库。<br><a id="more"></a> </p><h3 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h3><p>　　能单表就单表，尽量不要连表，不光有开销，连表后复用性降低，系统复杂性会增加。而且数据库做关联是很耗性能的。把连表查拆分成两次查询也是基于查出结果的 idList 去查另一张表，开销很小，查询出的结果可以做一次merge组合。</p><h3 id="通用的-merge-方法"><a href="#通用的-merge-方法" class="headerlink" title="通用的 merge 方法"></a>通用的 merge 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wave</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2018-06-20 11:24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把 sourceList 的一些属性合并到 targetList 中</span></span><br><span class="line"><span class="comment">     * 基于 testFunction 的条件,合入逻辑实现为 biConsumer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> testFunction</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> biConsumer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;S&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, S&gt; <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(List&lt;T&gt; targetList, List&lt;S&gt; sourceList,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    BiFunction&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> S,Boolean&gt; testFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> S&gt; biConsumer)</span> </span>&#123;</span><br><span class="line">        targetList.forEach((t)-&gt;&#123;</span><br><span class="line">            Optional&lt;S&gt; optional = sourceList.stream().filter(s -&gt; testFunction.apply(t,s)).findFirst();</span><br><span class="line">            <span class="keyword">if</span> (optional.isPresent()) &#123;</span><br><span class="line">                biConsumer.accept(t,optional.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基于两个 list 的 id 做关联, 将 name 属性 merge 到目标 list </span><br><span class="line"> *</span><br><span class="line">**/</span><br><span class="line">MergeUtil.merge(targetList,sourceList,</span><br><span class="line">                (target,source)-&gt;target.id().equals(source.id()),</span><br><span class="line">                (target,source)-&gt;target.setName(source.getName));</span><br></pre></td></tr></table></figure><blockquote><p>Reference:</p><ul><li>梁桂钊的知识星球 –「服务端思维」</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　关于开发中单表查询和连接查询怎么取舍？连表配合索引一次查询就可以出来，单表的话可能需要 n 次读取数据库。&lt;br&gt;
    
    </summary>
    
    
      <category term="沉淀" scheme="http://imbotao.top/tags/%E6%B2%89%E6%B7%80/"/>
    
  </entry>
  
</feed>
