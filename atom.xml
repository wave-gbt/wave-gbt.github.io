<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wave&#39;s blog</title>
  
  <subtitle>Less is More</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://imbotao.top/"/>
  <updated>2019-05-12T08:24:42.016Z</updated>
  <id>http://imbotao.top/</id>
  
  <author>
    <name>wave</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最长公共前缀</title>
    <link href="http://imbotao.top/longest-common-prefix.html"/>
    <id>http://imbotao.top/longest-common-prefix.html</id>
    <published>2019-05-12T08:14:14.000Z</published>
    <updated>2019-05-12T08:24:42.016Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。<br><a id="more"></a></p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong><br>先利用<code>Arrays.sort(strs)</code>为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可。 </p><p><strong>实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果检查值不合法及就返回空串</span></span><br><span class="line"><span class="keyword">if</span> (!checkStrs(strs)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组长度</span></span><br><span class="line"><span class="keyword">int</span> len = strs.length;</span><br><span class="line"><span class="comment">// 用于保存结果</span></span><br><span class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// 给字符串数组的元素按照升序排序(包含数字的话，数字会排在前面)</span></span><br><span class="line">Arrays.sort(strs);</span><br><span class="line"><span class="keyword">int</span> m = strs[<span class="number">0</span>].length();</span><br><span class="line"><span class="keyword">int</span> n = strs[len - <span class="number">1</span>].length();</span><br><span class="line"><span class="keyword">int</span> num = Math.min(m, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (strs[<span class="number">0</span>].charAt(i) == strs[len - <span class="number">1</span>].charAt(i)) &#123;</span><br><span class="line">res.append(strs[<span class="number">0</span>].charAt(i));</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkStrs</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (strs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历strs检查元素值</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (strs[i] == <span class="keyword">null</span> || strs[i].length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String[] strs = &#123; <span class="string">"customer"</span>, <span class="string">"car"</span>, <span class="string">"cat"</span> &#125;;</span><br><span class="line"><span class="comment">// String[] strs = &#123; "customer", "car", null &#125;;//空串</span></span><br><span class="line"><span class="comment">// String[] strs = &#123;&#125;;//空串</span></span><br><span class="line"><span class="comment">// String[] strs = null;//空串</span></span><br><span class="line">System.out.println(Main.replaceSpace(strs));<span class="comment">// c</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://imbotao.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>如何保证幂等机制</title>
    <link href="http://imbotao.top/how-to-guarantee-idempotent-mechanism.html"/>
    <id>http://imbotao.top/how-to-guarantee-idempotent-mechanism.html</id>
    <published>2019-05-12T06:39:49.000Z</published>
    <updated>2019-05-12T07:20:46.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>　　其实这是一个很常见的问题，做后端开发会经常遇到这个问题，如何保证消息消费不被重复消费，或者说如何保证一个接口多次调用只会产生一种结果，不管调多少次，资源都不会发生改变。如果重复消费了或者调用了，如何保证不造成系统异常。所以幂等机制的核心就是保证资源唯一性。<br><a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>　　需要保证幂等性的场景就是需要限定接口只能调用一次；消息重复消费之后，要保证资源不会发生改变。例如：</p><ul><li>支付接口</li><li>退款接口</li><li>新增数据的接口</li><li>…</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>利用数据库的唯一索引，针对我们需要约束的资源字段创建唯一索引，可以防止插入重复的数据。需要注意的是，如果是分库分表的情况，唯一索引的情况就不能限制资源数据的唯一性。</li><li>可以先根据数据库唯一索引查一下，如果存在，就做更新操作。 这块要注意的是如何避免并发场景（分布式锁）。</li><li>如果是直接写 redis，每次都是set，天然就幂等的。</li><li>利用 redis 做一层校验，每次调接口或这消费消息之前先查一下 redis 里有没有全局的ID，如果没有消费过，加redis，再处理消息或接口。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;　　其实这是一个很常见的问题，做后端开发会经常遇到这个问题，如何保证消息消费不被重复消费，或者说如何保证一个接口多次调用只会产生一种结果，不管调多少次，资源都不会发生改变。如果重复消费了或者调用了，如何保证不造成系统异常。所以幂等机制的核心就是保证资源唯一性。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://imbotao.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="沉淀" scheme="http://imbotao.top/tags/%E6%B2%89%E6%B7%80/"/>
    
  </entry>
  
  <entry>
    <title>All Or Nothing</title>
    <link href="http://imbotao.top/goodbye-2018.html"/>
    <id>http://imbotao.top/goodbye-2018.html</id>
    <published>2019-01-02T12:51:23.000Z</published>
    <updated>2019-05-10T03:32:28.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>关键字</strong>：<code>don&#39;t be nervous</code>, <code>业务or技术</code>, <code>人情味儿</code>, <code>慎独</code><br><a id="more"></a></p></blockquote><p>　　年前和学弟吃了个饭，听他讲了讲毕业这半年有什么变化，进步了多少，因为公司涉及的领域各有不同，所以技术领域或者说业务领域有很大的差别，没有什么反复探讨的东西，不过有一句话倒是令我影响深刻：<code>其他人或者公司不注重的细节，积累起来就是自身的核心价值。</code></p><p>　　<strong>don’t be nervous</strong>，这一年在亚信做了一些小事儿，佣金业务，智能调度，监控预警等，相应的也接触到了一些”新鲜”的技术, 微服务(SpringBoot), 微服务治理框架(SpringCloud, Dubbo), 分布式定时任务调度平台(elastic-job,xxl-job), 消息中间件(rabbitMQ, rocketMQ, kafka), 全文搜索引擎(Elasticsearch)等，能结合业务的发展方向对基础技术有一定的预判和快速上手，在面对方方面面的技术过程中，最重要的就是不要害怕，不要惊慌失措，不要逃避，这就是学习工程化，在技术宽度达到一定阶段后，就能根据不同的业务需求，进行技术选型，避免业务发展受到基础技术的拖累而不知所措。</p><p>　　<strong>业务or技术</strong>，纯粹的业务做的久了，难免心生倦怠，觉得技术得不到成长，工作内容除了<code>CRUD</code>就是<code>if...else</code>,就算接到有挑战的开发任务,有了上面<code>don&#39;t be nervous</code>的心态之后，也能心态平和的迎刃而解。我当然知道这是很多开发者面对的问题。其实这是一种相对割裂的眼光看问题，<code>实际上，所谓的业务代码和技术代码，它们的区别，仅仅是和业务的距离远近不同而已：业务代码离业务更近，技术代码离业务稍远。他们最终都是指向业务实现的</code>。2018年，我没有很好的去阅读他人的代码了解全局的业务形态，也没有在自己的技术栈上下功夫深钻底层实现，其实这两者只要有一个做的出色，就能有很大的成长。每当心生倦怠的时候，不妨多读读<a href="https://mp.weixin.qq.com/s/MiV-_xkWeT-mWMZbmJ8NBA" target="_blank" rel="noopener">《对开发来讲，业务重要还是技术重要？》</a>。</p><p>　　<strong>人情味儿</strong>，其实说到一个公司的人情味儿，当然离不开领导的关怀，组内和睦。我这里主要想说的是关于开发过程中，项目组或者说开发小组所给予的试错空间，容错性，很大程度上每个人写的代码都会被组长review一遍，或者就算是生产出了问题，自然有测试同事和负责发版的同事发现并修复，只要不导致重大生产后果，上线之后还存活的bug也不会被专门针对，逐渐的开发少了对自己代码负责的心态，没有对代码敬畏之心。我曾经问一个实习生毕业之后还来亚信的原因，答案是清闲，安稳。我不觉得清闲松散是一个项目组有人情味的表现，死海效应已经泛滥。其实团队有这么大的试错性，对于提升个人技术是特别好的一件事，任何可以实现业务需求的方式，就都可以去尝试，并且分享出来一起探讨利弊是一个很好的组内技术交流方式。</p><p>　　<strong>慎独</strong>, 马未都的脱口秀节目《观复嘟嘟》曾经有一期以江湖为主题，这其中就有一段关于慎独更加清晰明了的对话。一位女观众问：“像我们这种普通人如果要在江湖上混，应该注意些什么？” 他说：“<code>要很注意的一点，就是古人一再提醒的叫慎独。慎独就是你一个人独处的时候，你自己给自己一个交代，你给自己内心一个交代，我老说，你这事你对谁都不重要，对你自己最重要</code>。你当下所有对工作的敷衍，最后都成了人生对你的敷衍。希望2019以此为戒，对自己负责。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：&lt;code&gt;don&amp;#39;t be nervous&lt;/code&gt;, &lt;code&gt;业务or技术&lt;/code&gt;, &lt;code&gt;人情味儿&lt;/code&gt;, &lt;code&gt;慎独&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Life-Talk" scheme="http://imbotao.top/tags/Life-Talk/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Jest 实践</title>
    <link href="http://imbotao.top/es-jest-practice.html"/>
    <id>http://imbotao.top/es-jest-practice.html</id>
    <published>2018-12-24T12:30:11.000Z</published>
    <updated>2019-05-10T03:32:28.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h2><p><a href="https://github.com/searchbox-io/Jest/tree/master/jest" target="_blank" rel="noopener">GitHub</a><br>Jest是 <code>Elasticsearch</code> 的 Java Http Rest 客户端。ElasticSearch 已经具备应用于 Elasticsearch 内部的 Java API，但是 Jest 弥补了ES自有API缺少Elasticsearch Http Rest接口客户端的不足。<br><a id="more"></a></p><h2 id="springBoot-集成-Jest-依赖"><a href="#springBoot-集成-Jest-依赖" class="headerlink" title="springBoot 集成 Jest 依赖"></a>springBoot 集成 Jest 依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.searchbox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jest&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><p><img src="/img/20170813164101013.png" alt="jest 使用"></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建查询表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> criterias</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SearchSourceBuilder <span class="title">buildSearch</span><span class="params">(List&lt;Criteria&gt; criterias, EqlPage page)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定查询的库表</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分页</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(page)) &#123;</span><br><span class="line">        searchSourceBuilder.from((page.getCurrentPage() - <span class="number">1</span>) * page.getPageRows()).size(page.getPageRows());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(criterias)) &#123;</span><br><span class="line">        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line">        criterias.stream().forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (SHOULD.equals(t.getFieldType())) &#123;</span><br><span class="line">                <span class="comment">// 设置 should 匹配条件</span></span><br><span class="line">                boolQueryBuilder.should(QueryBuilders.termQuery(t.getFieldName(), t.getFieldValue()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (MUST.equals(t.getFieldType())) &#123;</span><br><span class="line">                <span class="comment">// 设置 must 匹配条件</span></span><br><span class="line">                boolQueryBuilder.must(QueryBuilders.termQuery(t.getFieldName(), t.getFieldValue()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (RANGE.equals(t.getFieldType())) &#123;</span><br><span class="line">                <span class="comment">// 设置 range 区间匹配条件</span></span><br><span class="line">                boolQueryBuilder.must(</span><br><span class="line">                        QueryBuilders.rangeQuery(t.getFieldName()).format(DATE_FORMAT).from(t.getFieldValue()).to(t.getFieldValue2()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchSourceBuilder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * es 执行查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> searchSourceBuilder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;OrderBean&gt; <span class="title">search</span><span class="params">(SearchSourceBuilder searchSourceBuilder,EqlPage page)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    List&lt;OrderBean&gt; list = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SearchResult result = client.execute(<span class="keyword">new</span> Search.Builder(searchSourceBuilder.toString())</span><br><span class="line">                <span class="comment">// multiple index or types can be added.</span></span><br><span class="line">                .addIndex(baseConfig.getEsIndex())</span><br><span class="line">                .addType(baseConfig.getEsType())</span><br><span class="line">                <span class="comment">// 设置排序字段与排序方式</span></span><br><span class="line">                .addSort(<span class="keyword">new</span> Sort(StringUtils.isBlank(page.getSortField()) ? <span class="string">"create_time"</span> : page.getSortField(),</span><br><span class="line">                        StringUtils.isEmpty(page.getSort())</span><br><span class="line">                                ? Sort.Sorting.DESC : Sort.Sorting.ASC))</span><br><span class="line">                .build());</span><br><span class="line"></span><br><span class="line">        result.getSourceAsObjectList(OrderBean.class, <span class="keyword">false</span>);</span><br><span class="line">        List&lt;SearchResult.Hit&lt;Object, Void&gt;&gt; hits = result.getHits(Object.class);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(hits)) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"es - list size :&#123;&#125;"</span>, hits.size());</span><br><span class="line">        <span class="comment">// 将查询结果映射到java实体里</span></span><br><span class="line">        hits.stream().forEach(t -&gt; &#123;</span><br><span class="line">            String news = JSON.toJSONString(t.source);</span><br><span class="line">            OrderBean order = JSON.parseObject(news, OrderBean.class);</span><br><span class="line">            list.add(order);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 获取查询总记录数</span></span><br><span class="line">        page.setTotalRows(result.getTotal().intValue());</span><br><span class="line">        <span class="comment">// 设置总页数</span></span><br><span class="line">        page.setPageNum((page.getTotalRows() - <span class="number">1</span>) / page.getPageRows() + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">"es - 查询失败：&#123;&#125;"</span>,JSON.toJSONString(e.getMessage()));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">"9999"</span>,<span class="string">"es 查询失败：&#123;&#125;"</span>,e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Jest&quot;&gt;&lt;a href=&quot;#Jest&quot; class=&quot;headerlink&quot; title=&quot;Jest&quot;&gt;&lt;/a&gt;Jest&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/searchbox-io/Jest/tree/master/jest&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;&lt;br&gt;Jest是 &lt;code&gt;Elasticsearch&lt;/code&gt; 的 Java Http Rest 客户端。ElasticSearch 已经具备应用于 Elasticsearch 内部的 Java API，但是 Jest 弥补了ES自有API缺少Elasticsearch Http Rest接口客户端的不足。&lt;br&gt;
    
    </summary>
    
    
      <category term="ES" scheme="http://imbotao.top/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="http://imbotao.top/achieve-queues-with-two-stack.html"/>
    <id>http://imbotao.top/achieve-queues-with-two-stack.html</id>
    <published>2018-11-15T06:46:34.000Z</published>
    <updated>2019-05-10T03:32:28.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>　　用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。<br><a id="more"></a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>　　首先清楚栈和队列的特点，栈的特点是先进后出，队列的特点是先进先出。也就是说，栈的删除操作在表尾进行，队列的删除操作在表头进行。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。<br><img src="/img/immmstack.png" alt="入栈出栈思路"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; in = new Stack&lt;Integer&gt;();</span><br><span class="line">Stack&lt;Integer&gt; out = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">// 入栈 (in 栈)</span><br><span class="line">public void push(int node) &#123;</span><br><span class="line">    in.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 出栈</span><br><span class="line">public int pop() throws Exception &#123;</span><br><span class="line">    if (out.isEmpty())  // 如果 out 栈为空，in 栈不为空，把元素从 in 栈顶出栈，放到 out 栈底</span><br><span class="line">        while (!in.isEmpty())</span><br><span class="line">            out.push(in.pop());</span><br><span class="line"></span><br><span class="line">    if (out.isEmpty())</span><br><span class="line">        throw new Exception(&quot;queue is empty&quot;);</span><br><span class="line"></span><br><span class="line">    return out.pop();   // 然后从 out 的栈的栈顶出栈，就是当时最先入栈的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目来源：<a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">nowcoder</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;　　用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。&lt;br&gt;
    
    </summary>
    
    
      <category term="nowcoder" scheme="http://imbotao.top/tags/nowcoder/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="http://imbotao.top/find-in-two-dimensional-array.html"/>
    <id>http://imbotao.top/find-in-two-dimensional-array.html</id>
    <published>2018-11-14T09:34:53.000Z</published>
    <updated>2019-05-10T03:32:28.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>　　在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><a id="more"></a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从右上角开始查找。矩阵中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间。</p><p>复杂度：O(M + N) + O(1)</p><p>当前元素的查找区间为左下角的所有元素，例如元素 12 的查找区间如下：<br><img src="/img/222array.png" alt="二维数组中的查找"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean Find(int target, int[][] matrix) &#123;</span><br><span class="line">    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)</span><br><span class="line">        return false;</span><br><span class="line">    int rows = matrix.length, cols = matrix[0].length;</span><br><span class="line">    int r = 0, c = cols - 1; // 从右上角开始</span><br><span class="line">    while (r &lt;= rows - 1 &amp;&amp; c &gt;= 0) &#123;</span><br><span class="line">        if (target == matrix[r][c]) </span><br><span class="line">            return true;</span><br><span class="line">        else if (target &gt; matrix[r][c]) // 如果比右上角的数大,就往下找；否则往左找</span><br><span class="line">            r++;</span><br><span class="line">        else </span><br><span class="line">            c--;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目来源：<a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">nowcoder</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;　　在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;br&gt;
    
    </summary>
    
    
      <category term="nowcoder" scheme="http://imbotao.top/tags/nowcoder/"/>
    
  </entry>
  
  <entry>
    <title>关于缓存</title>
    <link href="http://imbotao.top/about-cache.html"/>
    <id>http://imbotao.top/about-cache.html</id>
    <published>2018-11-12T07:37:54.000Z</published>
    <updated>2019-05-10T03:32:28.594Z</updated>
    
    <content type="html"><![CDATA[<p>对于热点数据，缓存的价值非常大，主要解决热点数据访问的性能问题。提供高性能的数据快速访问。<br><a id="more"></a></p><h2 id="缓存特征"><a href="#缓存特征" class="headerlink" title="缓存特征"></a>缓存特征</h2><h3 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h3><p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p><p>缓存命中率越高，缓存的利用率也就越高。</p><h3 id="最大空间"><a href="#最大空间" class="headerlink" title="最大空间"></a>最大空间</h3><p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p><p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p><h3 id="清空策略"><a href="#清空策略" class="headerlink" title="清空策略"></a>清空策略</h3><ul><li><p>FIFO (First In First Out)：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</p></li><li><p>LRU (Least Recently Used)：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</p></li><li><p>LFU (less frequently used)：最少使用策略，无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。策略算法主要比较元素的hitCount（命中次数）。在保证高频数据有效性场景下，可选择这类策略。</p></li></ul><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。</p><p>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p><h3 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h3><p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p><h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p><p><strong>解决方案：</strong></p><ul><li>对这些不存在的数据缓存一个空数据；</li><li>对这类请求进行过滤。</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p><p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p><p><strong>解决方案：</strong></p><ul><li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li><li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li><li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li></ul><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p><p><strong>解决方案：</strong></p><ul><li>在数据更新的同时立即去更新缓存；</li><li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li></ul><p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p><blockquote><p>Reference: </p><ul><li><a href="https://tech.meituan.com/cache_about.html" target="_blank" rel="noopener">缓存那些事</a></li><li><a href="https://www.aspirationhosting.com/aspiration-cdn/" target="_blank" rel="noopener">How Aspiration CDN helps to improve your website loading speed?</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于热点数据，缓存的价值非常大，主要解决热点数据访问的性能问题。提供高性能的数据快速访问。&lt;br&gt;
    
    </summary>
    
    
      <category term="缓存" scheme="http://imbotao.top/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>消息可靠性投递的技术方案</title>
    <link href="http://imbotao.top/message-reliability-delivery-suggestion.html"/>
    <id>http://imbotao.top/message-reliability-delivery-suggestion.html</id>
    <published>2018-11-06T02:26:26.000Z</published>
    <updated>2019-05-10T03:32:28.595Z</updated>
    
    <content type="html"><![CDATA[<p>　　使用 <code>MQ</code> 技术最常见的核心需求，需要保证消息不丢失，100%投递成功。以下是一个可靠性投递的流程图，以说明可靠性投递的概念。<br><a id="more"></a><br><img src="/img/MQkekao.jpg" alt="可靠性投递的流程图"></p><p><strong>step 1：</strong> 首先把消息信息(业务数据）存储到数据库中，紧接着，我们再把这个消息记录也存储到一张消息记录表里(者另外一个同源数据库的消息记录表)<br><strong>step 2：</strong> 发送消息到<code>MQ Broker</code>节点（采用 confirm 方式发送，会有异步的返回结果）<br><strong>step 3：</strong> 生产者端接受<code>MQ Broker</code>节点返回的 confirm 确认消息结果<br><strong>step 4：</strong> 进行更新消息记录表里的消息状态。比如默认 status = 0 当收到消息确认成功后，更新为1即可<br><strong>step 5：</strong> 但是在消息确认这个过程中可能由于网络闪断、MQ Broker端异常等原因导致 回送消息失败或者异常。这个时候就需要发送方（生产者）对消息进行可靠性投递了，保障消息不丢失，100%的投递成功！（有一种极限情况是闪断，Broker返回的成功确认消息，但是生产端由于网络闪断没收到，这个时候重新投递可能会造成消息重复，需要消费端去做幂等处理）所以我们需要有一个定时任务，（比如每5分钟拉取一下处于中间状态的消息，当然这个消息可以设置一个超时时间，比如超过1分钟 Status = 0 ，也就说明了1分钟这个时间窗口内，我们的消息没有被确认，那么会被定时任务拉取出来）<br><strong>step 6：</strong> 接下来我们把中间状态的消息进行重新投递 retry send，继续发送消息到MQ ，当然也可能有多种原因导致发送失败<br><strong>step 7：</strong> 我们可以采用设置最大努力尝试次数，比如投递了3次，还是失败，那么我们可以将最终状态设置为Status = 2 ，最后 交由人工解决处理此类问题（或者把消息转储到失败表中）。</p><p>具体的技术实现细节参考慕课视频《RabbitMQ消息中间件极速入门与实战》</p><blockquote><p>Reference:</p><ul><li><a href="https://www.imooc.com/learn/1042" target="_blank" rel="noopener">RabbitMQ消息中间件极速入门与实战</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　使用 &lt;code&gt;MQ&lt;/code&gt; 技术最常见的核心需求，需要保证消息不丢失，100%投递成功。以下是一个可靠性投递的流程图，以说明可靠性投递的概念。&lt;br&gt;
    
    </summary>
    
    
      <category term="MQ" scheme="http://imbotao.top/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>保证服务可用行性的核心思路</title>
    <link href="http://imbotao.top/improve-service-availability.html"/>
    <id>http://imbotao.top/improve-service-availability.html</id>
    <published>2018-09-09T13:28:04.000Z</published>
    <updated>2019-05-10T03:32:28.593Z</updated>
    
    <content type="html"><![CDATA[<p>　　如何保障稳定性，提高可用性呢？其实，可以分为几个方面：通过技术和流程防止故障产生、并且在发生故障时，减少故障的定位时间，以及提高故障恢复时间。<br><a id="more"></a><br><img src="/img/1532601081166-ca0c87c3-569c-4c68-8679-6d7aaf8972ce.jpeg" alt="保证服务可用行性的核心思路"></p><blockquote><p>Reference:</p><ul><li>梁桂钊的知识星球 –「服务端思维」</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　如何保障稳定性，提高可用性呢？其实，可以分为几个方面：通过技术和流程防止故障产生、并且在发生故障时，减少故障的定位时间，以及提高故障恢复时间。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://imbotao.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>百度地图API-判断坐标点在多边形区域内</title>
    <link href="http://imbotao.top/judge-point-isInPolygon.html"/>
    <id>http://imbotao.top/judge-point-isInPolygon.html</id>
    <published>2018-08-29T08:12:29.000Z</published>
    <updated>2019-05-10T03:32:28.596Z</updated>
    
    <content type="html"><![CDATA[<p>　　在智能派单的业务中,判断一个订单的收货地址在哪个配送员的配送范围之内,就显得极为关键。网上参考了一些解决思路和方法,做了一些实践和归纳。<br><a id="more"></a></p><h3 id="射线法思路"><a href="#射线法思路" class="headerlink" title="射线法思路"></a>射线法思路</h3><ul><li><a href="http://www.html-js.com/article/1517" target="_blank" rel="noopener">判断一个点是否在多边形内部 [1] 射线法思路</a></li><li><a href="http://www.html-js.com/article/1528" target="_blank" rel="noopener">判断一个点是否在多边形内部 [2] 射线法实现</a></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 判断点是否在多边形内，如果点位于多边形的顶点或边上，也算做点在多边形内，直接返回true</span><br><span class="line">     * @param point 检测点</span><br><span class="line">     * @param pts   多边形的顶点</span><br><span class="line">     * @return      点在多边形内返回true,否则返回false</span><br><span class="line">     */</span><br><span class="line">    public static boolean IsPtInPoly(Point2D.Double point, List&lt;Point2D.Double&gt; pts)&#123;</span><br><span class="line"></span><br><span class="line">        int N = pts.size();</span><br><span class="line">        boolean boundOrVertex = true; //如果点位于多边形的顶点或边上，也算做点在多边形内，直接返回true</span><br><span class="line">        int intersectCount = 0;//cross points count of x</span><br><span class="line">        double precision = 2e-10; //浮点类型计算时候与0比较时候的容差</span><br><span class="line">        Point2D.Double p1, p2;//neighbour bound vertices</span><br><span class="line">        Point2D.Double p = point; //当前点</span><br><span class="line"></span><br><span class="line">        p1 = pts.get(0);//left vertex</span><br><span class="line">        for(int i = 1; i &lt;= N; ++i)&#123;//check all rays</span><br><span class="line">            if(p.equals(p1))&#123;</span><br><span class="line">                return boundOrVertex;//p is an vertex</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p2 = pts.get(i % N);//right vertex</span><br><span class="line">            if(p.x &lt; Math.min(p1.x, p2.x) || p.x &gt; Math.max(p1.x, p2.x))&#123;//ray is outside of our interests</span><br><span class="line">                p1 = p2;</span><br><span class="line">                continue;//next ray left point</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(p.x &gt; Math.min(p1.x, p2.x) &amp;&amp; p.x &lt; Math.max(p1.x, p2.x))&#123;//ray is crossing over by the algorithm (common part of)</span><br><span class="line">                if(p.y &lt;= Math.max(p1.y, p2.y))&#123;//x is before of ray</span><br><span class="line">                    if(p1.x == p2.x &amp;&amp; p.y &gt;= Math.min(p1.y, p2.y))&#123;//overlies on a horizontal ray</span><br><span class="line">                        return boundOrVertex;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if(p1.y == p2.y)&#123;//ray is vertical</span><br><span class="line">                        if(p1.y == p.y)&#123;//overlies on a vertical ray</span><br><span class="line">                            return boundOrVertex;</span><br><span class="line">                        &#125;else&#123;//before ray</span><br><span class="line">                            ++intersectCount;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;else&#123;//cross point on the left side</span><br><span class="line">                        double xinters = (p.x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y;//cross point of y</span><br><span class="line">                        if(Math.abs(p.y - xinters) &lt; precision)&#123;//overlies on a ray</span><br><span class="line">                            return boundOrVertex;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if(p.y &lt; xinters)&#123;//before ray</span><br><span class="line">                            ++intersectCount;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;//special case when ray is crossing through the vertex</span><br><span class="line">                if(p.x == p2.x &amp;&amp; p.y &lt;= p2.y)&#123;//p crossing over p2</span><br><span class="line">                    Point2D.Double p3 = pts.get((i+1) % N); //next vertex</span><br><span class="line">                    if(p.x &gt;= Math.min(p1.x, p3.x) &amp;&amp; p.x &lt;= Math.max(p1.x, p3.x))&#123;//p.x lies between p1.x &amp; p3.x</span><br><span class="line">                        ++intersectCount;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        intersectCount += 2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p2;//next ray left point</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(intersectCount % 2 == 0)&#123;//偶数在多边形外</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123; //奇数在多边形内</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="百度地图-API-的使用"><a href="#百度地图-API-的使用" class="headerlink" title="百度地图 API 的使用"></a>百度地图 API 的使用</h3><ul><li>需要申请且认证为开发者。</li><li>需要在<a href="http://lbsyun.baidu.com/apiconsole/key" target="_blank" rel="noopener">控制台</a>创建应用,获取相应的服务密钥(<code>AK</code>)</li><li>在开发文档中选择自己需要的api,根据具体api的服务文档和使用指南发送请求,使用服务即可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　在智能派单的业务中,判断一个订单的收货地址在哪个配送员的配送范围之内,就显得极为关键。网上参考了一些解决思路和方法,做了一些实践和归纳。&lt;br&gt;
    
    </summary>
    
    
      <category term="沉淀" scheme="http://imbotao.top/tags/%E6%B2%89%E6%B7%80/"/>
    
  </entry>
  
  <entry>
    <title>关于开发中单表查和连表查的取舍</title>
    <link href="http://imbotao.top/single-or-join-query.html"/>
    <id>http://imbotao.top/single-or-join-query.html</id>
    <published>2018-06-22T02:09:29.000Z</published>
    <updated>2019-05-10T03:32:28.593Z</updated>
    
    <content type="html"><![CDATA[<p>　　关于开发中单表查询和连接查询怎么取舍？连表配合索引一次查询就可以出来，单表的话可能需要 n 次读取数据库。<br><a id="more"></a> </p><h3 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h3><p>　　能单表就单表，尽量不要连表，不光有开销，连表后复用性降低，系统复杂性会增加。而且数据库做关联是很耗性能的。把连表查拆分成两次查询也是基于查出结果的 idList 去查另一张表，开销很小，查询出的结果可以做一次merge组合。</p><h3 id="通用的-merge-方法"><a href="#通用的-merge-方法" class="headerlink" title="通用的 merge 方法"></a>通用的 merge 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wave</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2018-06-20 11:24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把 sourceList 的一些属性合并到 targetList 中</span></span><br><span class="line"><span class="comment">     * 基于 testFunction 的条件,合入逻辑实现为 biConsumer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> testFunction</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> biConsumer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;S&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, S&gt; <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(List&lt;T&gt; targetList, List&lt;S&gt; sourceList,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    BiFunction&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> S,Boolean&gt; testFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> S&gt; biConsumer)</span> </span>&#123;</span><br><span class="line">        targetList.forEach((t)-&gt;&#123;</span><br><span class="line">            Optional&lt;S&gt; optional = sourceList.stream().filter(s -&gt; testFunction.apply(t,s)).findFirst();</span><br><span class="line">            <span class="keyword">if</span> (optional.isPresent()) &#123;</span><br><span class="line">                biConsumer.accept(t,optional.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基于两个 list 的 id 做关联, 将 name 属性 merge 到目标 list </span><br><span class="line"> *</span><br><span class="line">**/</span><br><span class="line">MergeUtil.merge(targetList,sourceList,</span><br><span class="line">                (target,source)-&gt;target.id().equals(source.id()),</span><br><span class="line">                (target,source)-&gt;target.setName(source.getName));</span><br></pre></td></tr></table></figure><blockquote><p>Reference:</p><ul><li>梁桂钊的知识星球 –「服务端思维」</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　关于开发中单表查询和连接查询怎么取舍？连表配合索引一次查询就可以出来，单表的话可能需要 n 次读取数据库。&lt;br&gt;
    
    </summary>
    
    
      <category term="沉淀" scheme="http://imbotao.top/tags/%E6%B2%89%E6%B7%80/"/>
    
  </entry>
  
  <entry>
    <title>Lambda 表达式</title>
    <link href="http://imbotao.top/lambda-expressions.html"/>
    <id>http://imbotao.top/lambda-expressions.html</id>
    <published>2018-04-19T06:58:54.000Z</published>
    <updated>2019-05-10T03:32:28.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Lambda"><a href="#什么是-Lambda" class="headerlink" title="什么是 Lambda?"></a>什么是 Lambda?</h2><p>我们知道，对于一个Java变量，我们可以赋给其一个“<strong>值</strong>”。<br><img src="/img/lambda/p1.jpg" alt="normal"></p><p>如果你想把“<strong>一块代码</strong>”赋给一个Java变量，应该怎么做呢？<br><a id="more"></a></p><p>比如，我想把右边那块代码，赋给一个叫做<code>aBlockOfCode</code>的Java变量：<br><img src="/img/lambda/p2.jpg" alt="p2"></p><p>在Java 8之前，这个是做不到的。但是Java 8问世之后，利用Lambda特性，就可以做到了。<br><img src="/img/lambda/p3.jpg" alt="p3"></p><p>当然，这个并不是一个很简洁的写法。所以，为了使这个赋值操作更加<strong>elegant</strong>, 我们可以移除一些没用的声明。<br><img src="/img/lambda/p4.jpg" alt="p4"></p><p>这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。<strong>而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式</strong>。<br>但是这里仍然有一个问题，就是变量<code>aBlockOfCode</code>的类型应该是什么？在Java 8里面，<strong>所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现</strong>。这是我认为理解Lambda的一个关键所在，简而言之就是，<strong>Lambda表达式本身就是一个接口的实现</strong>。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型：</p><p><img src="/img/lambda/p5.jpg" alt="p5"><br>这种只有<strong>一个接口函数需要被实现的接口类型，我们叫它”函数式接口“</strong>。为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了：<br><img src="/img/lambda/p6.jpg" alt="p6"></p><p>这样，我们就得到了一个完整的Lambda表达式声明：<br><img src="/img/lambda/p7.jpg" alt="p7"></p><h2 id="Lambda表达式有什么作用"><a href="#Lambda表达式有什么作用" class="headerlink" title="Lambda表达式有什么作用?"></a>Lambda表达式有什么作用?</h2><p><strong>最直观的作用就是使得代码变得异常简洁。</strong><br>我们可以对比一下Lambda表达式和传统的Java对同一个接口的实现：<br><img src="/img/lambda/p8.jpg" alt="p8"></p><p>这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于Lambda可以直接赋值给一个变量，<strong>我们就可以直接把Lambda作为参数传给函数, 而传统的Java必须有明确的接口实现的定义，初始化才行：</strong><br><img src="/img/lambda/p9.jpg" alt="p9"><br>有些情况下，这个接口实现只需要用到一次。传统的Java 7必须要求你定义一个“污染环境”的接口实现MyInterfaceImpl，而相较之下Java 8的Lambda, 就显得干净很多。</p><h2 id="Lambda结合FunctionalInterface-Lib-forEach-stream-，method-reference等新特性可以使代码变的更加简洁！"><a href="#Lambda结合FunctionalInterface-Lib-forEach-stream-，method-reference等新特性可以使代码变的更加简洁！" class="headerlink" title="Lambda结合FunctionalInterface Lib, forEach, stream()，method reference等新特性可以使代码变的更加简洁！"></a>Lambda结合FunctionalInterface Lib, forEach, stream()，method reference等新特性可以使代码变的更加简洁！</h2><p>直接上例子。</p><p>假设Person的定义和List<person>的值都给定。<br><img src="/img/lambda/p10.jpg" alt="p10"><br>现在需要你打印出guiltyPersons List里面所有LastName以”Z”开头的人的FirstName。</person></p><p><strong>原生态Lambda写法</strong>：定义两个函数式接口，定义一个静态函数，调用静态函数并给参数赋值Lambda表达式。<br><img src="/img/lambda/p12.jpg" alt="p12"><br>这个代码实际上已经比较简洁了，但是我们还可以更简洁么？当然可以。在Java 8中有一个函数式接口的包，里面定义了大量可能用到的函数式接口（<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">java.util.function (Java Platform SE 8 )</a>）。所以，我们在这里压根都不需要定义NameChecker和Executor这两个函数式接口，直接用Java 8函数式接口包里的Predicate<t>和Consumer<t>就可以了——因为他们这一对的接口定义和NameChecker/Executor其实是一样的。<br><img src="/img/lambda/pp.jpg" alt="pp"><br><strong>第一步简化 - 利用函数式接口包：</strong><br><img src="/img/lambda/p13.jpg" alt="p13"><br>静态函数里面的for each循环其实是非常碍眼的。这里可以利用Iterable自带的forEach()来替代。forEach()本身可以接受一个Consumer<t> 参数。<br><strong>第二步简化 - 用Iterable.forEach()取代foreach loop：</strong><br><img src="/img/lambda/p14.jpg" alt="p14"><br>由于静态函数其实只是对List进行了一通操作，这里我们可以甩掉静态函数，直接使用stream()特性来完成。stream()的几个方法都是接受Predicate<t>，Consumer<t>等参数的（<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">java.util.stream (Java Platform SE 8 )</a>）。你理解了上面的内容，stream()这里就非常好理解了，并不需要多做解释。<br><strong>第三步简化 - 利用stream()替代静态函数：</strong><br><img src="/img/lambda/p15.jpg" alt="p15"><br>对比最开始的Lambda写法，这里已经非常非常简洁了。但是如果，我们的要求变一下，变成print这个人的全部信息，及p -&gt; System.out.println(p); 那么还可以利用Method reference来继续简化。所谓Method reference, 就是用已经写好的别的Object/Class的method来代替Lambda expression。格式如下：<br><img src="/img/lambda/p16.jpg" alt="p16"><br><strong>第四步简化 - 如果是println(p)，则可以利用Method reference代替forEach中的Lambda表达式：</strong><br><img src="/img/lambda/p17.jpg" alt="p17"><br>这基本上就是能写的最简洁的版本了。</t></t></t></t></t></p><h2 id="Lambda配合Optional可以使Java对于null的处理变的异常优雅"><a href="#Lambda配合Optional可以使Java对于null的处理变的异常优雅" class="headerlink" title="Lambda配合Optional可以使Java对于null的处理变的异常优雅"></a>Lambda配合Optional<t>可以使Java对于null的处理变的异常优雅</t></h2><p>这里假设我们有一个person object，以及一个person object的Optional wrapper:<br><img src="/img/lambda/p18.jpg" alt="p18"><br>Optional<t>如果不结合Lambda使用的话，并不能使原来繁琐的null check变的简单。<br><img src="/img/lambda/p20.jpg" alt="p20"><br><strong>只有当Optional<t>结合Lambda一起使用的时候，才能发挥出其真正的威力！</t></strong></t></p><p>我们现在就来对比一下下面四种常见的null处理中，Java 8的Lambda+Optional<t>和传统Java两者之间对于null的处理差异。<br><strong>情况一 - 存在则开干</strong><br><img src="/img/lambda/p21.jpg" alt="p21"><br><strong>情况二 - 存在则返回，无则返回屁</strong><br><img src="/img/lambda/p22.jpg" alt="p22"><br><strong>情况三 - 存在则返回，无则由函数产生</strong><br><img src="/img/lambda/p23.jpg" alt="p23"><br><strong>情况四 - 夺命连环null检查</strong><br><img src="/img/lambda/p24.jpg" alt="p24"><br>由上述四种情况可以清楚地看到，Optional<t>+Lambda可以让我们少写很多ifElse块。尤其是对于情况四那种夺命连环null检查，传统java的写法显得冗长难懂，而新的Optional<t>+Lambda则清新脱俗，清楚简洁。</t></t></t></p><p>关于Java的Lambda, 还有东西需要讨论和学习。比如如何handle lambda exception，如何利用Lambda的特性来进行parallel processing等。总之，我只是一如既往地介绍个大概，让你大概知道，哦！原来是这样子就OK了。网上关于Lambda有很多相关的教程，多看多练。假以时日，必定有所精益。</p><blockquote><p>Reference:　<a href="https://www.zhihu.com/question/20125256/answer/324121308" target="_blank" rel="noopener">Sevenvidia-知乎</a>　　</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Lambda&quot;&gt;&lt;a href=&quot;#什么是-Lambda&quot; class=&quot;headerlink&quot; title=&quot;什么是 Lambda?&quot;&gt;&lt;/a&gt;什么是 Lambda?&lt;/h2&gt;&lt;p&gt;我们知道，对于一个Java变量，我们可以赋给其一个“&lt;strong&gt;值&lt;/strong&gt;”。&lt;br&gt;&lt;img src=&quot;/img/lambda/p1.jpg&quot; alt=&quot;normal&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你想把“&lt;strong&gt;一块代码&lt;/strong&gt;”赋给一个Java变量，应该怎么做呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://imbotao.top/tags/Java/"/>
    
      <category term="Lambda" scheme="http://imbotao.top/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ 初试</title>
    <link href="http://imbotao.top/rocketmq-start-learn.html"/>
    <id>http://imbotao.top/rocketmq-start-learn.html</id>
    <published>2018-04-17T02:19:18.000Z</published>
    <updated>2019-05-10T03:32:28.590Z</updated>
    
    <content type="html"><![CDATA[<p>　　近期的项目需求需要用到消息队列, 结合实际的业务需求(佣金结算), 需要对市面上的几种消息中间件进行选型分析, 从功能维度(优先级队列、延迟队列、死信队列、重试队列、消费模式、消息过滤、消息顺序性、事务性消息等), 性能,可靠性 + 可用性, 运维管理, 日志追踪, 社区力度及生态发展等层面进行考虑, 根据各自的侧重点, 选择合适自己的消息中间件尤为重要。<br><a id="more"></a>　　<br>　　我这次选择了阿里开源的<code>RocketMQ</code>,下面主要记录下我的首次使用,与<code>Spring</code>集成,采用<code>push</code>方式接收消息。</p><h2 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apache.rocketmq.consumer.PushConsumer=WeChatConsumer</span><br><span class="line">apache.rocketmq.producer.producerGroup=WeChatProducer</span><br><span class="line">apache.rocketmq.namesrvAddr=XX.XX.XX.XX:9876</span><br></pre></td></tr></table></figure><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Producer.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者的组名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.producer.producerGroup&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String producerGroup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NameServer 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.namesrvAddr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultMQProducer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//生产者的组名</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(producerGroup);</span><br><span class="line">        <span class="comment">//指定NameServer地址，多个地址以 ; 隔开</span></span><br><span class="line">        producer.setNamesrvAddr(namesrvAddr);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  从文件中获取待消费消息数据：</span></span><br><span class="line"><span class="comment">        *  4418040302625808|2018-04-03 10:35:52|81|820|16608187978|2018-04-03 14:22:56|9095180232</span></span><br><span class="line"><span class="comment">           6518040101499088|2018-04-01 10:50:20|75|750|13037219257|2018-04-03 14:22:55|3579901463</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        File fin = <span class="keyword">new</span> File(<span class="string">"E:\\work\\20180403_1432_002.REQ"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Producer对象在使用之前必须要调用start初始化，初始化一次即可</span></span><br><span class="line"><span class="comment">             * 注意：切记不可以在每次发送消息时，都调用start方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            producer.start();</span><br><span class="line">            List&lt;String&gt; msgList = ReadFile.readFile(fin);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(msgList)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            StopWatch stop = <span class="keyword">new</span> StopWatch();</span><br><span class="line">            stop.start();</span><br><span class="line">            <span class="keyword">for</span> (String str : msgList) &#123;</span><br><span class="line">                <span class="comment">// 拆分字符串, id 记录流水号</span></span><br><span class="line">                String[] msgArr = str.split(<span class="string">"\\|"</span>);</span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"WXData"</span>,<span class="string">"push"</span>,msgArr[<span class="number">0</span>],str.getBytes());</span><br><span class="line">                <span class="comment">// 发送消息</span></span><br><span class="line">                SendResult result = producer.send(msg);</span><br><span class="line">                logger.info(<span class="string">"id:&#123;&#125;,result:&#123;&#125;"</span>, result.getMsgId(), result.getSendStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            stop.stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            producer.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者的组名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.consumer.PushConsumer&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NameServer 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.namesrvAddr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Consumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CalcCommissionService calcService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spring框架的注解，在方法上加该注解会在项目启动的时候执行该方法，也可以理解为在spring容器初始化的时候执行该方法</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultMQPushConsumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//消费者的组名</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(consumerGroup);</span><br><span class="line">        <span class="comment">//指定NameServer地址，多个地址以 ; 隔开</span></span><br><span class="line">        consumer.setNamesrvAddr(namesrvAddr);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//订阅WXData下的push消息</span></span><br><span class="line">            consumer.subscribe(<span class="string">"WXData"</span>, <span class="string">"push"</span>);</span><br><span class="line">            <span class="comment">//设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费</span></span><br><span class="line">            <span class="comment">//如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line">            consumer.setConsumeFromWhere(</span><br><span class="line">                    ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">            consumer.registerMessageListener(</span><br><span class="line">                    (List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext Context) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Message msg = list.get(<span class="number">0</span>);</span><br><span class="line">                            String msgBody = <span class="keyword">new</span> String (msg.getBody());</span><br><span class="line">                            <span class="comment">// TODO　coding...</span></span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER; <span class="comment">// 稍后重试</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;   <span class="comment">// 消费成功</span></span><br><span class="line">                    &#125;);</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * test rocketMQ</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Producer rocketMQProvider;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testMQ"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rocketMQProvider.defaultMQProducer();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　近期的项目需求需要用到消息队列, 结合实际的业务需求(佣金结算), 需要对市面上的几种消息中间件进行选型分析, 从功能维度(优先级队列、延迟队列、死信队列、重试队列、消费模式、消息过滤、消息顺序性、事务性消息等), 性能,可靠性 + 可用性, 运维管理, 日志追踪, 社区力度及生态发展等层面进行考虑, 根据各自的侧重点, 选择合适自己的消息中间件尤为重要。&lt;br&gt;
    
    </summary>
    
    
      <category term="MQ" scheme="http://imbotao.top/tags/MQ/"/>
    
      <category term="RocketMQ" scheme="http://imbotao.top/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>Java 高并发编程「三」</title>
    <link href="http://imbotao.top/java-concurrent-programming-3.html"/>
    <id>http://imbotao.top/java-concurrent-programming-3.html</id>
    <published>2018-04-07T08:38:58.000Z</published>
    <updated>2019-05-10T03:32:28.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ConcurrentMap"><a href="#ConcurrentMap" class="headerlink" title="ConcurrentMap"></a>ConcurrentMap</h2><p>　　Map(Set)如果在不加锁的情况下, 可以使用 <code>HashMap</code>,<code>treeMap</code>,<code>LinkedHashMap</code>等。如果想加锁,可以使用 <code>HashTable</code>(用的比较少),如果并发不高的情况下，可以使用 <code>Collections.synchronizedXXX</code>,如果并发性比较高的情况, 建议使用 <code>ConcurrentHashMap</code>,如果并发性比较高，并且要求排序的情况下，建议使用 <code>ConcurrentSkipListMap</code>。<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_ConcurrentMap</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 16 段, 分段锁,高并发的时候效率比较高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;(); <span class="comment">//高并发并且排序</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hashtable 本身就带锁,效率比较低</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Map&lt;String, String&gt; map = new Hashtable&lt;&gt;();</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以对 HashMap 加锁：Collections.synchronizedXXX</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Map&lt;String, String&gt; map =  new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">//TreeMap</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line">CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(ths.length);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ths.length; i++) &#123;</span><br><span class="line">ths[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++) map.put(<span class="string">"a"</span> + r.nextInt(<span class="number">100000</span>), <span class="string">"a"</span> + r.nextInt(<span class="number">100000</span>));</span><br><span class="line">latch.countDown();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Arrays.asList(ths).forEach(t-&gt;t.start());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">latch.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(end - start);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CopyOnWriteList"><a href="#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h2><p>写时复制容器 <code>copy on write</code>,多线程环境下,写时效率低,读时效率高,适合写少读多的环境。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CopyOnWriteList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; lists = </span><br><span class="line"><span class="comment">//new ArrayList&lt;&gt;(); //这个会出并发问题！</span></span><br><span class="line"><span class="comment">//new Vector();</span></span><br><span class="line"><span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ths.length; i++) &#123;</span><br><span class="line">Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) lists.add(<span class="string">"a"</span> + r.nextInt(<span class="number">10000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">ths[i] = <span class="keyword">new</span> Thread(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">runAndComputeTime(ths);</span><br><span class="line"></span><br><span class="line">System.out.println(lists.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAndComputeTime</span><span class="params">(Thread[] ths)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> s1 = System.currentTimeMillis();</span><br><span class="line">Arrays.asList(ths).forEach(t-&gt;t.start());</span><br><span class="line">Arrays.asList(ths).forEach(t-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">long</span> s2 = System.currentTimeMillis();</span><br><span class="line">System.out.println(s2 - s1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="SynchronizedList"><a href="#SynchronizedList" class="headerlink" title="SynchronizedList"></a>SynchronizedList</h2><p>　　<code>new ArrayList()</code> 是没有锁的，如果想给这个list上锁，可以通过调用<code>Collections</code> 的静态方法 <code>synchronizedList()</code>,将不加锁的容器返回成一个加了锁的容器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_SynchronizedList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; strs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; strsSync = Collections.synchronizedList(strs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ConcurrentQueue"><a href="#ConcurrentQueue" class="headerlink" title="ConcurrentQueue"></a>ConcurrentQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_ConcurrentQueue</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Queue&lt;String&gt; strs = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="comment">// offer 类似于 add,有一个boolean类型的返回值,表示是否添加成功</span></span><br><span class="line">strs.offer(<span class="string">"a"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(strs);</span><br><span class="line"></span><br><span class="line">System.out.println(strs.size());</span><br><span class="line"><span class="comment">// 表示从队列头部拿出一个,队列数量减少一个</span></span><br><span class="line">System.out.println(strs.poll());</span><br><span class="line">System.out.println(strs.size());</span><br><span class="line"><span class="comment">// 表示从队列中拿出来，但是不删除，队列数量不会变</span></span><br><span class="line">System.out.println(strs.peek());</span><br><span class="line">System.out.println(strs.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//双端队列Deque, 可以从两端取，也可以往两端添加</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>　　无界队列，使用链表实现的阻塞式容器,添加了两个方法，<code>put</code>,<code>take</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_LinkedBlockingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">strs.put(<span class="string">"a"</span> + i); <span class="comment">//如果满了，就会等待</span></span><br><span class="line">TimeUnit.MILLISECONDS.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">"p1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" take -"</span> + strs.take()); <span class="comment">//如果空了，就会等待</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">"c"</span> + i).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>　　<code>ArrayBlockingQueue</code>,是有界队列，能装的元素的个数是固定的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T06_ArrayBlockingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">strs.put(<span class="string">"a"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strs.put(<span class="string">"aaa"</span>); <span class="comment">//满了就会等待，程序阻塞</span></span><br><span class="line"><span class="comment">//strs.add("aaa"); // 会报异常</span></span><br><span class="line"><span class="comment">//strs.offer("aaa"); // 会通过返回值通知是否添加成功</span></span><br><span class="line"><span class="comment">//strs.offer("aaa", 1, TimeUnit.SECONDS); // 一秒钟之后加不进去，就不加了</span></span><br><span class="line"></span><br><span class="line">System.out.println(strs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>　　  无界队列，队列里的每一个元素都有一个时间表示自己还有多久时间可以被消费,可以用来做执行定时任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_DelayQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> BlockingQueue&lt;MyTask&gt; tasks = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> runningTime;</span><br><span class="line"></span><br><span class="line">MyTask(<span class="keyword">long</span> rt) &#123;</span><br><span class="line"><span class="keyword">this</span>.runningTime = rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span> + runningTime;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">MyTask t1 = <span class="keyword">new</span> MyTask(now + <span class="number">1000</span>);</span><br><span class="line">MyTask t2 = <span class="keyword">new</span> MyTask(now + <span class="number">2000</span>);</span><br><span class="line">MyTask t3 = <span class="keyword">new</span> MyTask(now + <span class="number">1500</span>);</span><br><span class="line">MyTask t4 = <span class="keyword">new</span> MyTask(now + <span class="number">2500</span>);</span><br><span class="line">MyTask t5 = <span class="keyword">new</span> MyTask(now + <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">tasks.put(t1);</span><br><span class="line">tasks.put(t2);</span><br><span class="line">tasks.put(t3);</span><br><span class="line">tasks.put(t4);</span><br><span class="line">tasks.put(t5);</span><br><span class="line"></span><br><span class="line">System.out.println(tasks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(tasks.take());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h2><p>　　提供一个<code>transfer</code>方法。 消费者先启动，当生产者生产的时候，先找消费者，有消费者直接给消费者，而不是放入队列,效率更高， 用在更高的并发场景下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T08_TransferQueue</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">LinkedTransferQueue&lt;String&gt; strs = <span class="keyword">new</span> LinkedTransferQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">try &#123;</span></span><br><span class="line"><span class="comment">System.out.println(strs.take());</span></span><br><span class="line"><span class="comment">&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">e.printStackTrace();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;).start();*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//strs.transfer("aaa");</span></span><br><span class="line"></span><br><span class="line">strs.put(<span class="string">"aaa"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(strs.take());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="SynchronusQueue"><a href="#SynchronusQueue" class="headerlink" title="SynchronusQueue"></a>SynchronusQueue</h2><p>　　没有容量的队列，有消息直接被消费，而不能放入队列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_SynchronusQueue</span> </span>&#123; <span class="comment">//容量为0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(strs.take());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">strs.put(<span class="string">"aaa"</span>); <span class="comment">//阻塞等待消费者消费</span></span><br><span class="line"><span class="comment">//strs.add("aaa");</span></span><br><span class="line">System.out.println(strs.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ConcurrentMap&quot;&gt;&lt;a href=&quot;#ConcurrentMap&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentMap&quot;&gt;&lt;/a&gt;ConcurrentMap&lt;/h2&gt;&lt;p&gt;　　Map(Set)如果在不加锁的情况下, 可以使用 &lt;code&gt;HashMap&lt;/code&gt;,&lt;code&gt;treeMap&lt;/code&gt;,&lt;code&gt;LinkedHashMap&lt;/code&gt;等。如果想加锁,可以使用 &lt;code&gt;HashTable&lt;/code&gt;(用的比较少),如果并发不高的情况下，可以使用 &lt;code&gt;Collections.synchronizedXXX&lt;/code&gt;,如果并发性比较高的情况, 建议使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;,如果并发性比较高，并且要求排序的情况下，建议使用 &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="http://imbotao.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>问题沉淀「二」</title>
    <link href="http://imbotao.top/questions-share-2.html"/>
    <id>http://imbotao.top/questions-share-2.html</id>
    <published>2018-03-30T11:18:06.000Z</published>
    <updated>2019-05-10T03:32:28.598Z</updated>
    
    <content type="html"><![CDATA[<p>关键字: <code>幂等</code>、<code>CountDownLatch</code>、<code>异常处理</code>、<code>B+ 树</code><br><a id="more"></a></p><p><strong>问题：</strong> 如何保证幂等机制<br><strong>解决方案：</strong><br>　　幂等机制的核心是保证资源唯一性，例如客户端重复提交或服务端的多次重试只会产生一份结果。支付场景、退款场景，涉及金钱的交易不能出现多次扣款等问题。事实上，查询接口用于获取资源，因为它只是查询数据而不会影响到资源的变化，因此不管调用多少次接口，资源都不会改变，所以是它是幂等的。而新增接口是非幂等的，因为调用接口多次，它都将会产生资源的变化。因此，我们需要在出现重复提交时进行幂等处理。</p><p>那么，如何保证幂等机制呢？事实上，我们有很多实现方案。其中，一种方案就是常见的创建唯一索引。在数据库中针对我们需要约束的资源字段创建唯一索引，可以防止插入重复的数据。但是，遇到分库分表的情况是，唯一索引也就不那么好使了，此时，我们可以先查询一次数据库，然后判断是否约束的资源字段存在重复，没有的重复时再进行插入操作。注意的是，为了避免并发场景，我们可以通过锁机制，例如悲观锁与乐观锁保证数据的唯一性。这里，分布式锁是一种经常使用的方案，它通常情况下是一种悲观锁的实现。但是，很多人经常把悲观锁、乐观锁、分布式锁当作幂等机制的解决方案，这个是不正确的。除此之外，我们还可以引入状态机，通过状态机进行状态的约束以及状态跳转，确保同一个业务的流程化执行，从而实现数据幂等。</p><p>事实上，并不是所有的接口都要保证幂等，换句话说，是否需要幂等机制可以通过考量需不需要确保资源唯一性，例如行为日志可以不考虑幂等性。当然，还有一种设计方案是接口不考虑幂等机制，而是在业务实现的时候通过业务层面来保证，例如允许存在多份数据，但是在业务处理的时候获取最新的版本进行处理。</p><hr><p><strong>问题：</strong> <code>redis key</code> 过期后如何防止流量瞬间打在DB上?<br><strong>探讨：</strong><br>因为key过期后，不确定有多大的流量打在db上，所以，要提前reload<br>这种情况，没有特别好的方式。有文章说用分布式锁。其实是错误的，这样所有流量压力也会打到锁上，这种只是把压力转换了。<br>最好的方式只能对DB做限流，热点数据做本地缓存，这样能防止一个特别热的key，很大的流量都到DB。<br>什么是热点数据？而且基本上所有item都是长尾效应，用户能接触的只有10%的商品；剩下的90%商品都用不到缓存，<br>热与否，是会随时间的变化而变化的~，当然99%的公司，不需要考虑这个问题，所以很多时候在大流量面前<br>很多方案变的那么无力！！！</p><hr><p><strong>问题：</strong> <code>CountDownLatch</code> 实际运用在项目中什么样的场景？<br><strong>解答：</strong></p><ol><li>做某个事情可能会有前置条件，比如 A depends on B，C，那 A 要等到 B,C 任务完成了才能开始。比如聚餐，可能需要等所有人到齐才能开始，比赛颁奖需要等所有运动员赛完了，才能开始颁奖。等等…</li><li>futureTask 只是等待线程池里的线程执行完毕，但是线程间没有依赖关系，完全互相独立的。所以 fututreTask 和 countDownLatch 适用的场景不一样。</li></ol><hr><p><strong>问题：</strong> 项目中的异常一般是不是不在 controller 层 catch 处理，而是丢给专门的 ControllerAdvice 处理？<br><strong>解答：</strong><br>ControllerAdvice 处理确实是一种好方案。我们自定义一个运行时异常，然后统一处理，并且封装给一个统一格式的异常 JSON 格式。</p><hr><p><strong>问题：</strong> 为什么 B+ 树适合做索引？<br><strong>解答：</strong><br>索引本身很大，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。而 B+ 树带有顺序访问的指针，并且利用了磁盘预读以及计算机局部性原理，相比 B 树和红黑树，B+ 树的磁盘IO数最少。具体原理看：<a href="https://www.cnblogs.com/tgycoder/p/5410057.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><blockquote><p>Reference:</p><ul><li>梁桂钊的知识星球 –「服务端思维」</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字: &lt;code&gt;幂等&lt;/code&gt;、&lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;异常处理&lt;/code&gt;、&lt;code&gt;B+ 树&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="沉淀" scheme="http://imbotao.top/tags/%E6%B2%89%E6%B7%80/"/>
    
  </entry>
  
  <entry>
    <title>问题沉淀「一」</title>
    <link href="http://imbotao.top/questions-share-1.html"/>
    <id>http://imbotao.top/questions-share-1.html</id>
    <published>2018-03-28T07:40:40.000Z</published>
    <updated>2019-05-10T03:32:28.597Z</updated>
    
    <content type="html"><![CDATA[<p>关键字: <code>mysql字符编码</code>、<code>索引</code>、<code>介绍项目</code>、<code>跨库跨表关联</code><br><a id="more"></a></p><p><strong>问题：</strong> 在 join 操作时，为什么 MySQL 编码不同，性能差距很大。<br><strong>解决方案：</strong><br>　　问题字符集转换遵循由小到大的原则，因为utf8mb4是utf8的超集，所以这里把utf8转换成utf8mb4，即把t1.code转换成utf8mb4字符集，转换了之后，由于t1.code上面的索引仍然是utf8字符集，所以这个索引就被执行计划忽略了，然后t1表只能选择全表扫描。更糟糕的是，如果t2筛选出来的记录不止1条，那么t1就会被全表扫描多次，性能之差可想而知。<a href="https://mp.weixin.qq.com/s/ns9eRxjXZfUPNSpfgGA7UA?from=groupmessage&amp;isappinstalled=0" target="_blank" rel="noopener">链接:MySQL表字段字符集不同导致的索引失效问题</a></p><hr><p><strong>问题：</strong> MySQL的最左前缀在第一字段不存在的情况下，为什么使用到了索引？<br><strong>解决方案：</strong><br>　　可以认真阅读这篇文章。<a href="https://www.zhihu.com/question/36996520?from=groupmessage&amp;isappinstalled=0" target="_blank" rel="noopener">链接：mysql索引最左匹配原则的理解? - 知乎</a></p><hr><p><strong>问题：</strong> 面试中面试官让谈一谈 MySQL 中的索引，怎么回答比较好？<br><strong>解决方案：</strong><br>　　MySQL是很常用的数据库，其中改善性能最好的方式，就是通过数据库中合理地使用索引。因此，首先可以谈谈在项目中如何设计索引。其次，索引使用的注意事项有哪些，例如复合索引的最左前缀原则，范围查询对多列查询的影响等。最后，如果面试官对原理比较感兴趣，可能再聊聊数据库索引的原理，为什么要用 B-tree，聚集索引与非聚集索引的区别这些问题。此外，加分项，还可以说说自己在项目中，遇到了哪些索引的难点，例如之前提到的编码转换的索引失效问题，以及通过曲线救国的方式满足业务场景。</p><hr><p><strong>问题：</strong> 如何介绍项目<br><strong>解决方案：</strong><br>　　面试官问这个问题，主要是考察你的概述能力和全局视野。当然，今天我们聊的并不是面试题，而是我们怎么去理解和复盘我们每天做的事情。有的人经常抱怨自己每天在堆业务，但没有成长。事实上，很多情况下确实在堆业务，但并不是没有成长的。并非做中间件或者技术架构才是成长，例如我们的需求分析能力，沟通协作能力，产品思维能力，抽象建模能力等都是一个非常重要的硬实力。首先，请你静下来思考，你真的了解自己每天在做的事情吗，你真的了解自己所做的业务吗？</p><p>  好的，现在进入正文，我们如何理解和复盘项目。这里，列了一个清单，请大家好好思考下这些内容。</p><ol><li>明确项目的周期。</li><li>明确项目的价值。（为什么做这个项目，它解决了用户什么痛点，它带来什么价值？）</li><li>明确项目的功能。（这个项目涉及哪些功能？）</li><li>明确项目的技术。（这个项目用到哪些技术？）</li><li>明确个人在项目中的位置和作用。（你在这个项目的承担角色？）</li><li>明确项目的整体架构。</li><li>明确项目的优缺点,如果重新设计你会如何设计。</li><li>明确项目的亮点。（这个项目有什么亮点？）</li><li>明确技术成长。（你通过这个项目有哪些技术成长？）</li></ol><hr><p><strong>问题：</strong> 分库与分表，联合查询就遇到跨库关联和跨表关系问题，那应该怎么办？<br><strong>解决方案：</strong> </p><ol><li>其实，数据量小的情况下，怎么使用都没有问题的。</li><li>如果在数据量大的情况下，不一定分库分表，单库也不行的。看阿里编码规范，禁止存储过程，尽量不要使用join，有也不要超过3个。</li><li>联合查询不一定性能就差，如果很多join，都能用到主键或者唯一键性能也不差的。</li><li>业务解偶，单张表也能更好缓存。</li><li>在单库单表的情况下，联合查询是非常容易的。但是，随着分库与分表的演变，联合查询就遇到跨库关联和跨表关系问题。在设计之初就应该尽量避免联合查询，可以通过程序中进行拼装，或者通过反范式化设计进行规避。</li></ol><blockquote><p>Reference:</p><ul><li>梁桂钊的知识星球 –「服务端思维」</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字: &lt;code&gt;mysql字符编码&lt;/code&gt;、&lt;code&gt;索引&lt;/code&gt;、&lt;code&gt;介绍项目&lt;/code&gt;、&lt;code&gt;跨库跨表关联&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="沉淀" scheme="http://imbotao.top/tags/%E6%B2%89%E6%B7%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 高并发编程「二」</title>
    <link href="http://imbotao.top/java-concurrent-programming-2.html"/>
    <id>http://imbotao.top/java-concurrent-programming-2.html</id>
    <published>2018-03-08T01:53:28.000Z</published>
    <updated>2019-05-10T03:32:28.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="reentrantlock"><a href="#reentrantlock" class="headerlink" title="reentrantlock"></a>reentrantlock</h2><p><code>reentrantlock</code>可以用于替代<code>synchronized</code>，使用reentrantlock可以完成同样的功能,需要注意的是，必须要手动释放锁,使用<code>synchronized</code>锁定的话如果遇到异常，jvm会自动释放锁，但是<code>lock</code>必须手动释放锁，因此经常在<code>finally</code>中进行锁的释放<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> </span>&#123;</span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock(); <span class="comment">//synchronized(this)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();  <span class="comment">// 手动释放锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(<span class="string">"m2 ..."</span>);</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ReentrantLock2 rl = <span class="keyword">new</span> ReentrantLock2();</span><br><span class="line"><span class="keyword">new</span> Thread(rl::m1).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread(rl::m2).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>reentrantlock</code>可以进行<strong>尝试锁定</strong><code>tryLock</code>，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock3</span> </span>&#123;</span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用tryLock进行尝试锁定，不管锁定与否，方法都将继续执行</span></span><br><span class="line"><span class="comment"> * 可以根据tryLock的返回值来判定是否锁定</span></span><br><span class="line"><span class="comment"> * 也可以指定tryLock的时间，由于tryLock(time)抛出异常，所以要注意unclock的处理，必须放到finally中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">boolean locked = lock.tryLock();</span></span><br><span class="line"><span class="comment">System.out.println("m2 ..." + locked);</span></span><br><span class="line"><span class="comment">if(locked) lock.unlock();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">locked = lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">System.out.println(<span class="string">"m2 ..."</span> + locked);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(locked) lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ReentrantLock3 rl = <span class="keyword">new</span> ReentrantLock3();</span><br><span class="line"><span class="keyword">new</span> Thread(rl::m1).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread(rl::m2).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用<code>ReentrantLock</code>还可以调用<code>lockInterruptibly</code>方法，可以对线程<code>interrupt</code>方法做出响应<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(<span class="string">"t1 start"</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">"t1 end"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"interrupted!"</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//lock.lock();</span></span><br><span class="line">lock.lockInterruptibly(); <span class="comment">//可以对interrupt()方法做出响应</span></span><br><span class="line">System.out.println(<span class="string">"t2 start"</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"t2 end"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"interrupted!"</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">t2.interrupt(); <span class="comment">//打断线程2的等待</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ReentrantLock</code>还可以指定为<strong>公平锁</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock5</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">//参数为true表示为公平锁，请对比输出结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"获得锁"</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock5 rl=<span class="keyword">new</span> ReentrantLock5();</span><br><span class="line">        Thread th1=<span class="keyword">new</span> Thread(rl);</span><br><span class="line">        Thread th2=<span class="keyword">new</span> Thread(rl);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><code>ThreadLocal</code> 线程局部变量,<code>ThreadLocal</code>是使用空间换时间，<code>synchronized</code>是使用时间换空间,比如在<code>hibernate</code>中<code>session</code>就存在与<code>ThreadLocal</code>中，避免<code>synchronized</code>的使用.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal2</span> </span>&#123;</span><br><span class="line"><span class="comment">//volatile static Person p = new Person();</span></span><br><span class="line"><span class="keyword">static</span> ThreadLocal&lt;Person&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(tl.get());</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">tl.set(<span class="keyword">new</span> Person());</span><br><span class="line">&#125;).start(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;reentrantlock&quot;&gt;&lt;a href=&quot;#reentrantlock&quot; class=&quot;headerlink&quot; title=&quot;reentrantlock&quot;&gt;&lt;/a&gt;reentrantlock&lt;/h2&gt;&lt;p&gt;&lt;code&gt;reentrantlock&lt;/code&gt;可以用于替代&lt;code&gt;synchronized&lt;/code&gt;，使用reentrantlock可以完成同样的功能,需要注意的是，必须要手动释放锁,使用&lt;code&gt;synchronized&lt;/code&gt;锁定的话如果遇到异常，jvm会自动释放锁，但是&lt;code&gt;lock&lt;/code&gt;必须手动释放锁，因此经常在&lt;code&gt;finally&lt;/code&gt;中进行锁的释放&lt;br&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="http://imbotao.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一道有意思的多线程编程题</title>
    <link href="http://imbotao.top/java-multi-thread-problem.html"/>
    <id>http://imbotao.top/java-multi-thread-problem.html</id>
    <published>2018-03-07T01:59:52.000Z</published>
    <updated>2019-05-10T03:32:28.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现一个容器，提供两个方法，add，size<br>写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束<br><a id="more"></a></p><p><strong>代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加volatile，使t2能够得到通知</span></span><br><span class="line"><span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">lists.add(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lists.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyContainer2 c = <span class="keyword">new</span> MyContainer2();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">c.add(<span class="keyword">new</span> Object());</span><br><span class="line">System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(c.size() == <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line">&#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样给 lists 添加 <code>volatile</code> 之后，t2能够接到通知，但是t2线程的死循环很浪费cpu，再看看下面这个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加volatile，使t2能够得到通知</span></span><br><span class="line"><span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">lists.add(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lists.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyContainer4 c = <span class="keyword">new</span> MyContainer4();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">System.out.println(<span class="string">"t2启动"</span>);</span><br><span class="line"><span class="keyword">if</span>(c.size() != <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line"><span class="comment">//通知t1继续执行</span></span><br><span class="line">lock.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"t1启动"</span>);</span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">c.add(<span class="keyword">new</span> Object());</span><br><span class="line">System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(c.size() == <span class="number">5</span>) &#123;</span><br><span class="line">lock.notify();</span><br><span class="line"><span class="comment">//释放锁，让t2得以执行</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里使用<code>wait</code>和<code>notify</code>做到，wait会释放锁，而notify不会释放锁,notify之后，t1必须释放锁，t2退出后，也必须notify，通知t1继续执行,整个通信过程比较繁琐<br>下面这种方法使用<code>Latch</code>（门闩）替代wait notify来进行通知<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加volatile，使t2能够得到通知</span></span><br><span class="line"><span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">lists.add(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lists.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyContainer c = <span class="keyword">new</span> MyContainer();</span><br><span class="line"></span><br><span class="line">CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"t2启动"</span>);</span><br><span class="line"><span class="keyword">if</span> (c.size() != <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">latch.await();</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以指定等待时间</span></span><br><span class="line"><span class="comment">//latch.await(5000, TimeUnit.MILLISECONDS);</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"t1启动"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">c.add(<span class="keyword">new</span> Object());</span><br><span class="line">System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c.size() == <span class="number">5</span>) &#123;</span><br><span class="line"><span class="comment">// 打开门闩，让t2得以执行</span></span><br><span class="line">latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好处是通信方式简单，同时也可以指定等待时间,使用<code>await</code>和<code>countdown</code>方法替代<code>wait</code>和<code>notify</code>,<code>CountDownLatch</code>不涉及锁定，当count的值为零时当前线程继续运行,当不涉及同步，只是涉及线程通信的时候，用<code>synchronized + wait/notify</code>就显得太重了,这时应该考虑countdownlatch/cyclicbarrier/semaphore.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;实现一个容器，提供两个方法，add，size&lt;br&gt;写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束&lt;br&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="http://imbotao.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>cmd 与 bash 基础命令入门</title>
    <link href="http://imbotao.top/cmd-and-bash.html"/>
    <id>http://imbotao.top/cmd-and-bash.html</id>
    <published>2018-02-18T03:21:56.000Z</published>
    <updated>2019-05-10T03:32:28.592Z</updated>
    
    <content type="html"><![CDATA[<p>不论是 bash 还是 cmd ，我们也通常称它们为“命令行工具”或者是“命令行界面(CLI)”。<br>最后，为什么我们要学习它们？因为学习它们，<code>cmd</code> 可以让我们可以在 windows 或者 <code>bash</code> linux 等简单使用场景中，脱离对鼠标与用户界面的依赖，从而提高编码效率。<br><a id="more"></a></p><h2 id="CMD-基础命令"><a href="#CMD-基础命令" class="headerlink" title="CMD 基础命令"></a>CMD 基础命令</h2><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><h4 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h4><p>cd ：进入指定的目录或者是显示当前的目录。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd                 #显示当前的路径</span><br><span class="line">cd dir/sub-dir     #进入到dir中的sub-dir目录。</span><br><span class="line">d:                 #直接进入d盘</span><br></pre></td></tr></table></figure></p><h4 id="列出文件与子目录"><a href="#列出文件与子目录" class="headerlink" title="列出文件与子目录"></a>列出文件与子目录</h4><p>dir ：列出当前目录中的文件以及子目录<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure></p><p><code>dir</code> 除了能默认显示当前目录的文件以及子目录，还可以显示指定目录下的文件以及子目录，同时也会统计目录下的文件以及目录的数量。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir d:\fornt    #显示D盘font目录中的资源</span><br></pre></td></tr></table></figure></p><p><code>dir</code> 默认不显示一些特殊属性的文件(例如被隐藏了的文件)，如果想显示所有文件,可以使用 <code>/a</code> 参数。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /a</span><br></pre></td></tr></table></figure></p><p>如果只是想显示具有特定属性的文件，可以为 <code>/a</code> 参数附加对应的属性。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dir /a [d|r|h|s] #显示具有指定属性的文件</span><br><span class="line">dir /ad          #只显示目录</span><br><span class="line">dir /ar          #只显示只读文件</span><br><span class="line">dir /ah          #只显示隐藏文件</span><br><span class="line">dir /as          #只显示系统文件</span><br></pre></td></tr></table></figure></p><p><code>dir</code> 还有一个 <code>/o</code> 的参数也会比较常用，使用它可以分类显示文件以及目录。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dir /o [n | s | e | d]</span><br><span class="line">dir /on   #按名称(字母)显示</span><br><span class="line">dir /os   #按大小(从小到大)</span><br><span class="line">dir /oe   #按扩展名(字母顺序)</span><br><span class="line">dir /od   #按日期/时间(从先到后)</span><br></pre></td></tr></table></figure></p><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>mkdir | md ：新建目录<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir dir               # 新建一个dir目录</span><br><span class="line">mkdir dir1\dir2\dir3    # 连续新建三个目录。</span><br></pre></td></tr></table></figure></p><h4 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h4><p>rmdir | rd ：删除指定目录<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">md dirname</span><br><span class="line">rd dirname</span><br><span class="line">md dir1\dir2\dir3</span><br><span class="line">rd dir1\dir2\</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：如果目录中含有其它目录或者是文件，单纯使用 <code>rd</code> 将无法删除，必须要结合一些特殊的参数，例如 <code>/s</code> 强制删除 <code>/q</code> 安静模式（不会询问）。</p><h4 id="复制目录"><a href="#复制目录" class="headerlink" title="复制目录"></a>复制目录</h4><p>xcopy ：将目录复制到指定的位置。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcopy dir e:dir1 #将dir目录复制到 E盘，并重命名为dir1。</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：使用这种方式复制目录，只能将目录以及目录中的文件复制到新的位置，但是并不能将目录中的子目录以及子目录中的所有文件也复制过去。<br>但可以通过附加一个参数 <code>/e</code> 从而实现将整个目录（所有的子目录以及文件）都复制到新的位置中。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcopy dir e:dir1 /e</span><br></pre></td></tr></table></figure></p><h4 id="移动目录"><a href="#移动目录" class="headerlink" title="移动目录"></a>移动目录</h4><p>move ：将指定的目录移动到新的目录中<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move C:\Users\gt\Desktop\test distDir #将指定的目录移动到新的目录中</span><br><span class="line">move dir1 dir2                        #将dir1目录移动到dir2目录中</span><br></pre></td></tr></table></figure></p><h4 id="重命名目录"><a href="#重命名目录" class="headerlink" title="重命名目录"></a>重命名目录</h4><p>rename | ren ：重命名文件或目录名。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren dirName newDirName</span><br></pre></td></tr></table></figure></p><h4 id="显示树形目录"><a href="#显示树形目录" class="headerlink" title="显示树形目录"></a>显示树形目录</h4><p>tree ： 显示目录的树形图。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tree                          #当前目录的树形图</span><br><span class="line">tree C:\Users\gt\Desktop\     #指定目录的树形图</span><br></pre></td></tr></table></figure></p><p>PS：感觉此命令在我们写项目文档时很有用，使用它可以帮我们生成项目目录的树形结构。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h4><p>notepad : 打开window的记事本程序新建文件。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">notepad filename.ext</span><br><span class="line">notepad 1.txt</span><br><span class="line">notepad index.js</span><br></pre></td></tr></table></figure></p><p>notepad 是调用window中的记事本程序来新建文件。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>del ：删除指定的文件或者是清空指定目录中的文件。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">del filename #删除指定的文件</span><br><span class="line">del file1 file2 .. #删除多个文件</span><br><span class="line">del dir #清空指定目录下的所有文件</span><br><span class="line">del dir1 dir2 dir3 .. #清空多个目录下的文件。</span><br></pre></td></tr></table></figure></p><p>当使用 del 清空指定目录下的所有文件时，默认会有一个询问，如果想忽略询问，只需要加一个参数/q即可。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del dir /q</span><br></pre></td></tr></table></figure></p><p>出此之外，使用 del 还可以删除特定属性的文件<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">del /AR #可以删除只读文件</span><br><span class="line">del /AH #可以删除隐藏文件</span><br><span class="line">del /AS #可以删除系统文件</span><br></pre></td></tr></table></figure></p><p>最后，del 还可以结合通配符来删除匹配到文件。</p><h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><p>copy ：复制一个或者是多个文件<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">copy file.txt file<span class="emphasis">_copy.txt    #在当前目录由file.txt 复制为一个名为file_</span>copy.txt的新文件。</span><br><span class="line">copy C:\Users\Admin\Desktop\index.js index<span class="emphasis">_copy.js #将桌面上的index.js文件复制到当前目录，并命名为index_</span>copy.js</span><br><span class="line">copy file1 dir\file2 #相对目录进行复制。</span><br><span class="line">copy file1+file2 dir\file3 #将当前目录的file1与file2文件复制到dir目录中并合成一个新的file3文件。</span><br><span class="line">copy C:\Users\Admin\Desktop\ #将桌面上的所有文件复制到当前目录。</span><br></pre></td></tr></table></figure></p><p><code>copy</code> 命令还具有两个不是太常用的参数：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy file /A #复制一个ASCII文件。</span><br><span class="line">copy file /B #复制一个二进制文件。</span><br></pre></td></tr></table></figure></p><p><code>copy</code> 命令只能复制指定目录中的文件，而不能复制指定目录中的子目录和文件。<br>如果想复制目标目录下的所有文件和文件夹，可以使用 <code>xcopy</code> 命令，它相当于 <code>copy</code> 命令的扩展版。</p><h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p>move ：将指定的文件移动到新的位置。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move file.txt dir/file.txt    #将指定的文件移动到指定的目录中。</span><br><span class="line">move file.txt dir/newfile.txt #移动的同时，重新命名。</span><br></pre></td></tr></table></figure></p><h4 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h4><p>ren ：重命名文件<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren oldfilename newfilename</span><br></pre></td></tr></table></figure></p><h4 id="文件内容比较"><a href="#文件内容比较" class="headerlink" title="文件内容比较"></a>文件内容比较</h4><p>fc ：在指定的文件集中比较文件的内容<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc file1 file2 file3</span><br></pre></td></tr></table></figure></p><h4 id="打印文件"><a href="#打印文件" class="headerlink" title="打印文件"></a>打印文件</h4><p>type ：在命令行工具中打印文件内容。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type file      #打印文件file的内容。</span><br><span class="line">type dir\file  #打印指定目录中file文件的内容。</span><br></pre></td></tr></table></figure></p><p><code>type</code> 命令还可以结合通配符一起使用，打印多个文件的内容。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type dir\*     #打印指定目录dir中所有文件的内容。</span><br></pre></td></tr></table></figure></p><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><p>我们知道 <code>dir</code> 是用于列出指定目录中所有的文件或子目录，实际上 <code>dir</code> 后面还可以跟上文件名目录名或者是通配符来设置只列出匹配到的文件以及目录。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dir index.js    #列出该目录下的index.js</span><br><span class="line">dir *.js        #列出该目录下扩展名为js的所有文件。</span><br><span class="line">dir *           #列出所有文件</span><br></pre></td></tr></table></figure></p><p>与查找文件相同，<code>dir</code> 也可以查找指定的目录<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir dirname</span><br></pre></td></tr></table></figure></p><h4 id="根据内容查找文件"><a href="#根据内容查找文件" class="headerlink" title="根据内容查找文件"></a>根据内容查找文件</h4><p>find ：根据文件内容查找文件，不确定文件名称或者是扩展名时可结合通配符使用。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find "function handle" index.js #确定文件查找</span><br><span class="line">find "function handle" *.js     #根据文件名模糊查找</span><br><span class="line">find "function handle" ?.js     #查找文件名只有一个字符的js文件。</span><br><span class="line">find "function handle" /*       #查找所有文件</span><br></pre></td></tr></table></figure></p><p><code>find</code> 命令还具有一些其它有用的参数：<code>/i</code> 忽略大小写 , <code>/v</code> 只显示匹配到的文件，<code>/n</code> 显示行号。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>注意，如果想在window中设置永久的环境变量，只能通过 “我的电脑” - “属性” - “高级” - “环境变量”。<br>使用命令行来设置环境变量只对当前窗口有效，窗口关闭时，将会自动失效。</p><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>set : 通过set命令我们即可以查看指定的环境变量，也可以设置一个新的环境变量。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set               #查看当前的所有环境变量</span><br><span class="line">set PATH          #查看环境变量PATH的值。</span><br><span class="line">set key = value   #设置一个新的环境变量并赋值。</span><br><span class="line">set key = value2  #重新对指定的环境变量赋值。</span><br></pre></td></tr></table></figure></p><p>path这个环境变量是用于设置可执行文件（程序）的搜索路径，是非常常用的一个环境变量。</p><h4 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h4><p>在CMD中，如果想引用某个环境变量，则使用 <code>%env%</code> 的格式。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo %PATH%</span><br><span class="line"></span><br><span class="line">set name=usrname</span><br><span class="line">echo %name%</span><br></pre></td></tr></table></figure></p><h3 id="辅助命令"><a href="#辅助命令" class="headerlink" title="辅助命令"></a>辅助命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cls        #清除屏幕。</span><br><span class="line">cmd        #进入MS-DOS</span><br><span class="line">echo       #显示消息，或将命令回显打开或关闭。</span><br><span class="line">exit       #退出 CMD.EXE 程序(命令解释程序)。</span><br><span class="line">start      #启动单独的窗口以运行指定的程序或命令。</span><br><span class="line">calc       #启动计算器</span><br><span class="line">explorer   #打开资源管理器</span><br><span class="line">notepad    #打开记事本</span><br><span class="line">dxdiag     #检查DirectX信息</span><br><span class="line">regedt32   #注册表编辑器</span><br><span class="line">Msconfig   #系统配置实用程序</span><br><span class="line">taskmgr    #打开任务管理器</span><br><span class="line">help       #查看MS-DOS命令帮助。</span><br><span class="line">command /? #查看指定命令详细帮助文档。</span><br><span class="line">wmic       #进入wmic（Windows Management Instrumentation），它是windows管理工具命令行版，使用wmic我们可以对整个系统进行管理，例如远程连接、硬件管理、进程管理、账号管理、服务管理、目录管理、共享管理等等，可说它是一个增强版的CMD。</span><br></pre></td></tr></table></figure><h2 id="BASH-基本命令"><a href="#BASH-基本命令" class="headerlink" title="BASH 基本命令"></a>BASH 基本命令</h2><h3 id="目录操作-1"><a href="#目录操作-1" class="headerlink" title="目录操作"></a>目录操作</h3><h4 id="切换目录-1"><a href="#切换目录-1" class="headerlink" title="切换目录"></a>切换目录</h4><p>cd ：进入指定的目录。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd   #进入个人目录</span><br><span class="line">cd / #进入根目录</span><br><span class="line">cd - #返回上次的目录</span><br></pre></td></tr></table></figure></p><p>如果不确定自己当前的目录位置，可以结合 <code>pwd</code> 命令，便会在命令行中打印出当前目录路径。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure></p><h4 id="列出文件与子目录-1"><a href="#列出文件与子目录-1" class="headerlink" title="列出文件与子目录"></a>列出文件与子目录</h4><p>ls ：列出当前目录中的文件以及子目录<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line"><span class="code">``` </span></span><br><span class="line"><span class="code">`ls` 除了能默认显示当前目录的资源以及子目录，还可以显示指定目录下的文件以及子目录</span></span><br><span class="line"><span class="code">```markdown</span></span><br><span class="line"><span class="code">ls ../   #列出上级目录下的资源和子目录</span></span><br><span class="line"><span class="code">ls /     #列出根目录下的资源和子目录。</span></span><br><span class="line"><span class="code">ls /home #列出home目录下的资源和子目录。</span></span><br></pre></td></tr></table></figure></p><p><code>ls</code> 默认不显示具有特殊属性的文件(例如被隐藏了的文件)，如果想显示所有文件,可以使用 <code>-a</code> 参数<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure></p><p>如果要查看资源或目录更详细的信息，可以附加 <code>-l</code> 属性<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure></p><h4 id="创建目录-1"><a href="#创建目录-1" class="headerlink" title="创建目录"></a>创建目录</h4><p>mkdir ：创建目录。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir dir                 #创建一个目录dir</span><br><span class="line">mkdir dir1 dir2 dir3..    #同时创建多个同级目录</span><br></pre></td></tr></table></figure></p><p>如果想创建一个目录树，可以附加一个 -p 参数。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p a/b/c/d</span><br></pre></td></tr></table></figure></p><h4 id="删除目录-1"><a href="#删除目录-1" class="headerlink" title="删除目录"></a>删除目录</h4><p>rmdir ：删除空目录<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ：强制删除目录(包括非空目录)。</span><br><span class="line">rmdir emptyDir #删除一个空目录</span><br></pre></td></tr></table></figure></p><p>如果想删除一个非空目录，则需要使用 rm 命令，并使用 -rf 参数。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf dir                  #删除一个非空目录。</span><br><span class="line">rm -rf dir1 dir2 dir3       #同时删除多个非空目录。</span><br><span class="line">rm -rf pattern              #删除按照特定模式匹配到的目录。</span><br></pre></td></tr></table></figure></p><h4 id="复制目录-1"><a href="#复制目录-1" class="headerlink" title="复制目录"></a>复制目录</h4><p>cp -a ：复制目录到指定的位置。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -a dir ../dir  #将当期目录复制一份到上级目录中。</span><br><span class="line">cp -a dir dir2    #复制目录并重命名。</span><br></pre></td></tr></table></figure></p><h4 id="移动目录-1"><a href="#移动目录-1" class="headerlink" title="移动目录"></a>移动目录</h4><p>mv ：移动目录到指定位置。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv file file2                         #同级移动，相当于重命名目录file为file2</span><br><span class="line">mv file ../file2                      #将目录移动到上级目录中并重命名。</span><br><span class="line">sudo mv /home/user/file /home/        #将指定位置的目录移动到指定位置中。</span><br></pre></td></tr></table></figure></p><p>另外，<code>mv</code> 也可以结合通配符进行使用。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv * ../   #将所有的目录与文件都复制到上级目录中。</span><br></pre></td></tr></table></figure></p><h4 id="重命名目录-1"><a href="#重命名目录-1" class="headerlink" title="重命名目录"></a>重命名目录</h4><p>利用 <code>mv</code> 命令同级移动功能，并结合重命名的特点，就可以做到目录的重命名。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv file newfile2              #同级移动，相当于重命名目录file为newfile2</span><br></pre></td></tr></table></figure></p><h4 id="显示树形目录-1"><a href="#显示树形目录-1" class="headerlink" title="显示树形目录"></a>显示树形目录</h4><p>tree ：显示目录的树形图。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tree       #当前目录的树形图</span><br><span class="line">tree /     #根目录下的树形图</span><br></pre></td></tr></table></figure></p><p>PS：感觉此命令在我们写项目文档时很有用，使用它可以帮我们生成项目目录的树形图。</p><h4 id="常用目录说明"><a href="#常用目录说明" class="headerlink" title="常用目录说明"></a>常用目录说明</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/     #根目录</span><br><span class="line">/bin  #命令保存目录</span><br><span class="line">/boot #启动目录</span><br><span class="line">/dev  #设备文件命令</span><br><span class="line">/etc  #配置文件保存目录</span><br><span class="line">/home #家目录</span><br><span class="line">/lib  #系统库保存命令</span><br><span class="line">/mnt  #系统挂载目录</span><br></pre></td></tr></table></figure><h3 id="文件操作-1"><a href="#文件操作-1" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="新建文件-1"><a href="#新建文件-1" class="headerlink" title="新建文件"></a>新建文件</h4><p>touch ：新建文件<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch filename             #新建一个文件。</span><br><span class="line">touch file1 file2 file3... #同时新建多个文件。</span><br><span class="line">touch dir/file             #在指定的位置中新建一个文件。</span><br></pre></td></tr></table></figure></p><p>如果终端已经附加了 <code>vi</code> 编辑器，也可以使用 <code>vi filename</code> 的形式来创建文件，与 <code>cmd</code> 中的 <code>notepad</code> 命令功能类似。</p><h4 id="删除文件-1"><a href="#删除文件-1" class="headerlink" title="删除文件"></a>删除文件</h4><p>rm ：删除文件。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm file      #删除文件</span><br><span class="line">rm dir/file  #删除指定目录中的文件</span><br><span class="line">rm dir/*     #删除指定目录中的所有文件。</span><br></pre></td></tr></table></figure></p><h4 id="复制文件-1"><a href="#复制文件-1" class="headerlink" title="复制文件"></a>复制文件</h4><p>cp ：复制文件到指定的位置<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp file file1    #将文件复制一份并重新命名。</span><br><span class="line">cp file ../      #将文件复制一份到上级目录中。</span><br><span class="line">sudo cp file /   #将文件复制到根目录中。</span><br></pre></td></tr></table></figure></p><p><code>cp</code> 还可以结合通配符一起使用，将匹配到的文件复制到指定的位置中。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp dir/*  ./  #指定目录中的所有文件复制到当前目录中。</span><br></pre></td></tr></table></figure></p><h4 id="移动文件-1"><a href="#移动文件-1" class="headerlink" title="移动文件"></a>移动文件</h4><p>mv ：移动文件到指定的位置<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv file ../       #将文件移动到上级目录中。</span><br><span class="line">mv ../file ./     #将上级的文件移动到当前目录中。</span><br><span class="line">sudo mv file /    #将文件移动到根目录中。</span><br></pre></td></tr></table></figure></p><p>mv 不仅可以移动文件，还可以在移动后重命名文件。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv filename1 ../filename2</span><br></pre></td></tr></table></figure></p><p>mv还可以结合通配符使用。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv na?.txt ../nbc.txt</span><br></pre></td></tr></table></figure></p><h4 id="重命名文件-1"><a href="#重命名文件-1" class="headerlink" title="重命名文件"></a>重命名文件</h4><p>利用 mv 命令同级移动的功能再结合其可以重命名的特点，从而实现文件的重命名。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv file file2           #同级移动，相当于重命名文件file为file2</span><br></pre></td></tr></table></figure></p><h4 id="文件内容比较-1"><a href="#文件内容比较-1" class="headerlink" title="文件内容比较"></a>文件内容比较</h4><p>diff ：比较多个文件内容的不同<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff file1 file2 ...</span><br></pre></td></tr></table></figure></p><h4 id="打印文件-1"><a href="#打印文件-1" class="headerlink" title="打印文件"></a>打印文件</h4><p>cat ：在命令行工具中打印文件的内容<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat filename    #打印指定文件的内容</span><br><span class="line">cat file1 file2 #同时打印多个文件的内容</span><br></pre></td></tr></table></figure></p><p><code>cat</code> 命令除了能打印文件的内容，还可以合并多个文件的内容保存到一个新的文件中。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2 &gt; newfile</span><br></pre></td></tr></table></figure></p><p>除此之外，还可以结合通配符来打印匹配到的所有文件内容。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat a*</span><br><span class="line">cat *.txt</span><br></pre></td></tr></table></figure></p><p>如果查看的文件内容很多，还可以使用 <code>less</code> 命令<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less file</span><br></pre></td></tr></table></figure></p><p>然后使用 <code>space</code> 便可以向下一页一页的翻动，或者 <code>pgup</code> 向上翻页 , <code>pgdn</code> 向下翻页，<code>q</code> 则可以退出 <code>less</code> 命令。</p><h4 id="查找文件-1"><a href="#查找文件-1" class="headerlink" title="查找文件"></a>查找文件</h4><p>find ：可以根绝名称、大小、修改时间来查找指定的文件。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find -name httpd.conf #在当前目录下查找httpd.conf文件。</span><br><span class="line">find -name *.js       #在当前目录下查找所有js文件。</span><br><span class="line">find -empty           #查找所有为空的目录。</span><br><span class="line">find -size -1000      #查找小于1000KB的文件。</span><br><span class="line">find -size +1000      #查找大于1000KB的文件。</span><br></pre></td></tr></table></figure></p><p><code>find</code> 命令默认在当前目录进行查找，你也可以指定一个目录进行查找。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -name *.txt          #在根目录下查找所有的txt文件。</span><br><span class="line">find /etc -name httpd.conf  #在etc目录下查找httpd.conf文件。</span><br></pre></td></tr></table></figure></p><p>与根据文件名查找文件相同，也可以使用 <code>find</code> 按照目录名来查找目录。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name dirname</span><br></pre></td></tr></table></figure></p><h4 id="根据内容查找文件-1"><a href="#根据内容查找文件-1" class="headerlink" title="根据内容查找文件"></a>根据内容查找文件</h4><p>grep ：可以根据指定的内容来查找含有这些内容的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep pattern *  #查找当前目录含有指定匹配模式的文件。pattren可以是一个正则表达式。</span><br><span class="line">grep c *        #查找当前目录含有单词c的文件。</span><br></pre></td></tr></table></figure></p><p>如果想忽略内容的大小写可以附加一个 <code>-i</code> 的参数。<br>显示匹配行及行号附加 <code>-n</code><br>如果只显示文件名，不显示具体匹配到的内容，则附加 <code>-l</code> 参数</p><h4 id="压缩与解压"><a href="#压缩与解压" class="headerlink" title="压缩与解压"></a>压缩与解压</h4><p>gzip ：单独压缩指定的文件，压缩后删除被压缩文件，只保留压缩后的文件，并且不能压缩目录。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip file                   #压缩指定的文件</span><br><span class="line">gzip file1 file2 file3...   #同时压缩多个文件</span><br></pre></td></tr></table></figure></p><p><code>gzip</code> 还可以与通配符结合使用，压缩匹配到的文件。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip <span class="emphasis">*.*</span></span><br><span class="line">gzip ?.?.*</span><br></pre></td></tr></table></figure></p><p>若想列出某个 .gz 压缩文件中的内容，可以附加一个 <code>-l</code> 参数。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -l file.gz</span><br></pre></td></tr></table></figure></p><p>解压某个.gz 文件，则使用 <code>gunzip</code> 命令。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip file.gz</span><br></pre></td></tr></table></figure></p><p>zip ：与 <code>gzip</code> 相比 <code>zip</code> 可以压缩目录还可以将多个文件压缩在一起，并保留被压缩的文件。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip filename.zip file1 file2 ...   #将指定的文件压缩到一个新创建的压缩文件中。</span><br></pre></td></tr></table></figure></p><p><code>zip</code> 也可以结合通配符使用，压缩匹配到的文件。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip filename.zip *.txt</span><br></pre></td></tr></table></figure></p><p>更强的是 <code>zip</code> 还可以一次性压缩一个目录<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip filename.zip dir</span><br></pre></td></tr></table></figure></p><p>同样的，若想列出某个 .zip 压缩文件中的内容，可以附加一个 <code>-l</code> 参数。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -l filename.zip</span><br></pre></td></tr></table></figure></p><p>解压某个<code>.zip</code> 文件，则使用 <code>unzip</code> 命令。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip file.zip</span><br></pre></td></tr></table></figure></p><h4 id="打包与解包"><a href="#打包与解包" class="headerlink" title="打包与解包"></a>打包与解包</h4><p>tar ：它是linux下的一个打包命令，它可以将一大堆松散的文件或者是目录打包在一起，从而保证资源的完整性。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf package.tar file1 file2 file3 ...</span><br></pre></td></tr></table></figure></p><p>如果要打包一个目录，则指定目录名：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf package.tar dirname</span><br></pre></td></tr></table></figure></p><p>如果想解包，则附加 <code>-xvf</code> 的参数即可。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf package.tar</span><br></pre></td></tr></table></figure></p><p>如果只是想列出某个包中含有的文件或目录,则附加 <code>-tvf</code> 参数即可。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar tvf package.tar</span><br></pre></td></tr></table></figure></p><p><code>tar</code> 命令只能打包，而不能压缩，而 <code>gzip</code> 虽然可以压缩但是只能对文件进行单独压缩，并且只保留压缩后的文件，而不保留被压缩的文件，所以将 <code>tar</code> + <code>gzip</code> 结合使用，将会互补其短，产生更大的功效。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar package.tar file1 file2 file3 ... #将多个文件打包在package.tar包文件中。</span><br><span class="line">gzip package.tar.gz package.tar       #将通过tar打包的文件再进行压缩。</span><br></pre></td></tr></table></figure></p><p>解压缩解包也要依次进行。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gunzip package.tar.gz #解压缩</span><br><span class="line">tar -xvf package.tar  #解包</span><br></pre></td></tr></table></figure></p><p>当然，你也可以通过附加参数的方式一次性的打包压缩。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf package.tar.gz</span><br></pre></td></tr></table></figure></p><p>然后一次性的解压缩解包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf package.tar.gz</span><br></pre></td></tr></table></figure></p><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctr+c  #终止当前命令</span><br><span class="line">ctr+l  ##清屏  相当于 clear</span><br><span class="line">ctr+a  #光标移到行首</span><br><span class="line">ctr+e  #光标移到行尾</span><br><span class="line">ctr+u  #把光标所在位置删除到行首</span><br><span class="line">ctr+d  #删除光标前面的字符，一旦内容全部删除再按则会退出窗口。</span><br><span class="line">ctr+h  #删除光标后面的字符，</span><br></pre></td></tr></table></figure><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">clear   #清除屏幕。</span><br><span class="line">echo    #显示消息，或将命令回显打开或关闭。</span><br><span class="line">whoami  #返回当前登录用户名。</span><br><span class="line">passwd  #允许当前登录的用户更改其密码。</span><br><span class="line">file    #尝试判断指定文件的类型。</span><br><span class="line">exit    #退出命令行工具</span><br><span class="line">users   #显示当前登录系统地用户</span><br><span class="line">last    #查看用户的登录日志</span><br><span class="line">cammand --help  #查看相关命令的帮助文档。</span><br><span class="line">ping    #查看网络状态</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不论是 bash 还是 cmd ，我们也通常称它们为“命令行工具”或者是“命令行界面(CLI)”。&lt;br&gt;最后，为什么我们要学习它们？因为学习它们，&lt;code&gt;cmd&lt;/code&gt; 可以让我们可以在 windows 或者 &lt;code&gt;bash&lt;/code&gt; linux 等简单使用场景中，脱离对鼠标与用户界面的依赖，从而提高编码效率。&lt;br&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://imbotao.top/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>八张图理解 JAVA</title>
    <link href="http://imbotao.top/top-8-diagrams-for-understanding-java.html"/>
    <id>http://imbotao.top/top-8-diagrams-for-understanding-java.html</id>
    <published>2018-02-17T16:13:09.000Z</published>
    <updated>2019-05-10T03:32:28.593Z</updated>
    
    <content type="html"><![CDATA[<p>　　一图胜千言，下面图解均来自 Program Creek 网站的 <a href="http://www.programcreek.com/java-tutorials/" target="_blank" rel="noopener">Java教程</a>，目前它们拥有最多的票选。如果图解没有阐明问题，那么你可以借助它的标题来一窥究竟。<br><a id="more"></a></p><h2 id="字符串不变性"><a href="#字符串不变性" class="headerlink" title="字符串不变性"></a>字符串不变性</h2><p>下面这张图展示了这段代码做了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;abcd&quot;;</span><br><span class="line">s = s.concat(&quot;ef&quot;);</span><br></pre></td></tr></table></figure></p><p><img src="/img/566535260001c98e06500279.jpg" alt="字符串不变性"></p><h2 id="equals-方法、hashCode-方法的区别"><a href="#equals-方法、hashCode-方法的区别" class="headerlink" title="equals()方法、hashCode()方法的区别"></a>equals()方法、hashCode()方法的区别</h2><p>HashCode被设计用来提高性能。equals()方法与hashCode()方法的区别在于：</p><ol><li>如果两个对象相等(equal)，那么他们一定有相同的哈希值。</li><li>如果两个对象的哈希值相同，但他们未必相等(equal)。</li></ol><p><img src="/img/5665355c0001a41106500369.jpg" alt="equals"></p><h2 id="Java异常类的层次结构"><a href="#Java异常类的层次结构" class="headerlink" title="Java异常类的层次结构"></a>Java异常类的层次结构</h2><p>图中红色部分为受检查异常。它们必须被捕获，或者在函数中声明为抛出该异常。</p><p><img src="/img/56653579000175e204981024.jpg" alt="java 异常类的层次结构"></p><h2 id="集合类的层次结构"><a href="#集合类的层次结构" class="headerlink" title="集合类的层次结构"></a>集合类的层次结构</h2><p>注意Collections和Collection的区别。（Collections包含有各种有关集合操作的静态多态方法）</p><p><img src="/img/5665359400016c2f09100467.jpg" alt="集合类的层次结构"></p><h2 id="Java同步"><a href="#Java同步" class="headerlink" title="Java同步"></a>Java同步</h2><p>Java同步机制可通过类比建筑物来阐明。</p><p><img src="/img/566535b60001050603240216.jpg" alt="Java同步"></p><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>别名意味着有多个变量指向同一可被更新的内存块，这些别名分别是不同的对象类型。</p><p><img src="/img/566535fb000113f703170201.jpg" alt="别名"></p><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p>图解表明了方法和对象在运行时内存中的位置。</p><p><img src="/img/566536260001052904960257.jpg" alt="堆和栈"></p><h2 id="Java虚拟机运行时数据区域"><a href="#Java虚拟机运行时数据区域" class="headerlink" title="Java虚拟机运行时数据区域"></a>Java虚拟机运行时数据区域</h2><p>图解展示了整个虚拟机运行时数据区域的情况。</p><p><img src="/img/5665364300010ec905010363.jpg" alt="Java虚拟机运行时数据区域"></p><blockquote><p>原文链接：<a href="https://www.imooc.com/article/2592" target="_blank" rel="noopener">programcreek</a>　　翻译：ImportNew.com - era_misa<br>译文链接：<a href="http://www.importnew.com/11725.html" target="_blank" rel="noopener">http://www.importnew.com/11725.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　一图胜千言，下面图解均来自 Program Creek 网站的 &lt;a href=&quot;http://www.programcreek.com/java-tutorials/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java教程&lt;/a&gt;，目前它们拥有最多的票选。如果图解没有阐明问题，那么你可以借助它的标题来一窥究竟。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://imbotao.top/tags/Java/"/>
    
  </entry>
  
</feed>
