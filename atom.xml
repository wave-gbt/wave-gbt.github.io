<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wave&#39;s blog</title>
  
  <subtitle>Less is More</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://imbotao.top/"/>
  <updated>2019-07-19T08:26:12.639Z</updated>
  <id>http://imbotao.top/</id>
  
  <author>
    <name>wave</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Optional 解决 NPE 问题</title>
    <link href="http://imbotao.top/Solve-NPE-problems-with-Optional.html"/>
    <id>http://imbotao.top/Solve-NPE-problems-with-Optional.html</id>
    <published>2019-07-19T03:01:35.000Z</published>
    <updated>2019-07-19T08:26:12.639Z</updated>
    
    <content type="html"><![CDATA[<p>　　NPE(NullPointerException) 是 Java 程序开发中的最典型的异常，从Java类型系统的角度看，null可以被赋值给任何类型的变量，并且不断被传递，知道最后谁也不知道它是从哪里引入的。<br><a id="more"></a></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>先看一种情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.getAddress().getProvince();</span><br></pre></td></tr></table></figure></p><p>这种写法，在<code>user</code>或者<code>address</code>为<code>null</code>时，是有可能报<code>NullPointerException</code>异常的。为了解决这个问题，于是采用下面的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(user!=null)&#123;</span><br><span class="line">    Address address = user.getAddress();</span><br><span class="line">    if(address!=null)&#123;</span><br><span class="line">        String province = address.getProvince();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种写法是比较丑陋的，为了避免上述丑陋的写法，让丑陋的设计变得优雅。JAVA8 提供了<code>Optional</code>类来优化这种写法，通过类型系统让你的领域模型中隐藏的知识显式地体现在你的代码中，这样我们就不用显式进行空值检测。</p><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>static <t> Optional<t> empty()</t></t></td><td>返回空的 Optional 实例。</td></tr><tr><td>boolean equals(Object obj)</td><td>判断其他对象是否等于 Optional。</td></tr><tr><td>Optional<t> filter(Predicate&lt;? super <t> predicate)</t></t></td><td>如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。</td></tr><tr><td><u> Optional<u> flatMap(Function&lt;? super T,Optional<u>&gt; mapper)</u></u></u></td><td>如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional</td></tr><tr><td>T get()</td><td>如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException</td></tr><tr><td>int hashCode()</td><td>返回存在值的哈希码，如果值不存在 返回 0。</td></tr><tr><td>void ifPresent(Consumer&lt;? super T&gt; consumer)</td><td>如果值存在则使用该值调用 consumer , 否则不做任何事情。</td></tr><tr><td>boolean isPresent()</td><td>如果值存在则方法会返回true，否则返回 false。</td></tr><tr><td><u>Optional<u> map(Function&lt;? super T,? extends U&gt; mapper)</u></u></td><td>如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。</td></tr><tr><td>static <t> Optional<t> of(T value)</t></t></td><td>返回一个指定非null值的Optional。</td></tr><tr><td>static <t> Optional<t> ofNullable(T value)</t></t></td><td>如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。</td></tr><tr><td>T orElse(T other)</td><td>如果存在该值，返回值， 否则返回 other。</td></tr><tr><td>T orElseGet(Supplier&lt;? extends T&gt; other)</td><td>如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。</td></tr><tr><td><x extends="" throwable=""> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</x></td><td>如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常</td></tr><tr><td>String toString()</td><td>返回一个Optional的非空字符串，用来调试</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 判断一个对象的属性是否为空，为空则跑出异常</span><br><span class="line">Optional.ofNullable(user)</span><br><span class="line">                   .flatMap(u-&gt; u.getAddress())</span><br><span class="line">                   .map(a-&gt;a.getCity())</span><br><span class="line">                   .orElseThrow(()-&gt;new Exception(&quot;异常&quot;));</span><br><span class="line">               </span><br><span class="line">// 判断一个对象是否为空，不为空 do something</span><br><span class="line">Optional.ofNullable(user).ifPresent(u-&gt;&#123;</span><br><span class="line">            // do something</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">// 对 Optional 中包含的值进行过滤，如果包含的值满足条件，那么还是返回这个 Optional；否则创建一个新的对象返回</span><br><span class="line">Optional&lt;User&gt; user1 = Optional.ofNullable(user).</span><br><span class="line">                                    filter(u -&gt; &quot;wave&quot;.equals(u.getName)).</span><br><span class="line">                                    orElseGet(()-&gt; &#123;</span><br><span class="line">                                                  User user1 = new User();</span><br><span class="line">                                                  user1.setName(&quot;wave&quot;);</span><br><span class="line">                                                  return user1;</span><br><span class="line">                                             &#125;);;</span><br></pre></td></tr></table></figure><p>使用<code>Optional</code>的思路和<code>Stream</code>相同，都是链式思路，省去了繁琐的判断，在后面的开发中，可以使用Optional设计API，这样可以设计出更安全的接口和方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　NPE(NullPointerException) 是 Java 程序开发中的最典型的异常，从Java类型系统的角度看，null可以被赋值给任何类型的变量，并且不断被传递，知道最后谁也不知道它是从哪里引入的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://imbotao.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一条SQL(select/update)语句是如何执行的?</title>
    <link href="http://imbotao.top/how-is-a-sql-executed.html"/>
    <id>http://imbotao.top/how-is-a-sql-executed.html</id>
    <published>2019-06-03T07:59:04.000Z</published>
    <updated>2019-06-03T09:31:50.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>关键字</strong>：<code>基础架构</code>,<code>日志系统</code></p></blockquote><p>在执行下面这个查询语句时：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br></pre></td></tr></table></figure></p><p>MySQL 内部的执行过程，所以需要拆解一下，看看 SQL 语句在 MySQL 中各个功能模块中的执行过程。</p><a id="more"></a><p><img src="/img/1559550471446.jpg" alt="MySQL 逻辑架构图"><br>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。<br>　　Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。<br>　　而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、 MyISAM、Memory 等多个存储引擎。</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure></p><p>　　如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。<br>　　数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。<br>　　建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。<br>　　但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因 为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断 开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉 (OOM)，从现象看就是 MySQL 异常重启了。</p><p>　　怎么解决这个问题呢?你可以考虑以下两种方案：</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后， 断开连接，之后要查询再重连。</li><li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执 行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权 限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>　　MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前 执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询 的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。所以如果被缓存命中，效率会很高。<br>　　查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。所以查询缓存的命中率会非常低。<br>　　MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻 底没有这个功能了。</p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>　　分析器先会做“词法分析”，识别出具体的SQL语句查询字段和对应的表明，然后做”语法分析”，判断是否满足 MySQL 的语法。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>　　优化器是在表里面有多个索引的时候，决定使用哪个索引;或者在一个语句有多表关联 (join)的时候，决定各个表的连接顺序。　　   </p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>　　开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返 回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结 果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。<br>　　比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的:</p><ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如 果是则将这行存在结果集中;</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 </li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><hr><p><strong>如果是下面的更新语句呢？</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure></p><p>除了上述查询的那一套流程，还涉及到两个重要的日志模块。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>　　具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。<br>　　InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文 件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。<br>　　有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>　　redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog(归档日志)。</p><p>这两种日志有以下三点不同。</p><ol><li>redo log 是 InnoDB 引擎特有的;binlog 是 MySQL 的 Server 层实现的，所有引擎 都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”;binlog 是逻辑日 志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li><li>redo log 是循环写的，空间固定会用完;binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。<br><img src="/img/1559553982651.jpg" alt=""></p><ol><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器;否则，需要先从磁 盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到 新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交(commit)状态，更新完成。</li></ol><p>将 redo log 的写入拆成了两个步骤: prepare 和 commit，这就是”两阶段提交”。<br>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><blockquote><p>Reference:　[极客时间-MySQL实践45讲]　</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：&lt;code&gt;基础架构&lt;/code&gt;,&lt;code&gt;日志系统&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在执行下面这个查询语句时：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; select * from T where ID=10;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;MySQL 内部的执行过程，所以需要拆解一下，看看 SQL 语句在 MySQL 中各个功能模块中的执行过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://imbotao.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>谈谈常用分布式ID的设计方案</title>
    <link href="http://imbotao.top/distributed-id-design.html"/>
    <id>http://imbotao.top/distributed-id-design.html</id>
    <published>2019-05-20T06:53:59.000Z</published>
    <updated>2019-06-01T05:37:55.585Z</updated>
    
    <content type="html"><![CDATA[<p>　　需要明确通常的分布式 ID 的定义，基本包括:</p><ul><li>全局唯一，区别于单点系统的唯一，全局是要求分布式系统内唯一。</li><li>有序性，通常要保证生成的 ID 是有序递增的。</li></ul><p><a id="more"></a>　<br>　　目前业界的的方案主要是：</p><ul><li>基于数据库自增序列的实现。这种方式优点和缺点都非常明显，好处是简单易用，但是在扩展性和可靠性等方面存在局限性。</li><li>基于 Twitter 早期开源的Snowflake的实现，以及相关改动方案。其结构定义可以参考下面的示意图。</li></ul><p><img src="/img/ffd41494a39ef737b3c1151929c3c4ad.png" alt="分布式id结构图"></p><p>其中 10 位的WorkerID，标准定义是 5 位数据中心 + 5 位机器编码，以区分不同的集群节点。<br>最后的 12 位就是单位毫秒内可生成的序列号数目的理论极限。</p><p>　　在明确的业务场景中，我们到底需要一个什么样的分布式ID呢，除了唯一性和有序，通常还希望分布式ID：</p><ul><li>有意义，也就是说包含更多的信息，比如时间和业务信息。</li><li>高可用性，取决于我们业务对扩展性，性能方面的要求。</li><li>紧凑性，ID 的大小可能受实际应用的制约，例如太长的ID会降低 MYSQL 等数据库索引的性能。</li></ul><p>分享一个很好的分布式ID的实现 <a href="https://github.com/bingoohuang/westid" target="_blank" rel="noopener">westid</a>.</p><blockquote><p>Reference:　<a href="https://time.geekbang.org/column/intro/82" target="_blank" rel="noopener">极客时间-Java核心技术36讲</a>　</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　需要明确通常的分布式 ID 的定义，基本包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局唯一，区别于单点系统的唯一，全局是要求分布式系统内唯一。&lt;/li&gt;
&lt;li&gt;有序性，通常要保证生成的 ID 是有序递增的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://imbotao.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程学习 - 概述</title>
    <link href="http://imbotao.top/java-concurrent-programming-outline.html"/>
    <id>http://imbotao.top/java-concurrent-programming-outline.html</id>
    <published>2019-05-14T10:05:56.000Z</published>
    <updated>2019-05-14T11:18:51.086Z</updated>
    
    <content type="html"><![CDATA[<p>　　看薛兆丰的《经济学通识》，他总结到，人类面临着四大基本约束：东西不够，生命有限，互相依赖，需要协调。当我看到这句话的时候，我猛然间意识到：计算机也同样面临着这四大基本约束。<br>　　在计算中，CPU、内存、IO、硬盘、带宽等，这些资源也都有不够的时候，而每个线程的也有着自己的生命周期，并且它们之间又是相互依赖的，也同样需要协调。有了上面的这种想法，我觉得我学习计算机的知识有了章法可循。</p><a id="more"></a><p>并发编程知识全景图<br><img src="/img/11e0c64618c04edba52619f41aaa3565.png" alt="并发编程全景图之思维导图"></p><p>并发编程领域可以抽象成三个核心问题：分工、同步和互斥。</p><h2 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h2><p>类似于现实中一个组织完成一个项目，项目经理要拆分任务，安排合适的成员去完成。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>每个小任务间可能存在相互依赖，同步需要做的是在前置任务完成后，通知后置任务启动。</p><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>互斥主要解决正确性问题。互斥要求同一时间，只允许一个线程访问共享变量。</p><p><strong>学习方法论:</strong> 我认为工程上的解决方案，一定要有理论做基础。「跳出来，看全景」 和 「钻进去，看本质」，这两条方法论，我想是适合很多领域的学习的。</p><blockquote><p>Reference:　<a href="https://time.geekbang.org/column/intro/159" target="_blank" rel="noopener">极客时间-Java并发编程实战</a>　　</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　看薛兆丰的《经济学通识》，他总结到，人类面临着四大基本约束：东西不够，生命有限，互相依赖，需要协调。当我看到这句话的时候，我猛然间意识到：计算机也同样面临着这四大基本约束。&lt;br&gt;　　在计算中，CPU、内存、IO、硬盘、带宽等，这些资源也都有不够的时候，而每个线程的也有着自己的生命周期，并且它们之间又是相互依赖的，也同样需要协调。有了上面的这种想法，我觉得我学习计算机的知识有了章法可循。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="http://imbotao.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>最长公共前缀</title>
    <link href="http://imbotao.top/longest-common-prefix.html"/>
    <id>http://imbotao.top/longest-common-prefix.html</id>
    <published>2019-05-12T08:14:14.000Z</published>
    <updated>2019-05-12T08:24:42.016Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。<br><a id="more"></a></p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure></p><p><strong>思路</strong><br>先利用<code>Arrays.sort(strs)</code>为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可。 </p><p><strong>实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果检查值不合法及就返回空串</span></span><br><span class="line"><span class="keyword">if</span> (!checkStrs(strs)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组长度</span></span><br><span class="line"><span class="keyword">int</span> len = strs.length;</span><br><span class="line"><span class="comment">// 用于保存结果</span></span><br><span class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// 给字符串数组的元素按照升序排序(包含数字的话，数字会排在前面)</span></span><br><span class="line">Arrays.sort(strs);</span><br><span class="line"><span class="keyword">int</span> m = strs[<span class="number">0</span>].length();</span><br><span class="line"><span class="keyword">int</span> n = strs[len - <span class="number">1</span>].length();</span><br><span class="line"><span class="keyword">int</span> num = Math.min(m, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (strs[<span class="number">0</span>].charAt(i) == strs[len - <span class="number">1</span>].charAt(i)) &#123;</span><br><span class="line">res.append(strs[<span class="number">0</span>].charAt(i));</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkStrs</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (strs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历strs检查元素值</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (strs[i] == <span class="keyword">null</span> || strs[i].length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String[] strs = &#123; <span class="string">"customer"</span>, <span class="string">"car"</span>, <span class="string">"cat"</span> &#125;;</span><br><span class="line"><span class="comment">// String[] strs = &#123; "customer", "car", null &#125;;//空串</span></span><br><span class="line"><span class="comment">// String[] strs = &#123;&#125;;//空串</span></span><br><span class="line"><span class="comment">// String[] strs = null;//空串</span></span><br><span class="line">System.out.println(Main.replaceSpace(strs));<span class="comment">// c</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://imbotao.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>如何保证幂等机制</title>
    <link href="http://imbotao.top/how-to-guarantee-idempotent-mechanism.html"/>
    <id>http://imbotao.top/how-to-guarantee-idempotent-mechanism.html</id>
    <published>2019-05-12T06:39:49.000Z</published>
    <updated>2019-05-12T07:20:46.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>　　其实这是一个很常见的问题，做后端开发会经常遇到这个问题，如何保证消息消费不被重复消费，或者说如何保证一个接口多次调用只会产生一种结果，不管调多少次，资源都不会发生改变。如果重复消费了或者调用了，如何保证不造成系统异常。所以幂等机制的核心就是保证资源唯一性。<br><a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>　　需要保证幂等性的场景就是需要限定接口只能调用一次；消息重复消费之后，要保证资源不会发生改变。例如：</p><ul><li>支付接口</li><li>退款接口</li><li>新增数据的接口</li><li>…</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>利用数据库的唯一索引，针对我们需要约束的资源字段创建唯一索引，可以防止插入重复的数据。需要注意的是，如果是分库分表的情况，唯一索引的情况就不能限制资源数据的唯一性。</li><li>可以先根据数据库唯一索引查一下，如果存在，就做更新操作。 这块要注意的是如何避免并发场景（分布式锁）。</li><li>如果是直接写 redis，每次都是set，天然就幂等的。</li><li>利用 redis 做一层校验，每次调接口或这消费消息之前先查一下 redis 里有没有全局的ID，如果没有消费过，加redis，再处理消息或接口。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;　　其实这是一个很常见的问题，做后端开发会经常遇到这个问题，如何保证消息消费不被重复消费，或者说如何保证一个接口多次调用只会产生一种结果，不管调多少次，资源都不会发生改变。如果重复消费了或者调用了，如何保证不造成系统异常。所以幂等机制的核心就是保证资源唯一性。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://imbotao.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="沉淀" scheme="http://imbotao.top/tags/%E6%B2%89%E6%B7%80/"/>
    
  </entry>
  
  <entry>
    <title>All Or Nothing</title>
    <link href="http://imbotao.top/goodbye-2018.html"/>
    <id>http://imbotao.top/goodbye-2018.html</id>
    <published>2019-01-02T12:51:23.000Z</published>
    <updated>2019-05-10T03:32:28.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>关键字</strong>：<code>don&#39;t be nervous</code>, <code>业务or技术</code>, <code>人情味儿</code>, <code>慎独</code><br><a id="more"></a></p></blockquote><p>　　年前和学弟吃了个饭，听他讲了讲毕业这半年有什么变化，进步了多少，因为公司涉及的领域各有不同，所以技术领域或者说业务领域有很大的差别，没有什么反复探讨的东西，不过有一句话倒是令我影响深刻：<code>其他人或者公司不注重的细节，积累起来就是自身的核心价值。</code></p><p>　　<strong>don’t be nervous</strong>，这一年在亚信做了一些小事儿，佣金业务，智能调度，监控预警等，相应的也接触到了一些”新鲜”的技术, 微服务(SpringBoot), 微服务治理框架(SpringCloud, Dubbo), 分布式定时任务调度平台(elastic-job,xxl-job), 消息中间件(rabbitMQ, rocketMQ, kafka), 全文搜索引擎(Elasticsearch)等，能结合业务的发展方向对基础技术有一定的预判和快速上手，在面对方方面面的技术过程中，最重要的就是不要害怕，不要惊慌失措，不要逃避，这就是学习工程化，在技术宽度达到一定阶段后，就能根据不同的业务需求，进行技术选型，避免业务发展受到基础技术的拖累而不知所措。</p><p>　　<strong>业务or技术</strong>，纯粹的业务做的久了，难免心生倦怠，觉得技术得不到成长，工作内容除了<code>CRUD</code>就是<code>if...else</code>,就算接到有挑战的开发任务,有了上面<code>don&#39;t be nervous</code>的心态之后，也能心态平和的迎刃而解。我当然知道这是很多开发者面对的问题。其实这是一种相对割裂的眼光看问题，<code>实际上，所谓的业务代码和技术代码，它们的区别，仅仅是和业务的距离远近不同而已：业务代码离业务更近，技术代码离业务稍远。他们最终都是指向业务实现的</code>。2018年，我没有很好的去阅读他人的代码了解全局的业务形态，也没有在自己的技术栈上下功夫深钻底层实现，其实这两者只要有一个做的出色，就能有很大的成长。每当心生倦怠的时候，不妨多读读<a href="https://mp.weixin.qq.com/s/MiV-_xkWeT-mWMZbmJ8NBA" target="_blank" rel="noopener">《对开发来讲，业务重要还是技术重要？》</a>。</p><p>　　<strong>人情味儿</strong>，其实说到一个公司的人情味儿，当然离不开领导的关怀，组内和睦。我这里主要想说的是关于开发过程中，项目组或者说开发小组所给予的试错空间，容错性，很大程度上每个人写的代码都会被组长review一遍，或者就算是生产出了问题，自然有测试同事和负责发版的同事发现并修复，只要不导致重大生产后果，上线之后还存活的bug也不会被专门针对，逐渐的开发少了对自己代码负责的心态，没有对代码敬畏之心。我曾经问一个实习生毕业之后还来亚信的原因，答案是清闲，安稳。我不觉得清闲松散是一个项目组有人情味的表现，死海效应已经泛滥。其实团队有这么大的试错性，对于提升个人技术是特别好的一件事，任何可以实现业务需求的方式，就都可以去尝试，并且分享出来一起探讨利弊是一个很好的组内技术交流方式。</p><p>　　<strong>慎独</strong>, 马未都的脱口秀节目《观复嘟嘟》曾经有一期以江湖为主题，这其中就有一段关于慎独更加清晰明了的对话。一位女观众问：“像我们这种普通人如果要在江湖上混，应该注意些什么？” 他说：“<code>要很注意的一点，就是古人一再提醒的叫慎独。慎独就是你一个人独处的时候，你自己给自己一个交代，你给自己内心一个交代，我老说，你这事你对谁都不重要，对你自己最重要</code>。你当下所有对工作的敷衍，最后都成了人生对你的敷衍。希望2019以此为戒，对自己负责。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：&lt;code&gt;don&amp;#39;t be nervous&lt;/code&gt;, &lt;code&gt;业务or技术&lt;/code&gt;, &lt;code&gt;人情味儿&lt;/code&gt;, &lt;code&gt;慎独&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Life-Talk" scheme="http://imbotao.top/tags/Life-Talk/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Jest 实践</title>
    <link href="http://imbotao.top/es-jest-practice.html"/>
    <id>http://imbotao.top/es-jest-practice.html</id>
    <published>2018-12-24T12:30:11.000Z</published>
    <updated>2019-05-10T03:32:28.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h2><p><a href="https://github.com/searchbox-io/Jest/tree/master/jest" target="_blank" rel="noopener">GitHub</a><br>Jest是 <code>Elasticsearch</code> 的 Java Http Rest 客户端。ElasticSearch 已经具备应用于 Elasticsearch 内部的 Java API，但是 Jest 弥补了ES自有API缺少Elasticsearch Http Rest接口客户端的不足。<br><a id="more"></a></p><h2 id="springBoot-集成-Jest-依赖"><a href="#springBoot-集成-Jest-依赖" class="headerlink" title="springBoot 集成 Jest 依赖"></a>springBoot 集成 Jest 依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.searchbox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jest&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><p><img src="/img/20170813164101013.png" alt="jest 使用"></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建查询表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> criterias</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SearchSourceBuilder <span class="title">buildSearch</span><span class="params">(List&lt;Criteria&gt; criterias, EqlPage page)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定查询的库表</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分页</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(page)) &#123;</span><br><span class="line">        searchSourceBuilder.from((page.getCurrentPage() - <span class="number">1</span>) * page.getPageRows()).size(page.getPageRows());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(criterias)) &#123;</span><br><span class="line">        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line">        criterias.stream().forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (SHOULD.equals(t.getFieldType())) &#123;</span><br><span class="line">                <span class="comment">// 设置 should 匹配条件</span></span><br><span class="line">                boolQueryBuilder.should(QueryBuilders.termQuery(t.getFieldName(), t.getFieldValue()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (MUST.equals(t.getFieldType())) &#123;</span><br><span class="line">                <span class="comment">// 设置 must 匹配条件</span></span><br><span class="line">                boolQueryBuilder.must(QueryBuilders.termQuery(t.getFieldName(), t.getFieldValue()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (RANGE.equals(t.getFieldType())) &#123;</span><br><span class="line">                <span class="comment">// 设置 range 区间匹配条件</span></span><br><span class="line">                boolQueryBuilder.must(</span><br><span class="line">                        QueryBuilders.rangeQuery(t.getFieldName()).format(DATE_FORMAT).from(t.getFieldValue()).to(t.getFieldValue2()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> searchSourceBuilder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * es 执行查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> searchSourceBuilder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;OrderBean&gt; <span class="title">search</span><span class="params">(SearchSourceBuilder searchSourceBuilder,EqlPage page)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    List&lt;OrderBean&gt; list = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SearchResult result = client.execute(<span class="keyword">new</span> Search.Builder(searchSourceBuilder.toString())</span><br><span class="line">                <span class="comment">// multiple index or types can be added.</span></span><br><span class="line">                .addIndex(baseConfig.getEsIndex())</span><br><span class="line">                .addType(baseConfig.getEsType())</span><br><span class="line">                <span class="comment">// 设置排序字段与排序方式</span></span><br><span class="line">                .addSort(<span class="keyword">new</span> Sort(StringUtils.isBlank(page.getSortField()) ? <span class="string">"create_time"</span> : page.getSortField(),</span><br><span class="line">                        StringUtils.isEmpty(page.getSort())</span><br><span class="line">                                ? Sort.Sorting.DESC : Sort.Sorting.ASC))</span><br><span class="line">                .build());</span><br><span class="line"></span><br><span class="line">        result.getSourceAsObjectList(OrderBean.class, <span class="keyword">false</span>);</span><br><span class="line">        List&lt;SearchResult.Hit&lt;Object, Void&gt;&gt; hits = result.getHits(Object.class);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(hits)) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"es - list size :&#123;&#125;"</span>, hits.size());</span><br><span class="line">        <span class="comment">// 将查询结果映射到java实体里</span></span><br><span class="line">        hits.stream().forEach(t -&gt; &#123;</span><br><span class="line">            String news = JSON.toJSONString(t.source);</span><br><span class="line">            OrderBean order = JSON.parseObject(news, OrderBean.class);</span><br><span class="line">            list.add(order);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 获取查询总记录数</span></span><br><span class="line">        page.setTotalRows(result.getTotal().intValue());</span><br><span class="line">        <span class="comment">// 设置总页数</span></span><br><span class="line">        page.setPageNum((page.getTotalRows() - <span class="number">1</span>) / page.getPageRows() + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">"es - 查询失败：&#123;&#125;"</span>,JSON.toJSONString(e.getMessage()));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">"9999"</span>,<span class="string">"es 查询失败：&#123;&#125;"</span>,e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Jest&quot;&gt;&lt;a href=&quot;#Jest&quot; class=&quot;headerlink&quot; title=&quot;Jest&quot;&gt;&lt;/a&gt;Jest&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/searchbox-io/Jest/tree/master/jest&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;&lt;br&gt;Jest是 &lt;code&gt;Elasticsearch&lt;/code&gt; 的 Java Http Rest 客户端。ElasticSearch 已经具备应用于 Elasticsearch 内部的 Java API，但是 Jest 弥补了ES自有API缺少Elasticsearch Http Rest接口客户端的不足。&lt;br&gt;
    
    </summary>
    
    
      <category term="ES" scheme="http://imbotao.top/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="http://imbotao.top/achieve-queues-with-two-stack.html"/>
    <id>http://imbotao.top/achieve-queues-with-two-stack.html</id>
    <published>2018-11-15T06:46:34.000Z</published>
    <updated>2019-05-10T03:32:28.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>　　用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。<br><a id="more"></a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>　　首先清楚栈和队列的特点，栈的特点是先进后出，队列的特点是先进先出。也就是说，栈的删除操作在表尾进行，队列的删除操作在表头进行。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。<br><img src="/img/immmstack.png" alt="入栈出栈思路"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; in = new Stack&lt;Integer&gt;();</span><br><span class="line">Stack&lt;Integer&gt; out = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">// 入栈 (in 栈)</span><br><span class="line">public void push(int node) &#123;</span><br><span class="line">    in.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 出栈</span><br><span class="line">public int pop() throws Exception &#123;</span><br><span class="line">    if (out.isEmpty())  // 如果 out 栈为空，in 栈不为空，把元素从 in 栈顶出栈，放到 out 栈底</span><br><span class="line">        while (!in.isEmpty())</span><br><span class="line">            out.push(in.pop());</span><br><span class="line"></span><br><span class="line">    if (out.isEmpty())</span><br><span class="line">        throw new Exception(&quot;queue is empty&quot;);</span><br><span class="line"></span><br><span class="line">    return out.pop();   // 然后从 out 的栈的栈顶出栈，就是当时最先入栈的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目来源：<a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">nowcoder</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;　　用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。&lt;br&gt;
    
    </summary>
    
    
      <category term="nowcoder" scheme="http://imbotao.top/tags/nowcoder/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="http://imbotao.top/find-in-two-dimensional-array.html"/>
    <id>http://imbotao.top/find-in-two-dimensional-array.html</id>
    <published>2018-11-14T09:34:53.000Z</published>
    <updated>2019-05-10T03:32:28.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>　　在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><a id="more"></a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从右上角开始查找。矩阵中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间。</p><p>复杂度：O(M + N) + O(1)</p><p>当前元素的查找区间为左下角的所有元素，例如元素 12 的查找区间如下：<br><img src="/img/222array.png" alt="二维数组中的查找"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean Find(int target, int[][] matrix) &#123;</span><br><span class="line">    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)</span><br><span class="line">        return false;</span><br><span class="line">    int rows = matrix.length, cols = matrix[0].length;</span><br><span class="line">    int r = 0, c = cols - 1; // 从右上角开始</span><br><span class="line">    while (r &lt;= rows - 1 &amp;&amp; c &gt;= 0) &#123;</span><br><span class="line">        if (target == matrix[r][c]) </span><br><span class="line">            return true;</span><br><span class="line">        else if (target &gt; matrix[r][c]) // 如果比右上角的数大,就往下找；否则往左找</span><br><span class="line">            r++;</span><br><span class="line">        else </span><br><span class="line">            c--;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目来源：<a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">nowcoder</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;　　在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;br&gt;
    
    </summary>
    
    
      <category term="nowcoder" scheme="http://imbotao.top/tags/nowcoder/"/>
    
  </entry>
  
  <entry>
    <title>关于缓存</title>
    <link href="http://imbotao.top/about-cache.html"/>
    <id>http://imbotao.top/about-cache.html</id>
    <published>2018-11-12T07:37:54.000Z</published>
    <updated>2019-05-10T03:32:28.594Z</updated>
    
    <content type="html"><![CDATA[<p>对于热点数据，缓存的价值非常大，主要解决热点数据访问的性能问题。提供高性能的数据快速访问。<br><a id="more"></a></p><h2 id="缓存特征"><a href="#缓存特征" class="headerlink" title="缓存特征"></a>缓存特征</h2><h3 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h3><p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p><p>缓存命中率越高，缓存的利用率也就越高。</p><h3 id="最大空间"><a href="#最大空间" class="headerlink" title="最大空间"></a>最大空间</h3><p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p><p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p><h3 id="清空策略"><a href="#清空策略" class="headerlink" title="清空策略"></a>清空策略</h3><ul><li><p>FIFO (First In First Out)：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</p></li><li><p>LRU (Least Recently Used)：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</p></li><li><p>LFU (less frequently used)：最少使用策略，无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。策略算法主要比较元素的hitCount（命中次数）。在保证高频数据有效性场景下，可选择这类策略。</p></li></ul><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。</p><p>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p><h3 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h3><p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p><h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p><p><strong>解决方案：</strong></p><ul><li>对这些不存在的数据缓存一个空数据；</li><li>对这类请求进行过滤。</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p><p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p><p><strong>解决方案：</strong></p><ul><li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li><li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li><li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li></ul><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p><p><strong>解决方案：</strong></p><ul><li>在数据更新的同时立即去更新缓存；</li><li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li></ul><p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p><blockquote><p>Reference: </p><ul><li><a href="https://tech.meituan.com/cache_about.html" target="_blank" rel="noopener">缓存那些事</a></li><li><a href="https://www.aspirationhosting.com/aspiration-cdn/" target="_blank" rel="noopener">How Aspiration CDN helps to improve your website loading speed?</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于热点数据，缓存的价值非常大，主要解决热点数据访问的性能问题。提供高性能的数据快速访问。&lt;br&gt;
    
    </summary>
    
    
      <category term="缓存" scheme="http://imbotao.top/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>消息可靠性投递的技术方案</title>
    <link href="http://imbotao.top/message-reliability-delivery-suggestion.html"/>
    <id>http://imbotao.top/message-reliability-delivery-suggestion.html</id>
    <published>2018-11-06T02:26:26.000Z</published>
    <updated>2019-05-10T03:32:28.595Z</updated>
    
    <content type="html"><![CDATA[<p>　　使用 <code>MQ</code> 技术最常见的核心需求，需要保证消息不丢失，100%投递成功。以下是一个可靠性投递的流程图，以说明可靠性投递的概念。<br><a id="more"></a><br><img src="/img/MQkekao.jpg" alt="可靠性投递的流程图"></p><p><strong>step 1：</strong> 首先把消息信息(业务数据）存储到数据库中，紧接着，我们再把这个消息记录也存储到一张消息记录表里(者另外一个同源数据库的消息记录表)<br><strong>step 2：</strong> 发送消息到<code>MQ Broker</code>节点（采用 confirm 方式发送，会有异步的返回结果）<br><strong>step 3：</strong> 生产者端接受<code>MQ Broker</code>节点返回的 confirm 确认消息结果<br><strong>step 4：</strong> 进行更新消息记录表里的消息状态。比如默认 status = 0 当收到消息确认成功后，更新为1即可<br><strong>step 5：</strong> 但是在消息确认这个过程中可能由于网络闪断、MQ Broker端异常等原因导致 回送消息失败或者异常。这个时候就需要发送方（生产者）对消息进行可靠性投递了，保障消息不丢失，100%的投递成功！（有一种极限情况是闪断，Broker返回的成功确认消息，但是生产端由于网络闪断没收到，这个时候重新投递可能会造成消息重复，需要消费端去做幂等处理）所以我们需要有一个定时任务，（比如每5分钟拉取一下处于中间状态的消息，当然这个消息可以设置一个超时时间，比如超过1分钟 Status = 0 ，也就说明了1分钟这个时间窗口内，我们的消息没有被确认，那么会被定时任务拉取出来）<br><strong>step 6：</strong> 接下来我们把中间状态的消息进行重新投递 retry send，继续发送消息到MQ ，当然也可能有多种原因导致发送失败<br><strong>step 7：</strong> 我们可以采用设置最大努力尝试次数，比如投递了3次，还是失败，那么我们可以将最终状态设置为Status = 2 ，最后 交由人工解决处理此类问题（或者把消息转储到失败表中）。</p><p>具体的技术实现细节参考慕课视频《RabbitMQ消息中间件极速入门与实战》</p><blockquote><p>Reference:</p><ul><li><a href="https://www.imooc.com/learn/1042" target="_blank" rel="noopener">RabbitMQ消息中间件极速入门与实战</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　使用 &lt;code&gt;MQ&lt;/code&gt; 技术最常见的核心需求，需要保证消息不丢失，100%投递成功。以下是一个可靠性投递的流程图，以说明可靠性投递的概念。&lt;br&gt;
    
    </summary>
    
    
      <category term="MQ" scheme="http://imbotao.top/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>保证服务可用行性的核心思路</title>
    <link href="http://imbotao.top/improve-service-availability.html"/>
    <id>http://imbotao.top/improve-service-availability.html</id>
    <published>2018-09-09T13:28:04.000Z</published>
    <updated>2019-05-10T03:32:28.593Z</updated>
    
    <content type="html"><![CDATA[<p>　　如何保障稳定性，提高可用性呢？其实，可以分为几个方面：通过技术和流程防止故障产生、并且在发生故障时，减少故障的定位时间，以及提高故障恢复时间。<br><a id="more"></a><br><img src="/img/1532601081166-ca0c87c3-569c-4c68-8679-6d7aaf8972ce.jpeg" alt="保证服务可用行性的核心思路"></p><blockquote><p>Reference:</p><ul><li>梁桂钊的知识星球 –「服务端思维」</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　如何保障稳定性，提高可用性呢？其实，可以分为几个方面：通过技术和流程防止故障产生、并且在发生故障时，减少故障的定位时间，以及提高故障恢复时间。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://imbotao.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>百度地图API-判断坐标点在多边形区域内</title>
    <link href="http://imbotao.top/judge-point-isInPolygon.html"/>
    <id>http://imbotao.top/judge-point-isInPolygon.html</id>
    <published>2018-08-29T08:12:29.000Z</published>
    <updated>2019-05-10T03:32:28.596Z</updated>
    
    <content type="html"><![CDATA[<p>　　在智能派单的业务中,判断一个订单的收货地址在哪个配送员的配送范围之内,就显得极为关键。网上参考了一些解决思路和方法,做了一些实践和归纳。<br><a id="more"></a></p><h3 id="射线法思路"><a href="#射线法思路" class="headerlink" title="射线法思路"></a>射线法思路</h3><ul><li><a href="http://www.html-js.com/article/1517" target="_blank" rel="noopener">判断一个点是否在多边形内部 [1] 射线法思路</a></li><li><a href="http://www.html-js.com/article/1528" target="_blank" rel="noopener">判断一个点是否在多边形内部 [2] 射线法实现</a></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 判断点是否在多边形内，如果点位于多边形的顶点或边上，也算做点在多边形内，直接返回true</span><br><span class="line">     * @param point 检测点</span><br><span class="line">     * @param pts   多边形的顶点</span><br><span class="line">     * @return      点在多边形内返回true,否则返回false</span><br><span class="line">     */</span><br><span class="line">    public static boolean IsPtInPoly(Point2D.Double point, List&lt;Point2D.Double&gt; pts)&#123;</span><br><span class="line"></span><br><span class="line">        int N = pts.size();</span><br><span class="line">        boolean boundOrVertex = true; //如果点位于多边形的顶点或边上，也算做点在多边形内，直接返回true</span><br><span class="line">        int intersectCount = 0;//cross points count of x</span><br><span class="line">        double precision = 2e-10; //浮点类型计算时候与0比较时候的容差</span><br><span class="line">        Point2D.Double p1, p2;//neighbour bound vertices</span><br><span class="line">        Point2D.Double p = point; //当前点</span><br><span class="line"></span><br><span class="line">        p1 = pts.get(0);//left vertex</span><br><span class="line">        for(int i = 1; i &lt;= N; ++i)&#123;//check all rays</span><br><span class="line">            if(p.equals(p1))&#123;</span><br><span class="line">                return boundOrVertex;//p is an vertex</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p2 = pts.get(i % N);//right vertex</span><br><span class="line">            if(p.x &lt; Math.min(p1.x, p2.x) || p.x &gt; Math.max(p1.x, p2.x))&#123;//ray is outside of our interests</span><br><span class="line">                p1 = p2;</span><br><span class="line">                continue;//next ray left point</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(p.x &gt; Math.min(p1.x, p2.x) &amp;&amp; p.x &lt; Math.max(p1.x, p2.x))&#123;//ray is crossing over by the algorithm (common part of)</span><br><span class="line">                if(p.y &lt;= Math.max(p1.y, p2.y))&#123;//x is before of ray</span><br><span class="line">                    if(p1.x == p2.x &amp;&amp; p.y &gt;= Math.min(p1.y, p2.y))&#123;//overlies on a horizontal ray</span><br><span class="line">                        return boundOrVertex;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if(p1.y == p2.y)&#123;//ray is vertical</span><br><span class="line">                        if(p1.y == p.y)&#123;//overlies on a vertical ray</span><br><span class="line">                            return boundOrVertex;</span><br><span class="line">                        &#125;else&#123;//before ray</span><br><span class="line">                            ++intersectCount;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;else&#123;//cross point on the left side</span><br><span class="line">                        double xinters = (p.x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y;//cross point of y</span><br><span class="line">                        if(Math.abs(p.y - xinters) &lt; precision)&#123;//overlies on a ray</span><br><span class="line">                            return boundOrVertex;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if(p.y &lt; xinters)&#123;//before ray</span><br><span class="line">                            ++intersectCount;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;//special case when ray is crossing through the vertex</span><br><span class="line">                if(p.x == p2.x &amp;&amp; p.y &lt;= p2.y)&#123;//p crossing over p2</span><br><span class="line">                    Point2D.Double p3 = pts.get((i+1) % N); //next vertex</span><br><span class="line">                    if(p.x &gt;= Math.min(p1.x, p3.x) &amp;&amp; p.x &lt;= Math.max(p1.x, p3.x))&#123;//p.x lies between p1.x &amp; p3.x</span><br><span class="line">                        ++intersectCount;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        intersectCount += 2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p2;//next ray left point</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(intersectCount % 2 == 0)&#123;//偶数在多边形外</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123; //奇数在多边形内</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="百度地图-API-的使用"><a href="#百度地图-API-的使用" class="headerlink" title="百度地图 API 的使用"></a>百度地图 API 的使用</h3><ul><li>需要申请且认证为开发者。</li><li>需要在<a href="http://lbsyun.baidu.com/apiconsole/key" target="_blank" rel="noopener">控制台</a>创建应用,获取相应的服务密钥(<code>AK</code>)</li><li>在开发文档中选择自己需要的api,根据具体api的服务文档和使用指南发送请求,使用服务即可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　在智能派单的业务中,判断一个订单的收货地址在哪个配送员的配送范围之内,就显得极为关键。网上参考了一些解决思路和方法,做了一些实践和归纳。&lt;br&gt;
    
    </summary>
    
    
      <category term="沉淀" scheme="http://imbotao.top/tags/%E6%B2%89%E6%B7%80/"/>
    
  </entry>
  
  <entry>
    <title>关于开发中单表查和连表查的取舍</title>
    <link href="http://imbotao.top/single-or-join-query.html"/>
    <id>http://imbotao.top/single-or-join-query.html</id>
    <published>2018-06-22T02:09:29.000Z</published>
    <updated>2019-05-10T03:32:28.593Z</updated>
    
    <content type="html"><![CDATA[<p>　　关于开发中单表查询和连接查询怎么取舍？连表配合索引一次查询就可以出来，单表的话可能需要 n 次读取数据库。<br><a id="more"></a> </p><h3 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h3><p>　　能单表就单表，尽量不要连表，不光有开销，连表后复用性降低，系统复杂性会增加。而且数据库做关联是很耗性能的。把连表查拆分成两次查询也是基于查出结果的 idList 去查另一张表，开销很小，查询出的结果可以做一次merge组合。</p><h3 id="通用的-merge-方法"><a href="#通用的-merge-方法" class="headerlink" title="通用的 merge 方法"></a>通用的 merge 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wave</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2018-06-20 11:24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把 sourceList 的一些属性合并到 targetList 中</span></span><br><span class="line"><span class="comment">     * 基于 testFunction 的条件,合入逻辑实现为 biConsumer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> testFunction</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> biConsumer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;S&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, S&gt; <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(List&lt;T&gt; targetList, List&lt;S&gt; sourceList,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    BiFunction&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> S,Boolean&gt; testFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> S&gt; biConsumer)</span> </span>&#123;</span><br><span class="line">        targetList.forEach((t)-&gt;&#123;</span><br><span class="line">            Optional&lt;S&gt; optional = sourceList.stream().filter(s -&gt; testFunction.apply(t,s)).findFirst();</span><br><span class="line">            <span class="keyword">if</span> (optional.isPresent()) &#123;</span><br><span class="line">                biConsumer.accept(t,optional.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基于两个 list 的 id 做关联, 将 name 属性 merge 到目标 list </span><br><span class="line"> *</span><br><span class="line">**/</span><br><span class="line">MergeUtil.merge(targetList,sourceList,</span><br><span class="line">                (target,source)-&gt;target.id().equals(source.id()),</span><br><span class="line">                (target,source)-&gt;target.setName(source.getName));</span><br></pre></td></tr></table></figure><blockquote><p>Reference:</p><ul><li>梁桂钊的知识星球 –「服务端思维」</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　关于开发中单表查询和连接查询怎么取舍？连表配合索引一次查询就可以出来，单表的话可能需要 n 次读取数据库。&lt;br&gt;
    
    </summary>
    
    
      <category term="沉淀" scheme="http://imbotao.top/tags/%E6%B2%89%E6%B7%80/"/>
    
  </entry>
  
  <entry>
    <title>Lambda 表达式</title>
    <link href="http://imbotao.top/lambda-expressions.html"/>
    <id>http://imbotao.top/lambda-expressions.html</id>
    <published>2018-04-19T06:58:54.000Z</published>
    <updated>2019-05-10T03:32:28.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Lambda"><a href="#什么是-Lambda" class="headerlink" title="什么是 Lambda?"></a>什么是 Lambda?</h2><p>我们知道，对于一个Java变量，我们可以赋给其一个“<strong>值</strong>”。<br><img src="/img/lambda/p1.jpg" alt="normal"></p><p>如果你想把“<strong>一块代码</strong>”赋给一个Java变量，应该怎么做呢？<br><a id="more"></a></p><p>比如，我想把右边那块代码，赋给一个叫做<code>aBlockOfCode</code>的Java变量：<br><img src="/img/lambda/p2.jpg" alt="p2"></p><p>在Java 8之前，这个是做不到的。但是Java 8问世之后，利用Lambda特性，就可以做到了。<br><img src="/img/lambda/p3.jpg" alt="p3"></p><p>当然，这个并不是一个很简洁的写法。所以，为了使这个赋值操作更加<strong>elegant</strong>, 我们可以移除一些没用的声明。<br><img src="/img/lambda/p4.jpg" alt="p4"></p><p>这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。<strong>而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式</strong>。<br>但是这里仍然有一个问题，就是变量<code>aBlockOfCode</code>的类型应该是什么？在Java 8里面，<strong>所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现</strong>。这是我认为理解Lambda的一个关键所在，简而言之就是，<strong>Lambda表达式本身就是一个接口的实现</strong>。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型：</p><p><img src="/img/lambda/p5.jpg" alt="p5"><br>这种只有<strong>一个接口函数需要被实现的接口类型，我们叫它”函数式接口“</strong>。为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了：<br><img src="/img/lambda/p6.jpg" alt="p6"></p><p>这样，我们就得到了一个完整的Lambda表达式声明：<br><img src="/img/lambda/p7.jpg" alt="p7"></p><h2 id="Lambda表达式有什么作用"><a href="#Lambda表达式有什么作用" class="headerlink" title="Lambda表达式有什么作用?"></a>Lambda表达式有什么作用?</h2><p><strong>最直观的作用就是使得代码变得异常简洁。</strong><br>我们可以对比一下Lambda表达式和传统的Java对同一个接口的实现：<br><img src="/img/lambda/p8.jpg" alt="p8"></p><p>这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于Lambda可以直接赋值给一个变量，<strong>我们就可以直接把Lambda作为参数传给函数, 而传统的Java必须有明确的接口实现的定义，初始化才行：</strong><br><img src="/img/lambda/p9.jpg" alt="p9"><br>有些情况下，这个接口实现只需要用到一次。传统的Java 7必须要求你定义一个“污染环境”的接口实现MyInterfaceImpl，而相较之下Java 8的Lambda, 就显得干净很多。</p><h2 id="Lambda结合FunctionalInterface-Lib-forEach-stream-，method-reference等新特性可以使代码变的更加简洁！"><a href="#Lambda结合FunctionalInterface-Lib-forEach-stream-，method-reference等新特性可以使代码变的更加简洁！" class="headerlink" title="Lambda结合FunctionalInterface Lib, forEach, stream()，method reference等新特性可以使代码变的更加简洁！"></a>Lambda结合FunctionalInterface Lib, forEach, stream()，method reference等新特性可以使代码变的更加简洁！</h2><p>直接上例子。</p><p>假设Person的定义和List<person>的值都给定。<br><img src="/img/lambda/p10.jpg" alt="p10"><br>现在需要你打印出guiltyPersons List里面所有LastName以”Z”开头的人的FirstName。</person></p><p><strong>原生态Lambda写法</strong>：定义两个函数式接口，定义一个静态函数，调用静态函数并给参数赋值Lambda表达式。<br><img src="/img/lambda/p12.jpg" alt="p12"><br>这个代码实际上已经比较简洁了，但是我们还可以更简洁么？当然可以。在Java 8中有一个函数式接口的包，里面定义了大量可能用到的函数式接口（<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">java.util.function (Java Platform SE 8 )</a>）。所以，我们在这里压根都不需要定义NameChecker和Executor这两个函数式接口，直接用Java 8函数式接口包里的Predicate<t>和Consumer<t>就可以了——因为他们这一对的接口定义和NameChecker/Executor其实是一样的。<br><img src="/img/lambda/pp.jpg" alt="pp"><br><strong>第一步简化 - 利用函数式接口包：</strong><br><img src="/img/lambda/p13.jpg" alt="p13"><br>静态函数里面的for each循环其实是非常碍眼的。这里可以利用Iterable自带的forEach()来替代。forEach()本身可以接受一个Consumer<t> 参数。<br><strong>第二步简化 - 用Iterable.forEach()取代foreach loop：</strong><br><img src="/img/lambda/p14.jpg" alt="p14"><br>由于静态函数其实只是对List进行了一通操作，这里我们可以甩掉静态函数，直接使用stream()特性来完成。stream()的几个方法都是接受Predicate<t>，Consumer<t>等参数的（<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">java.util.stream (Java Platform SE 8 )</a>）。你理解了上面的内容，stream()这里就非常好理解了，并不需要多做解释。<br><strong>第三步简化 - 利用stream()替代静态函数：</strong><br><img src="/img/lambda/p15.jpg" alt="p15"><br>对比最开始的Lambda写法，这里已经非常非常简洁了。但是如果，我们的要求变一下，变成print这个人的全部信息，及p -&gt; System.out.println(p); 那么还可以利用Method reference来继续简化。所谓Method reference, 就是用已经写好的别的Object/Class的method来代替Lambda expression。格式如下：<br><img src="/img/lambda/p16.jpg" alt="p16"><br><strong>第四步简化 - 如果是println(p)，则可以利用Method reference代替forEach中的Lambda表达式：</strong><br><img src="/img/lambda/p17.jpg" alt="p17"><br>这基本上就是能写的最简洁的版本了。</t></t></t></t></t></p><h2 id="Lambda配合Optional可以使Java对于null的处理变的异常优雅"><a href="#Lambda配合Optional可以使Java对于null的处理变的异常优雅" class="headerlink" title="Lambda配合Optional可以使Java对于null的处理变的异常优雅"></a>Lambda配合Optional<t>可以使Java对于null的处理变的异常优雅</t></h2><p>这里假设我们有一个person object，以及一个person object的Optional wrapper:<br><img src="/img/lambda/p18.jpg" alt="p18"><br>Optional<t>如果不结合Lambda使用的话，并不能使原来繁琐的null check变的简单。<br><img src="/img/lambda/p20.jpg" alt="p20"><br><strong>只有当Optional<t>结合Lambda一起使用的时候，才能发挥出其真正的威力！</t></strong></t></p><p>我们现在就来对比一下下面四种常见的null处理中，Java 8的Lambda+Optional<t>和传统Java两者之间对于null的处理差异。<br><strong>情况一 - 存在则开干</strong><br><img src="/img/lambda/p21.jpg" alt="p21"><br><strong>情况二 - 存在则返回，无则返回屁</strong><br><img src="/img/lambda/p22.jpg" alt="p22"><br><strong>情况三 - 存在则返回，无则由函数产生</strong><br><img src="/img/lambda/p23.jpg" alt="p23"><br><strong>情况四 - 夺命连环null检查</strong><br><img src="/img/lambda/p24.jpg" alt="p24"><br>由上述四种情况可以清楚地看到，Optional<t>+Lambda可以让我们少写很多ifElse块。尤其是对于情况四那种夺命连环null检查，传统java的写法显得冗长难懂，而新的Optional<t>+Lambda则清新脱俗，清楚简洁。</t></t></t></p><p>关于Java的Lambda, 还有东西需要讨论和学习。比如如何handle lambda exception，如何利用Lambda的特性来进行parallel processing等。总之，我只是一如既往地介绍个大概，让你大概知道，哦！原来是这样子就OK了。网上关于Lambda有很多相关的教程，多看多练。假以时日，必定有所精益。</p><blockquote><p>Reference:　<a href="https://www.zhihu.com/question/20125256/answer/324121308" target="_blank" rel="noopener">Sevenvidia-知乎</a>　　</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Lambda&quot;&gt;&lt;a href=&quot;#什么是-Lambda&quot; class=&quot;headerlink&quot; title=&quot;什么是 Lambda?&quot;&gt;&lt;/a&gt;什么是 Lambda?&lt;/h2&gt;&lt;p&gt;我们知道，对于一个Java变量，我们可以赋给其一个“&lt;strong&gt;值&lt;/strong&gt;”。&lt;br&gt;&lt;img src=&quot;/img/lambda/p1.jpg&quot; alt=&quot;normal&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你想把“&lt;strong&gt;一块代码&lt;/strong&gt;”赋给一个Java变量，应该怎么做呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://imbotao.top/tags/Java/"/>
    
      <category term="Lambda" scheme="http://imbotao.top/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ 初试</title>
    <link href="http://imbotao.top/rocketmq-start-learn.html"/>
    <id>http://imbotao.top/rocketmq-start-learn.html</id>
    <published>2018-04-17T02:19:18.000Z</published>
    <updated>2019-05-10T03:32:28.590Z</updated>
    
    <content type="html"><![CDATA[<p>　　近期的项目需求需要用到消息队列, 结合实际的业务需求(佣金结算), 需要对市面上的几种消息中间件进行选型分析, 从功能维度(优先级队列、延迟队列、死信队列、重试队列、消费模式、消息过滤、消息顺序性、事务性消息等), 性能,可靠性 + 可用性, 运维管理, 日志追踪, 社区力度及生态发展等层面进行考虑, 根据各自的侧重点, 选择合适自己的消息中间件尤为重要。<br><a id="more"></a>　　<br>　　我这次选择了阿里开源的<code>RocketMQ</code>,下面主要记录下我的首次使用,与<code>Spring</code>集成,采用<code>push</code>方式接收消息。</p><h2 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apache.rocketmq.consumer.PushConsumer=WeChatConsumer</span><br><span class="line">apache.rocketmq.producer.producerGroup=WeChatProducer</span><br><span class="line">apache.rocketmq.namesrvAddr=XX.XX.XX.XX:9876</span><br></pre></td></tr></table></figure><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Producer.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者的组名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.producer.producerGroup&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String producerGroup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NameServer 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.namesrvAddr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultMQProducer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//生产者的组名</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(producerGroup);</span><br><span class="line">        <span class="comment">//指定NameServer地址，多个地址以 ; 隔开</span></span><br><span class="line">        producer.setNamesrvAddr(namesrvAddr);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  从文件中获取待消费消息数据：</span></span><br><span class="line"><span class="comment">        *  4418040302625808|2018-04-03 10:35:52|81|820|16608187978|2018-04-03 14:22:56|9095180232</span></span><br><span class="line"><span class="comment">           6518040101499088|2018-04-01 10:50:20|75|750|13037219257|2018-04-03 14:22:55|3579901463</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        File fin = <span class="keyword">new</span> File(<span class="string">"E:\\work\\20180403_1432_002.REQ"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Producer对象在使用之前必须要调用start初始化，初始化一次即可</span></span><br><span class="line"><span class="comment">             * 注意：切记不可以在每次发送消息时，都调用start方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            producer.start();</span><br><span class="line">            List&lt;String&gt; msgList = ReadFile.readFile(fin);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(msgList)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            StopWatch stop = <span class="keyword">new</span> StopWatch();</span><br><span class="line">            stop.start();</span><br><span class="line">            <span class="keyword">for</span> (String str : msgList) &#123;</span><br><span class="line">                <span class="comment">// 拆分字符串, id 记录流水号</span></span><br><span class="line">                String[] msgArr = str.split(<span class="string">"\\|"</span>);</span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"WXData"</span>,<span class="string">"push"</span>,msgArr[<span class="number">0</span>],str.getBytes());</span><br><span class="line">                <span class="comment">// 发送消息</span></span><br><span class="line">                SendResult result = producer.send(msg);</span><br><span class="line">                logger.info(<span class="string">"id:&#123;&#125;,result:&#123;&#125;"</span>, result.getMsgId(), result.getSendStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            stop.stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            producer.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者的组名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.consumer.PushConsumer&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NameServer 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.namesrvAddr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Consumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CalcCommissionService calcService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spring框架的注解，在方法上加该注解会在项目启动的时候执行该方法，也可以理解为在spring容器初始化的时候执行该方法</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultMQPushConsumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//消费者的组名</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(consumerGroup);</span><br><span class="line">        <span class="comment">//指定NameServer地址，多个地址以 ; 隔开</span></span><br><span class="line">        consumer.setNamesrvAddr(namesrvAddr);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//订阅WXData下的push消息</span></span><br><span class="line">            consumer.subscribe(<span class="string">"WXData"</span>, <span class="string">"push"</span>);</span><br><span class="line">            <span class="comment">//设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费</span></span><br><span class="line">            <span class="comment">//如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line">            consumer.setConsumeFromWhere(</span><br><span class="line">                    ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">            consumer.registerMessageListener(</span><br><span class="line">                    (List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext Context) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Message msg = list.get(<span class="number">0</span>);</span><br><span class="line">                            String msgBody = <span class="keyword">new</span> String (msg.getBody());</span><br><span class="line">                            <span class="comment">// TODO　coding...</span></span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER; <span class="comment">// 稍后重试</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;   <span class="comment">// 消费成功</span></span><br><span class="line">                    &#125;);</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * test rocketMQ</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Producer rocketMQProvider;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testMQ"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rocketMQProvider.defaultMQProducer();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　近期的项目需求需要用到消息队列, 结合实际的业务需求(佣金结算), 需要对市面上的几种消息中间件进行选型分析, 从功能维度(优先级队列、延迟队列、死信队列、重试队列、消费模式、消息过滤、消息顺序性、事务性消息等), 性能,可靠性 + 可用性, 运维管理, 日志追踪, 社区力度及生态发展等层面进行考虑, 根据各自的侧重点, 选择合适自己的消息中间件尤为重要。&lt;br&gt;
    
    </summary>
    
    
      <category term="MQ" scheme="http://imbotao.top/tags/MQ/"/>
    
      <category term="RocketMQ" scheme="http://imbotao.top/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>Java 高并发编程「三」</title>
    <link href="http://imbotao.top/java-concurrent-programming-3.html"/>
    <id>http://imbotao.top/java-concurrent-programming-3.html</id>
    <published>2018-04-07T08:38:58.000Z</published>
    <updated>2019-05-10T03:32:28.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ConcurrentMap"><a href="#ConcurrentMap" class="headerlink" title="ConcurrentMap"></a>ConcurrentMap</h2><p>　　Map(Set)如果在不加锁的情况下, 可以使用 <code>HashMap</code>,<code>treeMap</code>,<code>LinkedHashMap</code>等。如果想加锁,可以使用 <code>HashTable</code>(用的比较少),如果并发不高的情况下，可以使用 <code>Collections.synchronizedXXX</code>,如果并发性比较高的情况, 建议使用 <code>ConcurrentHashMap</code>,如果并发性比较高，并且要求排序的情况下，建议使用 <code>ConcurrentSkipListMap</code>。<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_ConcurrentMap</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 16 段, 分段锁,高并发的时候效率比较高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;(); <span class="comment">//高并发并且排序</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hashtable 本身就带锁,效率比较低</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Map&lt;String, String&gt; map = new Hashtable&lt;&gt;();</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以对 HashMap 加锁：Collections.synchronizedXXX</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Map&lt;String, String&gt; map =  new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">//TreeMap</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line">CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(ths.length);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ths.length; i++) &#123;</span><br><span class="line">ths[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++) map.put(<span class="string">"a"</span> + r.nextInt(<span class="number">100000</span>), <span class="string">"a"</span> + r.nextInt(<span class="number">100000</span>));</span><br><span class="line">latch.countDown();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Arrays.asList(ths).forEach(t-&gt;t.start());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">latch.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(end - start);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CopyOnWriteList"><a href="#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h2><p>写时复制容器 <code>copy on write</code>,多线程环境下,写时效率低,读时效率高,适合写少读多的环境。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CopyOnWriteList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; lists = </span><br><span class="line"><span class="comment">//new ArrayList&lt;&gt;(); //这个会出并发问题！</span></span><br><span class="line"><span class="comment">//new Vector();</span></span><br><span class="line"><span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">Thread[] ths = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ths.length; i++) &#123;</span><br><span class="line">Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) lists.add(<span class="string">"a"</span> + r.nextInt(<span class="number">10000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">ths[i] = <span class="keyword">new</span> Thread(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">runAndComputeTime(ths);</span><br><span class="line"></span><br><span class="line">System.out.println(lists.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAndComputeTime</span><span class="params">(Thread[] ths)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> s1 = System.currentTimeMillis();</span><br><span class="line">Arrays.asList(ths).forEach(t-&gt;t.start());</span><br><span class="line">Arrays.asList(ths).forEach(t-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">long</span> s2 = System.currentTimeMillis();</span><br><span class="line">System.out.println(s2 - s1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="SynchronizedList"><a href="#SynchronizedList" class="headerlink" title="SynchronizedList"></a>SynchronizedList</h2><p>　　<code>new ArrayList()</code> 是没有锁的，如果想给这个list上锁，可以通过调用<code>Collections</code> 的静态方法 <code>synchronizedList()</code>,将不加锁的容器返回成一个加了锁的容器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_SynchronizedList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; strs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; strsSync = Collections.synchronizedList(strs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ConcurrentQueue"><a href="#ConcurrentQueue" class="headerlink" title="ConcurrentQueue"></a>ConcurrentQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_ConcurrentQueue</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Queue&lt;String&gt; strs = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="comment">// offer 类似于 add,有一个boolean类型的返回值,表示是否添加成功</span></span><br><span class="line">strs.offer(<span class="string">"a"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(strs);</span><br><span class="line"></span><br><span class="line">System.out.println(strs.size());</span><br><span class="line"><span class="comment">// 表示从队列头部拿出一个,队列数量减少一个</span></span><br><span class="line">System.out.println(strs.poll());</span><br><span class="line">System.out.println(strs.size());</span><br><span class="line"><span class="comment">// 表示从队列中拿出来，但是不删除，队列数量不会变</span></span><br><span class="line">System.out.println(strs.peek());</span><br><span class="line">System.out.println(strs.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//双端队列Deque, 可以从两端取，也可以往两端添加</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>　　无界队列，使用链表实现的阻塞式容器,添加了两个方法，<code>put</code>,<code>take</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_LinkedBlockingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">strs.put(<span class="string">"a"</span> + i); <span class="comment">//如果满了，就会等待</span></span><br><span class="line">TimeUnit.MILLISECONDS.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">"p1"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" take -"</span> + strs.take()); <span class="comment">//如果空了，就会等待</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">"c"</span> + i).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>　　<code>ArrayBlockingQueue</code>,是有界队列，能装的元素的个数是固定的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T06_ArrayBlockingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">strs.put(<span class="string">"a"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strs.put(<span class="string">"aaa"</span>); <span class="comment">//满了就会等待，程序阻塞</span></span><br><span class="line"><span class="comment">//strs.add("aaa"); // 会报异常</span></span><br><span class="line"><span class="comment">//strs.offer("aaa"); // 会通过返回值通知是否添加成功</span></span><br><span class="line"><span class="comment">//strs.offer("aaa", 1, TimeUnit.SECONDS); // 一秒钟之后加不进去，就不加了</span></span><br><span class="line"></span><br><span class="line">System.out.println(strs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>　　  无界队列，队列里的每一个元素都有一个时间表示自己还有多久时间可以被消费,可以用来做执行定时任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_DelayQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> BlockingQueue&lt;MyTask&gt; tasks = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> runningTime;</span><br><span class="line"></span><br><span class="line">MyTask(<span class="keyword">long</span> rt) &#123;</span><br><span class="line"><span class="keyword">this</span>.runningTime = rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span> + runningTime;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">MyTask t1 = <span class="keyword">new</span> MyTask(now + <span class="number">1000</span>);</span><br><span class="line">MyTask t2 = <span class="keyword">new</span> MyTask(now + <span class="number">2000</span>);</span><br><span class="line">MyTask t3 = <span class="keyword">new</span> MyTask(now + <span class="number">1500</span>);</span><br><span class="line">MyTask t4 = <span class="keyword">new</span> MyTask(now + <span class="number">2500</span>);</span><br><span class="line">MyTask t5 = <span class="keyword">new</span> MyTask(now + <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">tasks.put(t1);</span><br><span class="line">tasks.put(t2);</span><br><span class="line">tasks.put(t3);</span><br><span class="line">tasks.put(t4);</span><br><span class="line">tasks.put(t5);</span><br><span class="line"></span><br><span class="line">System.out.println(tasks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(tasks.take());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h2><p>　　提供一个<code>transfer</code>方法。 消费者先启动，当生产者生产的时候，先找消费者，有消费者直接给消费者，而不是放入队列,效率更高， 用在更高的并发场景下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T08_TransferQueue</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">LinkedTransferQueue&lt;String&gt; strs = <span class="keyword">new</span> LinkedTransferQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">try &#123;</span></span><br><span class="line"><span class="comment">System.out.println(strs.take());</span></span><br><span class="line"><span class="comment">&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">e.printStackTrace();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;).start();*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//strs.transfer("aaa");</span></span><br><span class="line"></span><br><span class="line">strs.put(<span class="string">"aaa"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(strs.take());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="SynchronusQueue"><a href="#SynchronusQueue" class="headerlink" title="SynchronusQueue"></a>SynchronusQueue</h2><p>　　没有容量的队列，有消息直接被消费，而不能放入队列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_SynchronusQueue</span> </span>&#123; <span class="comment">//容量为0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(strs.take());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">strs.put(<span class="string">"aaa"</span>); <span class="comment">//阻塞等待消费者消费</span></span><br><span class="line"><span class="comment">//strs.add("aaa");</span></span><br><span class="line">System.out.println(strs.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ConcurrentMap&quot;&gt;&lt;a href=&quot;#ConcurrentMap&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentMap&quot;&gt;&lt;/a&gt;ConcurrentMap&lt;/h2&gt;&lt;p&gt;　　Map(Set)如果在不加锁的情况下, 可以使用 &lt;code&gt;HashMap&lt;/code&gt;,&lt;code&gt;treeMap&lt;/code&gt;,&lt;code&gt;LinkedHashMap&lt;/code&gt;等。如果想加锁,可以使用 &lt;code&gt;HashTable&lt;/code&gt;(用的比较少),如果并发不高的情况下，可以使用 &lt;code&gt;Collections.synchronizedXXX&lt;/code&gt;,如果并发性比较高的情况, 建议使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;,如果并发性比较高，并且要求排序的情况下，建议使用 &lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="http://imbotao.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>问题沉淀「二」</title>
    <link href="http://imbotao.top/questions-share-2.html"/>
    <id>http://imbotao.top/questions-share-2.html</id>
    <published>2018-03-30T11:18:06.000Z</published>
    <updated>2019-05-10T03:32:28.598Z</updated>
    
    <content type="html"><![CDATA[<p>关键字: <code>幂等</code>、<code>CountDownLatch</code>、<code>异常处理</code>、<code>B+ 树</code><br><a id="more"></a></p><p><strong>问题：</strong> 如何保证幂等机制<br><strong>解决方案：</strong><br>　　幂等机制的核心是保证资源唯一性，例如客户端重复提交或服务端的多次重试只会产生一份结果。支付场景、退款场景，涉及金钱的交易不能出现多次扣款等问题。事实上，查询接口用于获取资源，因为它只是查询数据而不会影响到资源的变化，因此不管调用多少次接口，资源都不会改变，所以是它是幂等的。而新增接口是非幂等的，因为调用接口多次，它都将会产生资源的变化。因此，我们需要在出现重复提交时进行幂等处理。</p><p>那么，如何保证幂等机制呢？事实上，我们有很多实现方案。其中，一种方案就是常见的创建唯一索引。在数据库中针对我们需要约束的资源字段创建唯一索引，可以防止插入重复的数据。但是，遇到分库分表的情况是，唯一索引也就不那么好使了，此时，我们可以先查询一次数据库，然后判断是否约束的资源字段存在重复，没有的重复时再进行插入操作。注意的是，为了避免并发场景，我们可以通过锁机制，例如悲观锁与乐观锁保证数据的唯一性。这里，分布式锁是一种经常使用的方案，它通常情况下是一种悲观锁的实现。但是，很多人经常把悲观锁、乐观锁、分布式锁当作幂等机制的解决方案，这个是不正确的。除此之外，我们还可以引入状态机，通过状态机进行状态的约束以及状态跳转，确保同一个业务的流程化执行，从而实现数据幂等。</p><p>事实上，并不是所有的接口都要保证幂等，换句话说，是否需要幂等机制可以通过考量需不需要确保资源唯一性，例如行为日志可以不考虑幂等性。当然，还有一种设计方案是接口不考虑幂等机制，而是在业务实现的时候通过业务层面来保证，例如允许存在多份数据，但是在业务处理的时候获取最新的版本进行处理。</p><hr><p><strong>问题：</strong> <code>redis key</code> 过期后如何防止流量瞬间打在DB上?<br><strong>探讨：</strong><br>因为key过期后，不确定有多大的流量打在db上，所以，要提前reload<br>这种情况，没有特别好的方式。有文章说用分布式锁。其实是错误的，这样所有流量压力也会打到锁上，这种只是把压力转换了。<br>最好的方式只能对DB做限流，热点数据做本地缓存，这样能防止一个特别热的key，很大的流量都到DB。<br>什么是热点数据？而且基本上所有item都是长尾效应，用户能接触的只有10%的商品；剩下的90%商品都用不到缓存，<br>热与否，是会随时间的变化而变化的~，当然99%的公司，不需要考虑这个问题，所以很多时候在大流量面前<br>很多方案变的那么无力！！！</p><hr><p><strong>问题：</strong> <code>CountDownLatch</code> 实际运用在项目中什么样的场景？<br><strong>解答：</strong></p><ol><li>做某个事情可能会有前置条件，比如 A depends on B，C，那 A 要等到 B,C 任务完成了才能开始。比如聚餐，可能需要等所有人到齐才能开始，比赛颁奖需要等所有运动员赛完了，才能开始颁奖。等等…</li><li>futureTask 只是等待线程池里的线程执行完毕，但是线程间没有依赖关系，完全互相独立的。所以 fututreTask 和 countDownLatch 适用的场景不一样。</li></ol><hr><p><strong>问题：</strong> 项目中的异常一般是不是不在 controller 层 catch 处理，而是丢给专门的 ControllerAdvice 处理？<br><strong>解答：</strong><br>ControllerAdvice 处理确实是一种好方案。我们自定义一个运行时异常，然后统一处理，并且封装给一个统一格式的异常 JSON 格式。</p><hr><p><strong>问题：</strong> 为什么 B+ 树适合做索引？<br><strong>解答：</strong><br>索引本身很大，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。而 B+ 树带有顺序访问的指针，并且利用了磁盘预读以及计算机局部性原理，相比 B 树和红黑树，B+ 树的磁盘IO数最少。具体原理看：<a href="https://www.cnblogs.com/tgycoder/p/5410057.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><blockquote><p>Reference:</p><ul><li>梁桂钊的知识星球 –「服务端思维」</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字: &lt;code&gt;幂等&lt;/code&gt;、&lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;异常处理&lt;/code&gt;、&lt;code&gt;B+ 树&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="沉淀" scheme="http://imbotao.top/tags/%E6%B2%89%E6%B7%80/"/>
    
  </entry>
  
  <entry>
    <title>问题沉淀「一」</title>
    <link href="http://imbotao.top/questions-share-1.html"/>
    <id>http://imbotao.top/questions-share-1.html</id>
    <published>2018-03-28T07:40:40.000Z</published>
    <updated>2019-05-10T03:32:28.597Z</updated>
    
    <content type="html"><![CDATA[<p>关键字: <code>mysql字符编码</code>、<code>索引</code>、<code>介绍项目</code>、<code>跨库跨表关联</code><br><a id="more"></a></p><p><strong>问题：</strong> 在 join 操作时，为什么 MySQL 编码不同，性能差距很大。<br><strong>解决方案：</strong><br>　　问题字符集转换遵循由小到大的原则，因为utf8mb4是utf8的超集，所以这里把utf8转换成utf8mb4，即把t1.code转换成utf8mb4字符集，转换了之后，由于t1.code上面的索引仍然是utf8字符集，所以这个索引就被执行计划忽略了，然后t1表只能选择全表扫描。更糟糕的是，如果t2筛选出来的记录不止1条，那么t1就会被全表扫描多次，性能之差可想而知。<a href="https://mp.weixin.qq.com/s/ns9eRxjXZfUPNSpfgGA7UA?from=groupmessage&amp;isappinstalled=0" target="_blank" rel="noopener">链接:MySQL表字段字符集不同导致的索引失效问题</a></p><hr><p><strong>问题：</strong> MySQL的最左前缀在第一字段不存在的情况下，为什么使用到了索引？<br><strong>解决方案：</strong><br>　　可以认真阅读这篇文章。<a href="https://www.zhihu.com/question/36996520?from=groupmessage&amp;isappinstalled=0" target="_blank" rel="noopener">链接：mysql索引最左匹配原则的理解? - 知乎</a></p><hr><p><strong>问题：</strong> 面试中面试官让谈一谈 MySQL 中的索引，怎么回答比较好？<br><strong>解决方案：</strong><br>　　MySQL是很常用的数据库，其中改善性能最好的方式，就是通过数据库中合理地使用索引。因此，首先可以谈谈在项目中如何设计索引。其次，索引使用的注意事项有哪些，例如复合索引的最左前缀原则，范围查询对多列查询的影响等。最后，如果面试官对原理比较感兴趣，可能再聊聊数据库索引的原理，为什么要用 B-tree，聚集索引与非聚集索引的区别这些问题。此外，加分项，还可以说说自己在项目中，遇到了哪些索引的难点，例如之前提到的编码转换的索引失效问题，以及通过曲线救国的方式满足业务场景。</p><hr><p><strong>问题：</strong> 如何介绍项目<br><strong>解决方案：</strong><br>　　面试官问这个问题，主要是考察你的概述能力和全局视野。当然，今天我们聊的并不是面试题，而是我们怎么去理解和复盘我们每天做的事情。有的人经常抱怨自己每天在堆业务，但没有成长。事实上，很多情况下确实在堆业务，但并不是没有成长的。并非做中间件或者技术架构才是成长，例如我们的需求分析能力，沟通协作能力，产品思维能力，抽象建模能力等都是一个非常重要的硬实力。首先，请你静下来思考，你真的了解自己每天在做的事情吗，你真的了解自己所做的业务吗？</p><p>  好的，现在进入正文，我们如何理解和复盘项目。这里，列了一个清单，请大家好好思考下这些内容。</p><ol><li>明确项目的周期。</li><li>明确项目的价值。（为什么做这个项目，它解决了用户什么痛点，它带来什么价值？）</li><li>明确项目的功能。（这个项目涉及哪些功能？）</li><li>明确项目的技术。（这个项目用到哪些技术？）</li><li>明确个人在项目中的位置和作用。（你在这个项目的承担角色？）</li><li>明确项目的整体架构。</li><li>明确项目的优缺点,如果重新设计你会如何设计。</li><li>明确项目的亮点。（这个项目有什么亮点？）</li><li>明确技术成长。（你通过这个项目有哪些技术成长？）</li></ol><hr><p><strong>问题：</strong> 分库与分表，联合查询就遇到跨库关联和跨表关系问题，那应该怎么办？<br><strong>解决方案：</strong> </p><ol><li>其实，数据量小的情况下，怎么使用都没有问题的。</li><li>如果在数据量大的情况下，不一定分库分表，单库也不行的。看阿里编码规范，禁止存储过程，尽量不要使用join，有也不要超过3个。</li><li>联合查询不一定性能就差，如果很多join，都能用到主键或者唯一键性能也不差的。</li><li>业务解偶，单张表也能更好缓存。</li><li>在单库单表的情况下，联合查询是非常容易的。但是，随着分库与分表的演变，联合查询就遇到跨库关联和跨表关系问题。在设计之初就应该尽量避免联合查询，可以通过程序中进行拼装，或者通过反范式化设计进行规避。</li></ol><blockquote><p>Reference:</p><ul><li>梁桂钊的知识星球 –「服务端思维」</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字: &lt;code&gt;mysql字符编码&lt;/code&gt;、&lt;code&gt;索引&lt;/code&gt;、&lt;code&gt;介绍项目&lt;/code&gt;、&lt;code&gt;跨库跨表关联&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="沉淀" scheme="http://imbotao.top/tags/%E6%B2%89%E6%B7%80/"/>
    
  </entry>
  
</feed>
